<?xml version="1.0" encoding="UTF-8"?>
<templateSet group="user">
  <template name="hook_search_info" value="/**&#10; * Implements hook_search_info().&#10; *&#10; * Define a custom search type.&#10; *&#10; * This hook allows a module to tell search.module that it wishes to perform&#10; * searches on content it defines (custom node types, users, or comments for&#10; * example) when a site search is performed.&#10; *&#10; * In order for the search to do anything, your module must also implement&#10; * hook_search_execute(), which is called when someone requests a search&#10; * on your module's type of content. If you want to have your content&#10; * indexed in the standard search index, your module should also implement&#10; * hook_update_index(). If your search type has settings, you can implement&#10; * hook_search_admin() to add them to the search settings page. You can also&#10; * alter the display of your module's search results by implementing&#10; * hook_search_page(). You can use hook_form_FORM_ID_alter(), with&#10; * FORM_ID set to 'search', to add fields to the search form (see&#10; * node_form_search_form_alter() for an example). You can use&#10; * hook_search_access() to limit access to searching, and hook_search_page() to&#10; * override how search results are displayed.&#10; *&#10; * @return&#10; *   Array with optional keys:&#10; *   - 'title': Title for the tab on the search page for this module. Defaults&#10; *     to the module name if not given.&#10; *   - 'path': Path component after 'search/' for searching with this module.&#10; *     Defaults to the module name if not given.&#10; *   - 'conditions_callback': Name of a callback function that is invoked by&#10; *     search_view() to get an array of additional search conditions to pass to&#10; *     search_data(). For example, a search module may get additional keywords,&#10; *     filters, or modifiers for the search from the query string. Sample&#10; *     callback function: sample_search_conditions_callback().&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_info() {&#10;  return array(&#10;    'title' =&gt; 'Content',&#10;    'path' =&gt; 'node',&#10;    'conditions_callback' =&gt; 'sample_search_conditions_callback',&#10;  );&#10;  $END$&#10;}" description="hook_search_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_info" value="/**&#10; * Implements hook_search_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_info() {&#10;  return array(&#10;    'title' =&gt; 'Content',&#10;    'path' =&gt; 'node',&#10;    'conditions_callback' =&gt; 'sample_search_conditions_callback',&#10;  );&#10;  $END$&#10;}" description="hook_search_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_access" value="/**&#10; * Implements hook_search_access().&#10; *&#10; * Define access to a custom search routine.&#10; *&#10; * This hook allows a module to define permissions for a search tab.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_access() {&#10;  return user_access('access content');&#10;  $END$&#10;}" description="hook_search_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_access" value="/**&#10; * Implements hook_search_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_access() {&#10;  return user_access('access content');&#10;  $END$&#10;}" description="hook_search_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_reset" value="/**&#10; * Implements hook_search_reset().&#10; *&#10; * Take action when the search index is going to be rebuilt.&#10; *&#10; * Modules that use hook_update_index() should update their indexing&#10; * bookkeeping so that it starts from scratch the next time&#10; * hook_update_index() is called.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_reset() {&#10;  db_update('search_dataset')&#10;    -&gt;fields(array('reindex' =&gt; REQUEST_TIME))&#10;    -&gt;condition('type', 'node')&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_search_reset" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_reset" value="/**&#10; * Implements hook_search_reset().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_reset() {&#10;  db_update('search_dataset')&#10;    -&gt;fields(array('reindex' =&gt; REQUEST_TIME))&#10;    -&gt;condition('type', 'node')&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_search_reset" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_status" value="/**&#10; * Implements hook_search_status().&#10; *&#10; * Report the status of indexing.&#10; *&#10; * The core search module only invokes this hook on active modules.&#10; * Implementing modules do not need to check whether they are active when&#10; * calculating their return values.&#10; *&#10; * @return&#10; *  An associative array with the key-value pairs:&#10; *  - 'remaining': The number of items left to index.&#10; *  - 'total': The total number of items to index.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_status() {&#10;  $total = db_query('SELECT COUNT(*) FROM {node} WHERE status = 1')-&gt;fetchField();&#10;  $remaining = db_query(&quot;SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND d.sid IS NULL OR d.reindex &lt;&gt; 0&quot;)-&gt;fetchField();&#10;  return array('remaining' =&gt; $remaining, 'total' =&gt; $total);&#10;  $END$&#10;}" description="hook_search_status" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_status" value="/**&#10; * Implements hook_search_status().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_status() {&#10;  $total = db_query('SELECT COUNT(*) FROM {node} WHERE status = 1')-&gt;fetchField();&#10;  $remaining = db_query(&quot;SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND d.sid IS NULL OR d.reindex &lt;&gt; 0&quot;)-&gt;fetchField();&#10;  return array('remaining' =&gt; $remaining, 'total' =&gt; $total);&#10;  $END$&#10;}" description="hook_search_status" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_admin" value="/**&#10; * Implements hook_search_admin().&#10; *&#10; * Add elements to the search settings form.&#10; *&#10; * @return&#10; *   Form array for the Search settings page at admin/config/search/settings.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_admin() {&#10;  // Output form for defining rank factor weights.&#10;  $form['content_ranking'] = array(&#10;    '#type' =&gt; 'fieldset',&#10;    '#title' =&gt; t('Content ranking'),&#10;  );&#10;  $form['content_ranking']['#theme'] = 'node_search_admin';&#10;  $form['content_ranking']['info'] = array(&#10;    '#value' =&gt; '&lt;em&gt;' . t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') . '&lt;/em&gt;'&#10;  );&#10;&#10;  // Note: reversed to reflect that higher number = higher ranking.&#10;  $options = drupal_map_assoc(range(0, 10));&#10;  foreach (module_invoke_all('ranking') as $var =&gt; $values) {&#10;    $form['content_ranking']['factors']['node_rank_' . $var] = array(&#10;      '#title' =&gt; $values['title'],&#10;      '#type' =&gt; 'select',&#10;      '#options' =&gt; $options,&#10;      '#default_value' =&gt; variable_get('node_rank_' . $var, 0),&#10;    );&#10;  }&#10;  return $form;&#10;  $END$&#10;}" description="hook_search_admin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_admin" value="/**&#10; * Implements hook_search_admin().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_admin() {&#10;  // Output form for defining rank factor weights.&#10;  $form['content_ranking'] = array(&#10;    '#type' =&gt; 'fieldset',&#10;    '#title' =&gt; t('Content ranking'),&#10;  );&#10;  $form['content_ranking']['#theme'] = 'node_search_admin';&#10;  $form['content_ranking']['info'] = array(&#10;    '#value' =&gt; '&lt;em&gt;' . t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') . '&lt;/em&gt;'&#10;  );&#10;&#10;  // Note: reversed to reflect that higher number = higher ranking.&#10;  $options = drupal_map_assoc(range(0, 10));&#10;  foreach (module_invoke_all('ranking') as $var =&gt; $values) {&#10;    $form['content_ranking']['factors']['node_rank_' . $var] = array(&#10;      '#title' =&gt; $values['title'],&#10;      '#type' =&gt; 'select',&#10;      '#options' =&gt; $options,&#10;      '#default_value' =&gt; variable_get('node_rank_' . $var, 0),&#10;    );&#10;  }&#10;  return $form;&#10;  $END$&#10;}" description="hook_search_admin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_execute" value="/**&#10; * Implements hook_search_execute().&#10; *&#10; * Execute a search for a set of key words.&#10; *&#10; * Use database API with the 'PagerDefault' query extension to perform your&#10; * search.&#10; *&#10; * If your module uses hook_update_index() and search_index() to index its&#10; * items, use table 'search_index' aliased to 'i' as the main table in your&#10; * query, with the 'SearchQuery' extension. You can join to your module's table&#10; * using the 'i.sid' field, which will contain the $sid values you provided to&#10; * search_index(). Add the main keywords to the query by using method&#10; * searchExpression(). The functions search_expression_extract() and&#10; * search_expression_insert() may also be helpful for adding custom search&#10; * parameters to the search expression.&#10; *&#10; * See node_search_execute() for an example of a module that uses the search&#10; * index, and user_search_execute() for an example that doesn't use the search&#10; * index.&#10; *&#10; * @param $keys&#10; *   The search keywords as entered by the user.&#10; * @param $conditions&#10; *   An optional array of additional conditions, such as filters.&#10; *&#10; * @return&#10; *   An array of search results. To use the default search result&#10; *   display, each item should have the following keys':&#10; *   - 'link': Required. The URL of the found item.&#10; *   - 'type': The type of item (such as the content type).&#10; *   - 'title': Required. The name of the item.&#10; *   - 'user': The author of the item.&#10; *   - 'date': A timestamp when the item was last modified.&#10; *   - 'extra': An array of optional extra information items.&#10; *   - 'snippet': An excerpt or preview to show with the result (can be&#10; *     generated with search_excerpt()).&#10; *   - 'language': Language code for the item (usually two characters).&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_execute($keys = NULL, $conditions = NULL) {&#10;  // Build matching conditions&#10;  $query = db_select('search_index', 'i', array('target' =&gt; 'slave'))-&gt;extend('SearchQuery')-&gt;extend('PagerDefault');&#10;  $query-&gt;join('node', 'n', 'n.nid = i.sid');&#10;  $query&#10;    -&gt;condition('n.status', 1)&#10;    -&gt;addTag('node_access')&#10;    -&gt;searchExpression($keys, 'node');&#10;&#10;  // Insert special keywords.&#10;  $query-&gt;setOption('type', 'n.type');&#10;  $query-&gt;setOption('language', 'n.language');&#10;  if ($query-&gt;setOption('term', 'ti.tid')) {&#10;    $query-&gt;join('taxonomy_index', 'ti', 'n.nid = ti.nid');&#10;  }&#10;  // Only continue if the first pass query matches.&#10;  if (!$query-&gt;executeFirstPass()) {&#10;    return array();&#10;  }&#10;&#10;  // Add the ranking expressions.&#10;  _node_rankings($query);&#10;&#10;  // Load results.&#10;  $find = $query&#10;    -&gt;limit(10)&#10;    -&gt;execute();&#10;  $results = array();&#10;  foreach ($find as $item) {&#10;    // Build the node body.&#10;    $node = node_load($item-&gt;sid);&#10;    node_build_content($node, 'search_result');&#10;    $node-&gt;body = drupal_render($node-&gt;content);&#10;&#10;    // Fetch comments for snippet.&#10;    $node-&gt;rendered .= ' ' . module_invoke('comment', 'node_update_index', $node);&#10;    // Fetch terms for snippet.&#10;    $node-&gt;rendered .= ' ' . module_invoke('taxonomy', 'node_update_index', $node);&#10;&#10;    $extra = module_invoke_all('node_search_result', $node);&#10;&#10;    $results[] = array(&#10;      'link' =&gt; url('node/' . $item-&gt;sid, array('absolute' =&gt; TRUE)),&#10;      'type' =&gt; check_plain(node_type_get_name($node)),&#10;      'title' =&gt; $node-&gt;title,&#10;      'user' =&gt; theme('username', array('account' =&gt; $node)),&#10;      'date' =&gt; $node-&gt;changed,&#10;      'node' =&gt; $node,&#10;      'extra' =&gt; $extra,&#10;      'score' =&gt; $item-&gt;calculated_score,&#10;      'snippet' =&gt; search_excerpt($keys, $node-&gt;body),&#10;    );&#10;  }&#10;  return $results;&#10;  $END$&#10;}" description="hook_search_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_execute" value="/**&#10; * Implements hook_search_execute().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_execute($keys = NULL, $conditions = NULL) {&#10;  // Build matching conditions&#10;  $query = db_select('search_index', 'i', array('target' =&gt; 'slave'))-&gt;extend('SearchQuery')-&gt;extend('PagerDefault');&#10;  $query-&gt;join('node', 'n', 'n.nid = i.sid');&#10;  $query&#10;    -&gt;condition('n.status', 1)&#10;    -&gt;addTag('node_access')&#10;    -&gt;searchExpression($keys, 'node');&#10;&#10;  // Insert special keywords.&#10;  $query-&gt;setOption('type', 'n.type');&#10;  $query-&gt;setOption('language', 'n.language');&#10;  if ($query-&gt;setOption('term', 'ti.tid')) {&#10;    $query-&gt;join('taxonomy_index', 'ti', 'n.nid = ti.nid');&#10;  }&#10;  // Only continue if the first pass query matches.&#10;  if (!$query-&gt;executeFirstPass()) {&#10;    return array();&#10;  }&#10;&#10;  // Add the ranking expressions.&#10;  _node_rankings($query);&#10;&#10;  // Load results.&#10;  $find = $query&#10;    -&gt;limit(10)&#10;    -&gt;execute();&#10;  $results = array();&#10;  foreach ($find as $item) {&#10;    // Build the node body.&#10;    $node = node_load($item-&gt;sid);&#10;    node_build_content($node, 'search_result');&#10;    $node-&gt;body = drupal_render($node-&gt;content);&#10;&#10;    // Fetch comments for snippet.&#10;    $node-&gt;rendered .= ' ' . module_invoke('comment', 'node_update_index', $node);&#10;    // Fetch terms for snippet.&#10;    $node-&gt;rendered .= ' ' . module_invoke('taxonomy', 'node_update_index', $node);&#10;&#10;    $extra = module_invoke_all('node_search_result', $node);&#10;&#10;    $results[] = array(&#10;      'link' =&gt; url('node/' . $item-&gt;sid, array('absolute' =&gt; TRUE)),&#10;      'type' =&gt; check_plain(node_type_get_name($node)),&#10;      'title' =&gt; $node-&gt;title,&#10;      'user' =&gt; theme('username', array('account' =&gt; $node)),&#10;      'date' =&gt; $node-&gt;changed,&#10;      'node' =&gt; $node,&#10;      'extra' =&gt; $extra,&#10;      'score' =&gt; $item-&gt;calculated_score,&#10;      'snippet' =&gt; search_excerpt($keys, $node-&gt;body),&#10;    );&#10;  }&#10;  return $results;&#10;  $END$&#10;}" description="hook_search_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_page" value="/**&#10; * Implements hook_search_page().&#10; *&#10; * Override the rendering of search results.&#10; *&#10; * A module that implements hook_search_info() to define a type of search&#10; * may implement this hook in order to override the default theming of&#10; * its search results, which is otherwise themed using theme('search_results').&#10; *&#10; * Note that by default, theme('search_results') and theme('search_result')&#10; * work together to create an ordered list (OL). So your hook_search_page()&#10; * implementation should probably do this as well.&#10; *&#10; * @see search-result.tpl.php, search-results.tpl.php&#10; *&#10; * @param $results&#10; *   An array of search results.&#10; *&#10; * @return&#10; *   A renderable array, which will render the formatted search results with&#10; *   a pager included.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_page($results) {&#10;  $output['prefix']['#markup'] = '&lt;ol class=&quot;search-results&quot;&gt;';&#10;&#10;  foreach ($results as $entry) {&#10;    $output[] = array(&#10;      '#theme' =&gt; 'search_result',&#10;      '#result' =&gt; $entry,&#10;      '#module' =&gt; 'my_module_name',&#10;    );&#10;  }&#10;  $output['suffix']['#markup'] = '&lt;/ol&gt;' . theme('pager');&#10;&#10;  return $output;&#10;  $END$&#10;}" description="hook_search_page" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_page" value="/**&#10; * Implements hook_search_page().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_page($results) {&#10;  $output['prefix']['#markup'] = '&lt;ol class=&quot;search-results&quot;&gt;';&#10;&#10;  foreach ($results as $entry) {&#10;    $output[] = array(&#10;      '#theme' =&gt; 'search_result',&#10;      '#result' =&gt; $entry,&#10;      '#module' =&gt; 'my_module_name',&#10;    );&#10;  }&#10;  $output['suffix']['#markup'] = '&lt;/ol&gt;' . theme('pager');&#10;&#10;  return $output;&#10;  $END$&#10;}" description="hook_search_page" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_search_preprocess" value="/**&#10; * Implements hook_search_preprocess().&#10; *&#10; * Preprocess text for search.&#10; *&#10; * This hook is called to preprocess both the text added to the search index and&#10; * the keywords users have submitted for searching.&#10; *&#10; * Possible uses:&#10; * - Adding spaces between words of Chinese or Japanese text.&#10; * - Stemming words down to their root words to allow matches between, for&#10; *   instance, walk, walked, walking, and walks in searching.&#10; * - Expanding abbreviations and acronymns that occur in text.&#10; *&#10; * @param $text&#10; *   The text to preprocess. This is a single piece of plain text extracted&#10; *   from between two HTML tags or from the search query. It will not contain&#10; *   any HTML entities or HTML tags.&#10; *&#10; * @return&#10; *   The text after preprocessing. Note that if your module decides not to alter&#10; *   the text, it should return the original text. Also, after preprocessing,&#10; *   words in the text should be separated by a space.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_preprocess($text) {&#10;  // Do processing on $text&#10;  return $text;&#10;  $END$&#10;}" description="hook_search_preprocess" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_search_preprocess" value="/**&#10; * Implements hook_search_preprocess().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_search_preprocess($text) {&#10;  // Do processing on $text&#10;  return $text;&#10;  $END$&#10;}" description="hook_search_preprocess" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_index" value="/**&#10; * Implements hook_update_index().&#10; *&#10; * Update the search index for this module.&#10; *&#10; * This hook is called every cron run if search.module is enabled, your&#10; * module has implemented hook_search_info(), and your module has been set as&#10; * an active search module on the Search settings page&#10; * (admin/config/search/settings). It allows your module to add items to the&#10; * built-in search index using search_index(), or to add them to your module's&#10; * own indexing mechanism.&#10; *&#10; * When implementing this hook, your module should index content items that&#10; * were modified or added since the last run. PHP has a time limit&#10; * for cron, though, so it is advisable to limit how many items you index&#10; * per run using variable_get('search_cron_limit') (see example below). Also,&#10; * since the cron run could time out and abort in the middle of your run, you&#10; * should update your module's internal bookkeeping on when items have last&#10; * been indexed as you go rather than waiting to the end of indexing.&#10; *&#10; * @ingroup search&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_index() {&#10;  $limit = (int)variable_get('search_cron_limit', 100);&#10;&#10;  $result = db_query_range(&quot;SELECT n.nid FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex &lt;&gt; 0 ORDER BY d.reindex ASC, n.nid ASC&quot;, 0, $limit);&#10;&#10;  foreach ($result as $node) {&#10;    $node = node_load($node-&gt;nid);&#10;&#10;    // Save the changed time of the most recent indexed node, for the search&#10;    // results half-life calculation.&#10;    variable_set('node_cron_last', $node-&gt;changed);&#10;&#10;    // Render the node.&#10;    node_build_content($node, 'search_index');&#10;    $node-&gt;rendered = drupal_render($node-&gt;content);&#10;&#10;    $text = '&lt;h1&gt;' . check_plain($node-&gt;title) . '&lt;/h1&gt;' . $node-&gt;rendered;&#10;&#10;    // Fetch extra data normally not visible&#10;    $extra = module_invoke_all('node_update_index', $node);&#10;    foreach ($extra as $t) {&#10;      $text .= $t;&#10;    }&#10;&#10;    // Update index&#10;    search_index($node-&gt;nid, 'node', $text);&#10;  }&#10;  $END$&#10;}" description="hook_update_index" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_index" value="/**&#10; * Implements hook_update_index().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_index() {&#10;  $limit = (int)variable_get('search_cron_limit', 100);&#10;&#10;  $result = db_query_range(&quot;SELECT n.nid FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex &lt;&gt; 0 ORDER BY d.reindex ASC, n.nid ASC&quot;, 0, $limit);&#10;&#10;  foreach ($result as $node) {&#10;    $node = node_load($node-&gt;nid);&#10;&#10;    // Save the changed time of the most recent indexed node, for the search&#10;    // results half-life calculation.&#10;    variable_set('node_cron_last', $node-&gt;changed);&#10;&#10;    // Render the node.&#10;    node_build_content($node, 'search_index');&#10;    $node-&gt;rendered = drupal_render($node-&gt;content);&#10;&#10;    $text = '&lt;h1&gt;' . check_plain($node-&gt;title) . '&lt;/h1&gt;' . $node-&gt;rendered;&#10;&#10;    // Fetch extra data normally not visible&#10;    $extra = module_invoke_all('node_update_index', $node);&#10;    foreach ($extra as $t) {&#10;      $text .= $t;&#10;    }&#10;&#10;    // Update index&#10;    search_index($node-&gt;nid, 'node', $text);&#10;  }&#10;  $END$&#10;}" description="hook_update_index" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_effect_info" value="/**&#10; * Implements hook_image_effect_info().&#10; *&#10; * Define information about image effects provided by a module.&#10; *&#10; * This hook enables modules to define image manipulation effects for use with&#10; * an image style.&#10; *&#10; * @return&#10; *   An array of image effects. This array is keyed on the machine-readable&#10; *   effect name. Each effect is defined as an associative array containing the&#10; *   following items:&#10; *   - &quot;label&quot;: The human-readable name of the effect.&#10; *   - &quot;effect callback&quot;: The function to call to perform this image effect.&#10; *   - &quot;dimensions passthrough&quot;: (optional) Set this item if the effect doesn't&#10; *     change the dimensions of the image.&#10; *   - &quot;dimensions callback&quot;: (optional) The function to call to transform&#10; *     dimensions for this effect.&#10; *   - &quot;help&quot;: (optional) A brief description of the effect that will be shown&#10; *     when adding or configuring this image effect.&#10; *   - &quot;form callback&quot;: (optional) The name of a function that will return a&#10; *     $form array providing a configuration form for this image effect.&#10; *   - &quot;summary theme&quot;: (optional) The name of a theme function that will output&#10; *     a summary of this image effect's configuration.&#10; *&#10; * @see hook_image_effect_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_effect_info() {&#10;  $effects = array();&#10;&#10;  $effects['mymodule_resize'] = array(&#10;    'label' =&gt; t('Resize'),&#10;    'help' =&gt; t('Resize an image to an exact set of dimensions, ignoring aspect ratio.'),&#10;    'effect callback' =&gt; 'mymodule_resize_effect',&#10;    'dimensions callback' =&gt; 'mymodule_resize_dimensions',&#10;    'form callback' =&gt; 'mymodule_resize_form',&#10;    'summary theme' =&gt; 'mymodule_resize_summary',&#10;  );&#10;&#10;  return $effects;&#10;  $END$&#10;}" description="hook_image_effect_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_effect_info" value="/**&#10; * Implements hook_image_effect_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_effect_info() {&#10;  $effects = array();&#10;&#10;  $effects['mymodule_resize'] = array(&#10;    'label' =&gt; t('Resize'),&#10;    'help' =&gt; t('Resize an image to an exact set of dimensions, ignoring aspect ratio.'),&#10;    'effect callback' =&gt; 'mymodule_resize_effect',&#10;    'dimensions callback' =&gt; 'mymodule_resize_dimensions',&#10;    'form callback' =&gt; 'mymodule_resize_form',&#10;    'summary theme' =&gt; 'mymodule_resize_summary',&#10;  );&#10;&#10;  return $effects;&#10;  $END$&#10;}" description="hook_image_effect_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_effect_info_alter" value="/**&#10; * Implements hook_image_effect_info_alter().&#10; *&#10; * Alter the information provided in hook_image_effect_info().&#10; *&#10; * @param $effects&#10; *   The array of image effects, keyed on the machine-readable effect name.&#10; *&#10; * @see hook_image_effect_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_effect_info_alter(&amp;$effects) {&#10;  // Override the Image module's crop effect with more options.&#10;  $effects['image_crop']['effect callback'] = 'mymodule_crop_effect';&#10;  $effects['image_crop']['dimensions callback'] = 'mymodule_crop_dimensions';&#10;  $effects['image_crop']['form callback'] = 'mymodule_crop_form';&#10;  $END$&#10;}" description="hook_image_effect_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_effect_info_alter" value="/**&#10; * Implements hook_image_effect_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_effect_info_alter(&amp;$effects) {&#10;  // Override the Image module's crop effect with more options.&#10;  $effects['image_crop']['effect callback'] = 'mymodule_crop_effect';&#10;  $effects['image_crop']['dimensions callback'] = 'mymodule_crop_dimensions';&#10;  $effects['image_crop']['form callback'] = 'mymodule_crop_form';&#10;  $END$&#10;}" description="hook_image_effect_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_style_save" value="/**&#10; * Implements hook_image_style_save().&#10; *&#10; * Respond to image style updating.&#10; *&#10; * This hook enables modules to update settings that might be affected by&#10; * changes to an image. For example, updating a module specific variable to&#10; * reflect a change in the image style's name.&#10; *&#10; * @param $style&#10; *   The image style array that is being updated.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_save($style) {&#10;  // If a module defines an image style and that style is renamed by the user&#10;  // the module should update any references to that style.&#10;  if (isset($style['old_name']) &amp;&amp; $style['old_name'] == variable_get('mymodule_image_style', '')) {&#10;    variable_set('mymodule_image_style', $style['name']);&#10;  }&#10;  $END$&#10;}" description="hook_image_style_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_style_save" value="/**&#10; * Implements hook_image_style_save().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_save($style) {&#10;  // If a module defines an image style and that style is renamed by the user&#10;  // the module should update any references to that style.&#10;  if (isset($style['old_name']) &amp;&amp; $style['old_name'] == variable_get('mymodule_image_style', '')) {&#10;    variable_set('mymodule_image_style', $style['name']);&#10;  }&#10;  $END$&#10;}" description="hook_image_style_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_style_delete" value="/**&#10; * Implements hook_image_style_delete().&#10; *&#10; * Respond to image style deletion.&#10; *&#10; * This hook enables modules to update settings when a image style is being&#10; * deleted. If a style is deleted, a replacement name may be specified in&#10; * $style['name'] and the style being deleted will be specified in&#10; * $style['old_name'].&#10; *&#10; * @param $style&#10; *   The image style array that being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_delete($style) {&#10;  // Administrators can choose an optional replacement style when deleting.&#10;  // Update the modules style variable accordingly.&#10;  if (isset($style['old_name']) &amp;&amp; $style['old_name'] == variable_get('mymodule_image_style', '')) {&#10;    variable_set('mymodule_image_style', $style['name']);&#10;  }&#10;  $END$&#10;}" description="hook_image_style_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_style_delete" value="/**&#10; * Implements hook_image_style_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_delete($style) {&#10;  // Administrators can choose an optional replacement style when deleting.&#10;  // Update the modules style variable accordingly.&#10;  if (isset($style['old_name']) &amp;&amp; $style['old_name'] == variable_get('mymodule_image_style', '')) {&#10;    variable_set('mymodule_image_style', $style['name']);&#10;  }&#10;  $END$&#10;}" description="hook_image_style_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_style_flush" value="/**&#10; * Implements hook_image_style_flush().&#10; *&#10; * Respond to image style flushing.&#10; *&#10; * This hook enables modules to take effect when a style is being flushed (all&#10; * images are being deleted from the server and regenerated). Any&#10; * module-specific caches that contain information related to the style should&#10; * be cleared using this hook. This hook is called whenever a style is updated,&#10; * deleted, or any effect associated with the style is update or deleted.&#10; *&#10; * @param $style&#10; *   The image style array that is being flushed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_flush($style) {&#10;  // Empty cached data that contains information about the style.&#10;  cache_clear_all('*', 'cache_mymodule', TRUE);&#10;  $END$&#10;}" description="hook_image_style_flush" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_style_flush" value="/**&#10; * Implements hook_image_style_flush().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_style_flush($style) {&#10;  // Empty cached data that contains information about the style.&#10;  cache_clear_all('*', 'cache_mymodule', TRUE);&#10;  $END$&#10;}" description="hook_image_style_flush" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_styles_alter" value="/**&#10; * Implements hook_image_styles_alter().&#10; *&#10; * Modify any image styles provided by other modules or the user.&#10; *&#10; * This hook allows modules to modify, add, or remove image styles. This may&#10; * be useful to modify default styles provided by other modules or enforce&#10; * that a specific effect is always enabled on a style. Note that modifications&#10; * to these styles may negatively affect the user experience, such as if an&#10; * effect is added to a style through this hook, the user may attempt to remove&#10; * the effect but it will be immediately be re-added.&#10; *&#10; * The best use of this hook is usually to modify default styles, which are not&#10; * editable by the user until they are overridden, so such interface&#10; * contradictions will not occur. This hook can target default (or user) styles&#10; * by checking the $style['storage'] property.&#10; *&#10; * If your module needs to provide a new style (rather than modify an existing&#10; * one) use hook_image_default_styles() instead.&#10; *&#10; * @see hook_image_default_styles()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_styles_alter(&amp;$styles) {&#10;  // Check that we only affect a default style.&#10;  if ($styles['thumbnail']['storage'] == IMAGE_STORAGE_DEFAULT) {&#10;    // Add an additional effect to the thumbnail style.&#10;    $styles['thumbnail']['effects'][] = array(&#10;      'name' =&gt; 'image_desaturate',&#10;      'data' =&gt; array(),&#10;      'weight' =&gt; 1,&#10;      'effect callback' =&gt; 'image_desaturate_effect',&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_image_styles_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_styles_alter" value="/**&#10; * Implements hook_image_styles_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_styles_alter(&amp;$styles) {&#10;  // Check that we only affect a default style.&#10;  if ($styles['thumbnail']['storage'] == IMAGE_STORAGE_DEFAULT) {&#10;    // Add an additional effect to the thumbnail style.&#10;    $styles['thumbnail']['effects'][] = array(&#10;      'name' =&gt; 'image_desaturate',&#10;      'data' =&gt; array(),&#10;      'weight' =&gt; 1,&#10;      'effect callback' =&gt; 'image_desaturate_effect',&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_image_styles_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_default_styles" value="/**&#10; * Implements hook_image_default_styles().&#10; *&#10; * Provide module-based image styles for reuse throughout Drupal.&#10; *&#10; * This hook allows your module to provide image styles. This may be useful if&#10; * you require images to fit within exact dimensions. Note that you should&#10; * attempt to re-use the default styles provided by Image module whenever&#10; * possible, rather than creating image styles that are specific to your module.&#10; * Image provides the styles &quot;thumbnail&quot;, &quot;medium&quot;, and &quot;large&quot;.&#10; *&#10; * You may use this hook to more easily manage your site's changes by moving&#10; * existing image styles from the database to a custom module. Note however that&#10; * moving image styles to code instead storing them in the database has a&#10; * negligible effect on performance, since custom image styles are loaded&#10; * from the database all at once. Even if all styles are pulled from modules,&#10; * Image module will still perform the same queries to check the database for&#10; * any custom styles.&#10; *&#10; * @return&#10; *   An array of image styles, keyed by the style name.&#10; * @see image_image_default_styles()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_default_styles() {&#10;  $styles = array();&#10;&#10;  $styles['mymodule_preview'] = array(&#10;    'effects' =&gt; array(&#10;      array(&#10;        'name' =&gt; 'image_scale',&#10;        'data' =&gt; array('width' =&gt; 400, 'height' =&gt; 400, 'upscale' =&gt; 1),&#10;        'weight' =&gt; 0,&#10;      ),&#10;      array(&#10;        'name' =&gt; 'image_desaturate',&#10;        'data' =&gt; array(),&#10;        'weight' =&gt; 1,&#10;      ),&#10;    ),&#10;  );&#10;&#10;  return $styles;&#10;  $END$&#10;}" description="hook_image_default_styles" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_default_styles" value="/**&#10; * Implements hook_image_default_styles().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_default_styles() {&#10;  $styles = array();&#10;&#10;  $styles['mymodule_preview'] = array(&#10;    'effects' =&gt; array(&#10;      array(&#10;        'name' =&gt; 'image_scale',&#10;        'data' =&gt; array('width' =&gt; 400, 'height' =&gt; 400, 'upscale' =&gt; 1),&#10;        'weight' =&gt; 0,&#10;      ),&#10;      array(&#10;        'name' =&gt; 'image_desaturate',&#10;        'data' =&gt; array(),&#10;        'weight' =&gt; 1,&#10;      ),&#10;    ),&#10;  );&#10;&#10;  return $styles;&#10;  $END$&#10;}" description="hook_image_default_styles" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_projects_alter" value="/**&#10; * Implements hook_update_projects_alter().&#10; *&#10; * Alter the list of projects before fetching data and comparing versions.&#10; *&#10; * Most modules will never need to implement this hook. It is for advanced&#10; * interaction with the update status module: mere mortals need not apply.&#10; * The primary use-case for this hook is to add projects to the list, for&#10; * example, to provide update status data on disabled modules and themes. A&#10; * contributed module might want to hide projects from the list, for example,&#10; * if there is a site-specific module that doesn't have any official releases,&#10; * that module could remove itself from this list to avoid &quot;No available&#10; * releases found&quot; warnings on the available updates report. In rare cases, a&#10; * module might want to alter the data associated with a project already in&#10; * the list.&#10; *&#10; * @param $projects&#10; *   Reference to an array of the projects installed on the system. This&#10; *   includes all the metadata documented in the comments below for each&#10; *   project (either module or theme) that is currently enabled. The array is&#10; *   initially populated inside update_get_projects() with the help of&#10; *   _update_process_info_list(), so look there for examples of how to&#10; *   populate the array with real values.&#10; *&#10; * @see update_get_projects()&#10; * @see _update_process_info_list()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_projects_alter(&amp;$projects) {&#10;  // Hide a site-specific module from the list.&#10;  unset($projects['site_specific_module']);&#10;&#10;  // Add a disabled module to the list.&#10;  // The key for the array should be the machine-readable project &quot;short name&quot;.&#10;  $projects['disabled_project_name'] = array(&#10;    // Machine-readable project short name (same as the array key above).&#10;    'name' =&gt; 'disabled_project_name',&#10;    // Array of values from the main .info file for this project.&#10;    'info' =&gt; array(&#10;      'name' =&gt; 'Some disabled module',&#10;      'description' =&gt; 'A module not enabled on the site that you want to see in the available updates report.',&#10;      'version' =&gt; '7.x-1.0',&#10;      'core' =&gt; '7.x',&#10;      // The maximum file change time (the &quot;ctime&quot; returned by the filectime()&#10;      // PHP method) for all of the .info files included in this project.&#10;      '_info_file_ctime' =&gt; 1243888165,&#10;    ),&#10;    // The date stamp when the project was released, if known. If the disabled&#10;    // project was an officially packaged release from drupal.org, this will&#10;    // be included in the .info file as the 'datestamp' field. This only&#10;    // really matters for development snapshot releases that are regenerated,&#10;    // so it can be left undefined or set to 0 in most cases.&#10;    'datestamp' =&gt; 1243888185,&#10;    // Any modules (or themes) included in this project. Keyed by machine-&#10;    // readable &quot;short name&quot;, value is the human-readable project name printed&#10;    // in the UI.&#10;    'includes' =&gt; array(&#10;      'disabled_project' =&gt; 'Disabled module',&#10;      'disabled_project_helper' =&gt; 'Disabled module helper module',&#10;      'disabled_project_foo' =&gt; 'Disabled module foo add-on module',&#10;    ),&#10;    // Does this project contain a 'module', 'theme', 'disabled-module', or&#10;    // 'disabled-theme'?&#10;    'project_type' =&gt; 'disabled-module',&#10;  );&#10;  $END$&#10;}" description="hook_update_projects_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_projects_alter" value="/**&#10; * Implements hook_update_projects_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_projects_alter(&amp;$projects) {&#10;  // Hide a site-specific module from the list.&#10;  unset($projects['site_specific_module']);&#10;&#10;  // Add a disabled module to the list.&#10;  // The key for the array should be the machine-readable project &quot;short name&quot;.&#10;  $projects['disabled_project_name'] = array(&#10;    // Machine-readable project short name (same as the array key above).&#10;    'name' =&gt; 'disabled_project_name',&#10;    // Array of values from the main .info file for this project.&#10;    'info' =&gt; array(&#10;      'name' =&gt; 'Some disabled module',&#10;      'description' =&gt; 'A module not enabled on the site that you want to see in the available updates report.',&#10;      'version' =&gt; '7.x-1.0',&#10;      'core' =&gt; '7.x',&#10;      // The maximum file change time (the &quot;ctime&quot; returned by the filectime()&#10;      // PHP method) for all of the .info files included in this project.&#10;      '_info_file_ctime' =&gt; 1243888165,&#10;    ),&#10;    // The date stamp when the project was released, if known. If the disabled&#10;    // project was an officially packaged release from drupal.org, this will&#10;    // be included in the .info file as the 'datestamp' field. This only&#10;    // really matters for development snapshot releases that are regenerated,&#10;    // so it can be left undefined or set to 0 in most cases.&#10;    'datestamp' =&gt; 1243888185,&#10;    // Any modules (or themes) included in this project. Keyed by machine-&#10;    // readable &quot;short name&quot;, value is the human-readable project name printed&#10;    // in the UI.&#10;    'includes' =&gt; array(&#10;      'disabled_project' =&gt; 'Disabled module',&#10;      'disabled_project_helper' =&gt; 'Disabled module helper module',&#10;      'disabled_project_foo' =&gt; 'Disabled module foo add-on module',&#10;    ),&#10;    // Does this project contain a 'module', 'theme', 'disabled-module', or&#10;    // 'disabled-theme'?&#10;    'project_type' =&gt; 'disabled-module',&#10;  );&#10;  $END$&#10;}" description="hook_update_projects_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_status_alter" value="/**&#10; * Implements hook_update_status_alter().&#10; *&#10; * Alter the information about available updates for projects.&#10; *&#10; * @param $projects&#10; *   Reference to an array of information about available updates to each&#10; *   project installed on the system.&#10; *&#10; * @see update_calculate_project_data()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_status_alter(&amp;$projects) {&#10;  $settings = variable_get('update_advanced_project_settings', array());&#10;  foreach ($projects as $project =&gt; $project_info) {&#10;    if (isset($settings[$project]) &amp;&amp; isset($settings[$project]['check']) &amp;&amp;&#10;        ($settings[$project]['check'] == 'never' ||&#10;          (isset($project_info['recommended']) &amp;&amp;&#10;            $settings[$project]['check'] === $project_info['recommended']))) {&#10;      $projects[$project]['status'] = UPDATE_NOT_CHECKED;&#10;      $projects[$project]['reason'] = t('Ignored from settings');&#10;      if (!empty($settings[$project]['notes'])) {&#10;        $projects[$project]['extra'][] = array(&#10;          'class' =&gt; array('admin-note'),&#10;          'label' =&gt; t('Administrator note'),&#10;          'data' =&gt; $settings[$project]['notes'],&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_update_status_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_status_alter" value="/**&#10; * Implements hook_update_status_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_status_alter(&amp;$projects) {&#10;  $settings = variable_get('update_advanced_project_settings', array());&#10;  foreach ($projects as $project =&gt; $project_info) {&#10;    if (isset($settings[$project]) &amp;&amp; isset($settings[$project]['check']) &amp;&amp;&#10;        ($settings[$project]['check'] == 'never' ||&#10;          (isset($project_info['recommended']) &amp;&amp;&#10;            $settings[$project]['check'] === $project_info['recommended']))) {&#10;      $projects[$project]['status'] = UPDATE_NOT_CHECKED;&#10;      $projects[$project]['reason'] = t('Ignored from settings');&#10;      if (!empty($settings[$project]['notes'])) {&#10;        $projects[$project]['extra'][] = array(&#10;          'class' =&gt; array('admin-note'),&#10;          'label' =&gt; t('Administrator note'),&#10;          'data' =&gt; $settings[$project]['notes'],&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_update_status_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_verify_update_archive" value="/**&#10; * Implements hook_verify_update_archive().&#10; *&#10; * Verify an archive after it has been downloaded and extracted.&#10; *&#10; * @param string $project&#10; *   The short name of the project that has been downloaded.&#10; * @param string $archive_file&#10; *   The filename of the unextracted archive.&#10; * @param string $directory&#10; *   The directory that the archive was extracted into.&#10; *&#10; * @return&#10; *   If there are any problems, return an array of error messages. If there are&#10; *   no problems, return an empty array.&#10; *&#10; * @see update_manager_archive_verify()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_verify_update_archive($project, $archive_file, $directory) {&#10;  $errors = array();&#10;  if (!file_exists($directory)) {&#10;    $errors[] = t('The %directory does not exist.', array('%directory' =&gt; $directory));&#10;  }&#10;  // Add other checks on the archive integrity here.&#10;  return $errors;&#10;  $END$&#10;}" description="hook_verify_update_archive" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_verify_update_archive" value="/**&#10; * Implements hook_verify_update_archive().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_verify_update_archive($project, $archive_file, $directory) {&#10;  $errors = array();&#10;  if (!file_exists($directory)) {&#10;    $errors[] = t('The %directory does not exist.', array('%directory' =&gt; $directory));&#10;  }&#10;  // Add other checks on the archive integrity here.&#10;  return $errors;&#10;  $END$&#10;}" description="hook_verify_update_archive" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_simpletest_alter" value="/**&#10; * Implements hook_simpletest_alter().&#10; *&#10; * Alter the list of tests.&#10; *&#10; * @param $groups&#10; *   A two dimension array, the first key is the test group (as defined in&#10; *   getInfo) the second is the name of the class and the value is the return&#10; *   value of the getInfo method.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_simpletest_alter(&amp;$groups) {&#10;  // An alternative session handler module would not want to run the original&#10;  // Session https handling test because it checks the sessions table in the&#10;  // database.&#10;  unset($groups['Session']['testHttpsSession']);&#10;  $END$&#10;}" description="hook_simpletest_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_simpletest_alter" value="/**&#10; * Implements hook_simpletest_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_simpletest_alter(&amp;$groups) {&#10;  // An alternative session handler module would not want to run the original&#10;  // Session https handling test because it checks the sessions table in the&#10;  // database.&#10;  unset($groups['Session']['testHttpsSession']);&#10;  $END$&#10;}" description="hook_simpletest_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_test_group_started" value="/**&#10; * Implements hook_test_group_started().&#10; *&#10; * A test group has started.&#10; *&#10; * This hook is called just once at the beginning of a test group.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_group_started() {&#10;  $END$&#10;}" description="hook_test_group_started" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_test_group_started" value="/**&#10; * Implements hook_test_group_started().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_group_started() {&#10;  $END$&#10;}" description="hook_test_group_started" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_test_group_finished" value="/**&#10; * Implements hook_test_group_finished().&#10; *&#10; * A test group has finished.&#10; *&#10; * This hook is called just once at the end of a test group.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_group_finished() {&#10;  $END$&#10;}" description="hook_test_group_finished" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_test_group_finished" value="/**&#10; * Implements hook_test_group_finished().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_group_finished() {&#10;  $END$&#10;}" description="hook_test_group_finished" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_test_finished" value="/**&#10; * Implements hook_test_finished().&#10; *&#10; * An individual test has finished.&#10; *&#10; * This hook is called when an individual test has finished.&#10; *&#10; * @param&#10; *   $results The results of the test as gathered by DrupalWebTestCase.&#10; *&#10; * @see DrupalWebTestCase-&gt;results&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_finished($results) {&#10;  $END$&#10;}" description="hook_test_finished" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_test_finished" value="/**&#10; * Implements hook_test_finished().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_test_finished($results) {&#10;  $END$&#10;}" description="hook_test_finished" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_path_insert" value="/**&#10; * Implements hook_path_insert().&#10; *&#10; * Allow modules to respond to a path being inserted.&#10; *&#10; * @param $path&#10; *   An associative array containing the following keys:&#10; *   - source: The internal system path.&#10; *   - alias: The URL alias.&#10; *   - pid: Unique path alias identifier.&#10; *   - language: The language of the alias.&#10; *&#10; * @see path_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_insert($path) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'alias' =&gt; $path['alias'],&#10;      'pid' =&gt; $path['pid'],&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_path_insert" value="/**&#10; * Implements hook_path_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_insert($path) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'alias' =&gt; $path['alias'],&#10;      'pid' =&gt; $path['pid'],&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_path_update" value="/**&#10; * Implements hook_path_update().&#10; *&#10; * Allow modules to respond to a path being updated.&#10; *&#10; * @param $path&#10; *   An associative array containing the following keys:&#10; *   - source: The internal system path.&#10; *   - alias: The URL alias.&#10; *   - pid: Unique path alias identifier.&#10; *   - language: The language of the alias.&#10; *&#10; * @see path_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_update($path) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('alias' =&gt; $path['alias']))&#10;    -&gt;condition('pid', $path['pid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_path_update" value="/**&#10; * Implements hook_path_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_update($path) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('alias' =&gt; $path['alias']))&#10;    -&gt;condition('pid', $path['pid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_path_delete" value="/**&#10; * Implements hook_path_delete().&#10; *&#10; * Allow modules to respond to a path being deleted.&#10; *&#10; * @param $path&#10; *   An associative array containing the following keys:&#10; *   - source: The internal system path.&#10; *   - alias: The URL alias.&#10; *   - pid: Unique path alias identifier.&#10; *   - language: The language of the alias.&#10; *&#10; * @see path_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_delete($path) {&#10;  db_delete('mytable')&#10;    -&gt;condition('pid', $path['pid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_path_delete" value="/**&#10; * Implements hook_path_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_delete($path) {&#10;  db_delete('mytable')&#10;    -&gt;condition('pid', $path['pid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_path_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_contextual_links_view_alter" value="/**&#10; * Implements hook_contextual_links_view_alter().&#10; *&#10; * Alter a contextual links element before it is rendered.&#10; *&#10; * This hook is invoked by contextual_pre_render_links(). The renderable array&#10; * of #type 'contextual_links', containing the entire contextual links data that&#10; * is passed in by reference. Further links may be added or existing links can&#10; * be altered.&#10; *&#10; * @param $element&#10; *   A renderable array representing the contextual links.&#10; * @param $items&#10; *   An associative array containing the original contextual link items, as&#10; *   generated by menu_contextual_links(), which were used to build&#10; *   $element['#links'].&#10; *&#10; * @see hook_menu_contextual_links_alter()&#10; * @see contextual_pre_render_links()&#10; * @see contextual_element_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_contextual_links_view_alter(&amp;$element, $items) {&#10;  // Add another class to all contextual link lists to facilitate custom&#10;  // styling.&#10;  $element['#attributes']['class'][] = 'custom-class';&#10;  $END$&#10;}" description="hook_contextual_links_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_contextual_links_view_alter" value="/**&#10; * Implements hook_contextual_links_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_contextual_links_view_alter(&amp;$element, $items) {&#10;  // Add another class to all contextual link lists to facilitate custom&#10;  // styling.&#10;  $element['#attributes']['class'][] = 'custom-class';&#10;  $END$&#10;}" description="hook_contextual_links_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_grants" value="/**&#10; * Implements hook_node_grants().&#10; *&#10; * Inform the node access system what permissions the user has.&#10; *&#10; * This hook is for implementation by node access modules. In this hook,&#10; * the module grants a user different &quot;grant IDs&quot; within one or more&#10; * &quot;realms&quot;. In hook_node_access_records(), the realms and grant IDs are&#10; * associated with permission to view, edit, and delete individual nodes.&#10; *&#10; * The realms and grant IDs can be arbitrarily defined by your node access&#10; * module; it is common to use role IDs as grant IDs, but that is not&#10; * required. Your module could instead maintain its own list of users, where&#10; * each list has an ID. In that case, the return value of this hook would be&#10; * an array of the list IDs that this user is a member of.&#10; *&#10; * A node access module may implement as many realms as necessary to&#10; * properly define the access privileges for the nodes. Note that the system&#10; * makes no distinction between published and unpublished nodes. It is the&#10; * module's responsibility to provide appropriate realms to limit access to&#10; * unpublished content.&#10; *&#10; * Node access records are stored in the {node_access} table and define which&#10; * grants are required to access a node. There is a special case for the view&#10; * operation -- a record with node ID 0 corresponds to a &quot;view all&quot; grant for&#10; * the realm and grant ID of that record. If there are no node access modules&#10; * enabled, the core node module adds a node ID 0 record for realm 'all'. Node&#10; * access modules can also grant &quot;view all&quot; permission on their custom realms;&#10; * for example, a module could create a record in {node_access} with:&#10; * @code&#10; * $record = array(&#10; *   'nid' =&gt; 0,&#10; *   'gid' =&gt; 888,&#10; *   'realm' =&gt; 'example_realm',&#10; *   'grant_view' =&gt; 1,&#10; *   'grant_update' =&gt; 0,&#10; *   'grant_delete' =&gt; 0,&#10; * );&#10; * drupal_write_record('node_access', $record);&#10; * @endcode&#10; * And then in its hook_node_grants() implementation, it would need to return:&#10; * @code&#10; * if ($op == 'view') {&#10; *   $grants['example_realm'] = array(888);&#10; * }&#10; * @endcode&#10; * If you decide to do this, be aware that the node_access_rebuild() function&#10; * will erase any node ID 0 entry when it is called, so you will need to make&#10; * sure to restore your {node_access} record after node_access_rebuild() is&#10; * called.&#10; *&#10; * @see node_access_view_all_nodes()&#10; * @see node_access_rebuild()&#10; *&#10; * @param $account&#10; *   The user object whose grants are requested.&#10; * @param $op&#10; *   The node operation to be performed, such as &quot;view&quot;, &quot;update&quot;, or &quot;delete&quot;.&#10; *&#10; * @return&#10; *   An array whose keys are &quot;realms&quot; of grants, and whose values are arrays of&#10; *   the grant IDs within this realm that this user is being granted.&#10; *&#10; * For a detailed example, see node_access_example.module.&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_grants($account, $op) {&#10;  if (user_access('access private content', $account)) {&#10;    $grants['example'] = array(1);&#10;  }&#10;  $grants['example_owner'] = array($account-&gt;uid);&#10;  return $grants;&#10;  $END$&#10;}" description="hook_node_grants" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_grants" value="/**&#10; * Implements hook_node_grants().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_grants($account, $op) {&#10;  if (user_access('access private content', $account)) {&#10;    $grants['example'] = array(1);&#10;  }&#10;  $grants['example_owner'] = array($account-&gt;uid);&#10;  return $grants;&#10;  $END$&#10;}" description="hook_node_grants" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_access_records" value="/**&#10; * Implements hook_node_access_records().&#10; *&#10; * Set permissions for a node to be written to the database.&#10; *&#10; * When a node is saved, a module implementing hook_node_access_records() will&#10; * be asked if it is interested in the access permissions for a node. If it is&#10; * interested, it must respond with an array of permissions arrays for that&#10; * node.&#10; *&#10; * Node access grants apply regardless of the published or unpublished status&#10; * of the node. Implementations must make sure not to grant access to&#10; * unpublished nodes if they don't want to change the standard access control&#10; * behavior. Your module may need to create a separate access realm to handle&#10; * access to unpublished nodes.&#10; *&#10; * Note that the grant values in the return value from your hook must be&#10; * integers and not boolean TRUE and FALSE.&#10; *&#10; * Each permissions item in the array is an array with the following elements:&#10; * - 'realm': The name of a realm that the module has defined in&#10; *   hook_node_grants().&#10; * - 'gid': A 'grant ID' from hook_node_grants().&#10; * - 'grant_view': If set to 1 a user that has been identified as a member&#10; *   of this gid within this realm can view this node. This should usually be&#10; *   set to $node-&gt;status. Failure to do so may expose unpublished content&#10; *   to some users.&#10; * - 'grant_update': If set to 1 a user that has been identified as a member&#10; *   of this gid within this realm can edit this node.&#10; * - 'grant_delete': If set to 1 a user that has been identified as a member&#10; *   of this gid within this realm can delete this node.&#10; * - 'priority': If multiple modules seek to set permissions on a node, the&#10; *   realms that have the highest priority will win out, and realms with a lower&#10; *   priority will not be written. If there is any doubt, it is best to&#10; *   leave this 0.&#10; *&#10; *&#10; * When an implementation is interested in a node but want to deny access to&#10; * everyone, it may return a &quot;deny all&quot; grant:&#10; *&#10; * @code&#10; * $grants[] = array(&#10; *   'realm' =&gt; 'all',&#10; *   'gid' =&gt; 0,&#10; *   'grant_view' =&gt; 0,&#10; *   'grant_update' =&gt; 0,&#10; *   'grant_delete' =&gt; 0,&#10; *   'priority' =&gt; 1,&#10; * );&#10; * @endcode&#10; *&#10; * Setting the priority should cancel out other grants. In the case of a&#10; * conflict between modules, it is safer to use hook_node_access_records_alter()&#10; * to return only the deny grant.&#10; *&#10; * Note: a deny all grant is not written to the database; denies are implicit.&#10; *&#10; * @see node_access_write_grants()&#10; *&#10; * @param $node&#10; *   The node that has just been saved.&#10; *&#10; * @return&#10; *   An array of grants as defined above.&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_records($node) {&#10;  // We only care about the node if it has been marked private. If not, it is&#10;  // treated just like any other node and we completely ignore it.&#10;  if ($node-&gt;private) {&#10;    $grants = array();&#10;    // Only published nodes should be viewable to all users. If we allow access&#10;    // blindly here, then all users could view an unpublished node.&#10;    if ($node-&gt;status) {&#10;      $grants[] = array(&#10;        'realm' =&gt; 'example',&#10;        'gid' =&gt; 1,&#10;        'grant_view' =&gt; 1,&#10;        'grant_update' =&gt; 0,&#10;        'grant_delete' =&gt; 0,&#10;        'priority' =&gt; 0,&#10;      );&#10;    }&#10;    // For the example_author array, the GID is equivalent to a UID, which&#10;    // means there are many groups of just 1 user.&#10;    // Note that an author can always view his or her nodes, even if they&#10;    // have status unpublished.&#10;    $grants[] = array(&#10;      'realm' =&gt; 'example_author',&#10;      'gid' =&gt; $node-&gt;uid,&#10;      'grant_view' =&gt; 1,&#10;      'grant_update' =&gt; 1,&#10;      'grant_delete' =&gt; 1,&#10;      'priority' =&gt; 0,&#10;    );&#10;&#10;    return $grants;&#10;  }&#10;  $END$&#10;}" description="hook_node_access_records" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_access_records" value="/**&#10; * Implements hook_node_access_records().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_records($node) {&#10;  // We only care about the node if it has been marked private. If not, it is&#10;  // treated just like any other node and we completely ignore it.&#10;  if ($node-&gt;private) {&#10;    $grants = array();&#10;    // Only published nodes should be viewable to all users. If we allow access&#10;    // blindly here, then all users could view an unpublished node.&#10;    if ($node-&gt;status) {&#10;      $grants[] = array(&#10;        'realm' =&gt; 'example',&#10;        'gid' =&gt; 1,&#10;        'grant_view' =&gt; 1,&#10;        'grant_update' =&gt; 0,&#10;        'grant_delete' =&gt; 0,&#10;        'priority' =&gt; 0,&#10;      );&#10;    }&#10;    // For the example_author array, the GID is equivalent to a UID, which&#10;    // means there are many groups of just 1 user.&#10;    // Note that an author can always view his or her nodes, even if they&#10;    // have status unpublished.&#10;    $grants[] = array(&#10;      'realm' =&gt; 'example_author',&#10;      'gid' =&gt; $node-&gt;uid,&#10;      'grant_view' =&gt; 1,&#10;      'grant_update' =&gt; 1,&#10;      'grant_delete' =&gt; 1,&#10;      'priority' =&gt; 0,&#10;    );&#10;&#10;    return $grants;&#10;  }&#10;  $END$&#10;}" description="hook_node_access_records" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_access_records_alter" value="/**&#10; * Implements hook_node_access_records_alter().&#10; *&#10; * Alter permissions for a node before it is written to the database.&#10; *&#10; * Node access modules establish rules for user access to content. Node access&#10; * records are stored in the {node_access} table and define which permissions&#10; * are required to access a node. This hook is invoked after node access modules&#10; * returned their requirements via hook_node_access_records(); doing so allows&#10; * modules to modify the $grants array by reference before it is stored, so&#10; * custom or advanced business logic can be applied.&#10; *&#10; * @see hook_node_access_records()&#10; *&#10; * Upon viewing, editing or deleting a node, hook_node_grants() builds a&#10; * permissions array that is compared against the stored access records. The&#10; * user must have one or more matching permissions in order to complete the&#10; * requested operation.&#10; *&#10; * A module may deny all access to a node by setting $grants to an empty array.&#10; *&#10; * @see hook_node_grants()&#10; * @see hook_node_grants_alter()&#10; *&#10; * @param $grants&#10; *   The $grants array returned by hook_node_access_records().&#10; * @param $node&#10; *   The node for which the grants were acquired.&#10; *&#10; * The preferred use of this hook is in a module that bridges multiple node&#10; * access modules with a configurable behavior, as shown in the example with the&#10; * 'is_preview' field.&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_records_alter(&amp;$grants, $node) {&#10;  // Our module allows editors to mark specific articles with the 'is_preview'&#10;  // field. If the node being saved has a TRUE value for that field, then only&#10;  // our grants are retained, and other grants are removed. Doing so ensures&#10;  // that our rules are enforced no matter what priority other grants are given.&#10;  if ($node-&gt;is_preview) {&#10;    // Our module grants are set in $grants['example'].&#10;    $temp = $grants['example'];&#10;    // Now remove all module grants but our own.&#10;    $grants = array('example' =&gt; $temp);&#10;  }&#10;  $END$&#10;}" description="hook_node_access_records_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_access_records_alter" value="/**&#10; * Implements hook_node_access_records_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_records_alter(&amp;$grants, $node) {&#10;  // Our module allows editors to mark specific articles with the 'is_preview'&#10;  // field. If the node being saved has a TRUE value for that field, then only&#10;  // our grants are retained, and other grants are removed. Doing so ensures&#10;  // that our rules are enforced no matter what priority other grants are given.&#10;  if ($node-&gt;is_preview) {&#10;    // Our module grants are set in $grants['example'].&#10;    $temp = $grants['example'];&#10;    // Now remove all module grants but our own.&#10;    $grants = array('example' =&gt; $temp);&#10;  }&#10;  $END$&#10;}" description="hook_node_access_records_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_grants_alter" value="/**&#10; * Implements hook_node_grants_alter().&#10; *&#10; * Alter user access rules when trying to view, edit or delete a node.&#10; *&#10; * Node access modules establish rules for user access to content.&#10; * hook_node_grants() defines permissions for a user to view, edit or&#10; * delete nodes by building a $grants array that indicates the permissions&#10; * assigned to the user by each node access module. This hook is called to allow&#10; * modules to modify the $grants array by reference, so the interaction of&#10; * multiple node access modules can be altered or advanced business logic can be&#10; * applied.&#10; *&#10; * @see hook_node_grants()&#10; *&#10; * The resulting grants are then checked against the records stored in the&#10; * {node_access} table to determine if the operation may be completed.&#10; *&#10; * A module may deny all access to a user by setting $grants to an empty array.&#10; *&#10; * @see hook_node_access_records()&#10; * @see hook_node_access_records_alter()&#10; *&#10; * @param $grants&#10; *   The $grants array returned by hook_node_grants().&#10; * @param $account&#10; *   The user account requesting access to content.&#10; * @param $op&#10; *   The operation being performed, 'view', 'update' or 'delete'.&#10; *&#10; * Developers may use this hook to either add additional grants to a user&#10; * or to remove existing grants. These rules are typically based on either the&#10; * permissions assigned to a user role, or specific attributes of a user&#10; * account.&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_grants_alter(&amp;$grants, $account, $op) {&#10;  // Our sample module never allows certain roles to edit or delete&#10;  // content. Since some other node access modules might allow this&#10;  // permission, we expressly remove it by returning an empty $grants&#10;  // array for roles specified in our variable setting.&#10;&#10;  // Get our list of banned roles.&#10;  $restricted = variable_get('example_restricted_roles', array());&#10;&#10;  if ($op != 'view' &amp;&amp; !empty($restricted)) {&#10;    // Now check the roles for this account against the restrictions.&#10;    foreach ($restricted as $role_id) {&#10;      if (isset($user-&gt;roles[$role_id])) {&#10;        $grants = array();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_grants_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_grants_alter" value="/**&#10; * Implements hook_node_grants_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_grants_alter(&amp;$grants, $account, $op) {&#10;  // Our sample module never allows certain roles to edit or delete&#10;  // content. Since some other node access modules might allow this&#10;  // permission, we expressly remove it by returning an empty $grants&#10;  // array for roles specified in our variable setting.&#10;&#10;  // Get our list of banned roles.&#10;  $restricted = variable_get('example_restricted_roles', array());&#10;&#10;  if ($op != 'view' &amp;&amp; !empty($restricted)) {&#10;    // Now check the roles for this account against the restrictions.&#10;    foreach ($restricted as $role_id) {&#10;      if (isset($user-&gt;roles[$role_id])) {&#10;        $grants = array();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_grants_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_operations" value="/**&#10; * Implements hook_node_operations().&#10; *&#10; * Add mass node operations.&#10; *&#10; * This hook enables modules to inject custom operations into the mass&#10; * operations dropdown found at admin/content, by associating a callback&#10; * function with the operation, which is called when the form is submitted. The&#10; * callback function receives one initial argument, which is an array of the&#10; * checked nodes.&#10; *&#10; * @return&#10; *   An array of operations. Each operation is an associative array that may&#10; *   contain the following key-value pairs:&#10; *   - 'label': Required. The label for the operation, displayed in the dropdown&#10; *     menu.&#10; *   - 'callback': Required. The function to call for the operation.&#10; *   - 'callback arguments': Optional. An array of additional arguments to pass&#10; *     to the callback function.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_operations() {&#10;  $operations = array(&#10;    'publish' =&gt; array(&#10;      'label' =&gt; t('Publish selected content'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED)),&#10;    ),&#10;    'unpublish' =&gt; array(&#10;      'label' =&gt; t('Unpublish selected content'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_NOT_PUBLISHED)),&#10;    ),&#10;    'promote' =&gt; array(&#10;      'label' =&gt; t('Promote selected content to front page'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED, 'promote' =&gt; NODE_PROMOTED)),&#10;    ),&#10;    'demote' =&gt; array(&#10;      'label' =&gt; t('Demote selected content from front page'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('promote' =&gt; NODE_NOT_PROMOTED)),&#10;    ),&#10;    'sticky' =&gt; array(&#10;      'label' =&gt; t('Make selected content sticky'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED, 'sticky' =&gt; NODE_STICKY)),&#10;    ),&#10;    'unsticky' =&gt; array(&#10;      'label' =&gt; t('Make selected content not sticky'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('sticky' =&gt; NODE_NOT_STICKY)),&#10;    ),&#10;    'delete' =&gt; array(&#10;      'label' =&gt; t('Delete selected content'),&#10;      'callback' =&gt; NULL,&#10;    ),&#10;  );&#10;  return $operations;&#10;  $END$&#10;}" description="hook_node_operations" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_operations" value="/**&#10; * Implements hook_node_operations().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_operations() {&#10;  $operations = array(&#10;    'publish' =&gt; array(&#10;      'label' =&gt; t('Publish selected content'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED)),&#10;    ),&#10;    'unpublish' =&gt; array(&#10;      'label' =&gt; t('Unpublish selected content'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_NOT_PUBLISHED)),&#10;    ),&#10;    'promote' =&gt; array(&#10;      'label' =&gt; t('Promote selected content to front page'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED, 'promote' =&gt; NODE_PROMOTED)),&#10;    ),&#10;    'demote' =&gt; array(&#10;      'label' =&gt; t('Demote selected content from front page'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('promote' =&gt; NODE_NOT_PROMOTED)),&#10;    ),&#10;    'sticky' =&gt; array(&#10;      'label' =&gt; t('Make selected content sticky'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('status' =&gt; NODE_PUBLISHED, 'sticky' =&gt; NODE_STICKY)),&#10;    ),&#10;    'unsticky' =&gt; array(&#10;      'label' =&gt; t('Make selected content not sticky'),&#10;      'callback' =&gt; 'node_mass_update',&#10;      'callback arguments' =&gt; array('updates' =&gt; array('sticky' =&gt; NODE_NOT_STICKY)),&#10;    ),&#10;    'delete' =&gt; array(&#10;      'label' =&gt; t('Delete selected content'),&#10;      'callback' =&gt; NULL,&#10;    ),&#10;  );&#10;  return $operations;&#10;  $END$&#10;}" description="hook_node_operations" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_delete" value="/**&#10; * Implements hook_node_delete().&#10; *&#10; * Respond to node deletion.&#10; *&#10; * This hook is invoked from node_delete_multiple() after the type-specific&#10; * hook_delete() has been invoked, but before hook_entity_delete and&#10; * field_attach_delete() are called, and before the node is removed from the&#10; * node table in the database.&#10; *&#10; * @param $node&#10; *   The node that is being deleted.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_delete" value="/**&#10; * Implements hook_node_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_revision_delete" value="/**&#10; * Implements hook_node_revision_delete().&#10; *&#10; * Respond to deletion of a node revision.&#10; *&#10; * This hook is invoked from node_revision_delete() after the revision has been&#10; * removed from the node_revision table, and before&#10; * field_attach_delete_revision() is called.&#10; *&#10; * @param $node&#10; *   The node revision (node object) that is being deleted.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_revision_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('vid', $node-&gt;vid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_revision_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_revision_delete" value="/**&#10; * Implements hook_node_revision_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_revision_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('vid', $node-&gt;vid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_revision_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_insert" value="/**&#10; * Implements hook_node_insert().&#10; *&#10; * Respond to creation of a new node.&#10; *&#10; * This hook is invoked from node_save() after the node is inserted into the&#10; * node table in the database, after the type-specific hook_insert() is invoked,&#10; * and after field_attach_insert() is called.&#10; *&#10; * @param $node&#10; *   The node that is being created.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_insert($node) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $node-&gt;nid,&#10;      'extra' =&gt; $node-&gt;extra,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_insert" value="/**&#10; * Implements hook_node_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_insert($node) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $node-&gt;nid,&#10;      'extra' =&gt; $node-&gt;extra,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_load" value="/**&#10; * Implements hook_node_load().&#10; *&#10; * Act on nodes being loaded from the database.&#10; *&#10; * This hook is invoked during node loading, which is handled by entity_load(),&#10; * via classes NodeController and DrupalDefaultEntityController. After the node&#10; * information is read from the database or the entity cache, hook_load() is&#10; * invoked on the node's content type module, then field_attach_node_revision()&#10; * or field_attach_load() is called, then hook_entity_load() is invoked on all&#10; * implementing modules, and finally hook_node_load() is invoked on all&#10; * implementing modules.&#10; *&#10; * This hook should only be used to add information that is not in the node or&#10; * node revisions table, not to replace information that is in these tables&#10; * (which could interfere with the entity cache). For performance reasons,&#10; * information for all available nodes should be loaded in a single query where&#10; * possible.&#10; *&#10; * The $types parameter allows for your module to have an early return (for&#10; * efficiency) if your module only supports certain node types. However, if your&#10; * module defines a content type, you can use hook_load() to respond to loading&#10; * of just that content type.&#10; *&#10; * @param $nodes&#10; *   An array of the nodes being loaded, keyed by nid.&#10; * @param $types&#10; *   An array containing the types of the nodes.&#10; *&#10; * For a detailed usage example, see nodeapi_example.module.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_load($nodes, $types) {&#10;  $result = db_query('SELECT nid, foo FROM {mytable} WHERE nid IN(:nids)', array(':nids' =&gt; array_keys($nodes)));&#10;  foreach ($result as $record) {&#10;    $nodes[$record-&gt;nid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_node_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_load" value="/**&#10; * Implements hook_node_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_load($nodes, $types) {&#10;  $result = db_query('SELECT nid, foo FROM {mytable} WHERE nid IN(:nids)', array(':nids' =&gt; array_keys($nodes)));&#10;  foreach ($result as $record) {&#10;    $nodes[$record-&gt;nid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_node_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_access" value="/**&#10; * Implements hook_node_access().&#10; *&#10; * Control access to a node.&#10; *&#10; * Modules may implement this hook if they want to have a say in whether or not&#10; * a given user has access to perform a given operation on a node.&#10; *&#10; * The administrative account (user ID #1) always passes any access check,&#10; * so this hook is not called in that case. Users with the &quot;bypass node access&quot;&#10; * permission may always view and edit content through the administrative&#10; * interface.&#10; *&#10; * Note that not all modules will want to influence access on all&#10; * node types. If your module does not want to actively grant or&#10; * block access, return NODE_ACCESS_IGNORE or simply return nothing.&#10; * Blindly returning FALSE will break other node access modules.&#10; *&#10; * @param $node&#10; *   Either a node object or a (machine-readable) content type on which to&#10; *   perform the access check.&#10; * @param $op&#10; *   The operation to be performed. Possible values:&#10; *   - &quot;create&quot;&#10; *   - &quot;delete&quot;&#10; *   - &quot;update&quot;&#10; *   - &quot;view&quot;&#10; * @param $account&#10; *   The user object to perform the access check operation on.&#10; *&#10; * @return&#10; *   NODE_ACCESS_ALLOW if the operation is to be allowed;&#10; *   NODE_ACCESS_DENY if the operation is to be denied;&#10; *   NODE_ACCESS_IGNORE to not affect this operation at all.&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access($node, $op, $account) {&#10;  $type = is_string($node) ? $node : $node-&gt;type;&#10;&#10;  if (in_array($type, node_permissions_get_configured_types())) {&#10;    if ($op == 'create' &amp;&amp; user_access('create ' . $type . ' content', $account)) {&#10;      return NODE_ACCESS_ALLOW;&#10;    }&#10;&#10;    if ($op == 'update') {&#10;      if (user_access('edit any ' . $type . ' content', $account) || (user_access('edit own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $node-&gt;uid))) {&#10;        return NODE_ACCESS_ALLOW;&#10;      }&#10;    }&#10;&#10;    if ($op == 'delete') {&#10;      if (user_access('delete any ' . $type . ' content', $account) || (user_access('delete own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $node-&gt;uid))) {&#10;        return NODE_ACCESS_ALLOW;&#10;      }&#10;    }&#10;  }&#10;&#10;  // Returning nothing from this function would have the same effect.&#10;  return NODE_ACCESS_IGNORE;&#10;  $END$&#10;}" description="hook_node_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_access" value="/**&#10; * Implements hook_node_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access($node, $op, $account) {&#10;  $type = is_string($node) ? $node : $node-&gt;type;&#10;&#10;  if (in_array($type, node_permissions_get_configured_types())) {&#10;    if ($op == 'create' &amp;&amp; user_access('create ' . $type . ' content', $account)) {&#10;      return NODE_ACCESS_ALLOW;&#10;    }&#10;&#10;    if ($op == 'update') {&#10;      if (user_access('edit any ' . $type . ' content', $account) || (user_access('edit own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $node-&gt;uid))) {&#10;        return NODE_ACCESS_ALLOW;&#10;      }&#10;    }&#10;&#10;    if ($op == 'delete') {&#10;      if (user_access('delete any ' . $type . ' content', $account) || (user_access('delete own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $node-&gt;uid))) {&#10;        return NODE_ACCESS_ALLOW;&#10;      }&#10;    }&#10;  }&#10;&#10;  // Returning nothing from this function would have the same effect.&#10;  return NODE_ACCESS_IGNORE;&#10;  $END$&#10;}" description="hook_node_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_prepare" value="/**&#10; * Implements hook_node_prepare().&#10; *&#10; * Act on a node object about to be shown on the add/edit form.&#10; *&#10; * This hook is invoked from node_object_prepare() after the type-specific&#10; * hook_prepare() is invoked.&#10; *&#10; * @param $node&#10; *   The node that is about to be shown on the add/edit form.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_prepare($node) {&#10;  if (!isset($node-&gt;comment)) {&#10;    $node-&gt;comment = variable_get(&quot;comment_$node-&gt;type&quot;, COMMENT_NODE_OPEN);&#10;  }&#10;  $END$&#10;}" description="hook_node_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_prepare" value="/**&#10; * Implements hook_node_prepare().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_prepare($node) {&#10;  if (!isset($node-&gt;comment)) {&#10;    $node-&gt;comment = variable_get(&quot;comment_$node-&gt;type&quot;, COMMENT_NODE_OPEN);&#10;  }&#10;  $END$&#10;}" description="hook_node_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_search_result" value="/**&#10; * Implements hook_node_search_result().&#10; *&#10; * Act on a node being displayed as a search result.&#10; *&#10; * This hook is invoked from node_search_execute(), after node_load()&#10; * and node_view() have been called.&#10; *&#10; * @param $node&#10; *   The node being displayed in a search result.&#10; *&#10; * @return array&#10; *   Extra information to be displayed with search result. This information&#10; *   should be presented as an associative array. It will be concatenated&#10; *   with the post information (last updated, author) in the default search&#10; *   result theming.&#10; *&#10; * @see template_preprocess_search_result()&#10; * @see search-result.tpl.php&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_search_result($node) {&#10;  $comments = db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = :nid', array('nid' =&gt; $node-&gt;nid))-&gt;fetchField();&#10;  return array('comment' =&gt; format_plural($comments, '1 comment', '@count comments'));&#10;  $END$&#10;}" description="hook_node_search_result" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_search_result" value="/**&#10; * Implements hook_node_search_result().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_search_result($node) {&#10;  $comments = db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = :nid', array('nid' =&gt; $node-&gt;nid))-&gt;fetchField();&#10;  return array('comment' =&gt; format_plural($comments, '1 comment', '@count comments'));&#10;  $END$&#10;}" description="hook_node_search_result" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_presave" value="/**&#10; * Implements hook_node_presave().&#10; *&#10; * Act on a node being inserted or updated.&#10; *&#10; * This hook is invoked from node_save() before the node is saved to the&#10; * database.&#10; *&#10; * @param $node&#10; *   The node that is being inserted or updated.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_presave($node) {&#10;  if ($node-&gt;nid &amp;&amp; $node-&gt;moderate) {&#10;    // Reset votes when node is updated:&#10;    $node-&gt;score = 0;&#10;    $node-&gt;users = '';&#10;    $node-&gt;votes = 0;&#10;  }&#10;  $END$&#10;}" description="hook_node_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_presave" value="/**&#10; * Implements hook_node_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_presave($node) {&#10;  if ($node-&gt;nid &amp;&amp; $node-&gt;moderate) {&#10;    // Reset votes when node is updated:&#10;    $node-&gt;score = 0;&#10;    $node-&gt;users = '';&#10;    $node-&gt;votes = 0;&#10;  }&#10;  $END$&#10;}" description="hook_node_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_update" value="/**&#10; * Implements hook_node_update().&#10; *&#10; * Respond to updates to a node.&#10; *&#10; * This hook is invoked from node_save() after the node is updated in the node&#10; * table in the database, after the type-specific hook_update() is invoked, and&#10; * after field_attach_update() is called.&#10; *&#10; * @param $node&#10; *   The node that is being updated.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_update($node) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('extra' =&gt; $node-&gt;extra))&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_update" value="/**&#10; * Implements hook_node_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_update($node) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('extra' =&gt; $node-&gt;extra))&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_node_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_update_index" value="/**&#10; * Implements hook_node_update_index().&#10; *&#10; * Act on a node being indexed for searching.&#10; *&#10; * This hook is invoked during search indexing, after node_load(), and after&#10; * the result of node_view() is added as $node-&gt;rendered to the node object.&#10; *&#10; * @param $node&#10; *   The node being indexed.&#10; *&#10; * @return&#10; *   Array of additional information to be indexed.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_update_index($node) {&#10;  $text = '';&#10;  $comments = db_query('SELECT subject, comment, format FROM {comment} WHERE nid = :nid AND status = :status', array(':nid' =&gt; $node-&gt;nid, ':status' =&gt; COMMENT_PUBLISHED));&#10;  foreach ($comments as $comment) {&#10;    $text .= '&lt;h2&gt;' . check_plain($comment-&gt;subject) . '&lt;/h2&gt;' . check_markup($comment-&gt;comment, $comment-&gt;format, '', TRUE);&#10;  }&#10;  return $text;&#10;  $END$&#10;}" description="hook_node_update_index" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_update_index" value="/**&#10; * Implements hook_node_update_index().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_update_index($node) {&#10;  $text = '';&#10;  $comments = db_query('SELECT subject, comment, format FROM {comment} WHERE nid = :nid AND status = :status', array(':nid' =&gt; $node-&gt;nid, ':status' =&gt; COMMENT_PUBLISHED));&#10;  foreach ($comments as $comment) {&#10;    $text .= '&lt;h2&gt;' . check_plain($comment-&gt;subject) . '&lt;/h2&gt;' . check_markup($comment-&gt;comment, $comment-&gt;format, '', TRUE);&#10;  }&#10;  return $text;&#10;  $END$&#10;}" description="hook_node_update_index" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_validate" value="/**&#10; * Implements hook_node_validate().&#10; *&#10; * Perform node validation before a node is created or updated.&#10; *&#10; * This hook is invoked from node_validate(), after a user has has finished&#10; * editing the node and is previewing or submitting it. It is invoked at the&#10; * end of all the standard validation steps, and after the type-specific&#10; * hook_validate() is invoked.&#10; *&#10; * To indicate a validation error, use form_set_error().&#10; *&#10; * Note: Changes made to the $node object within your hook implementation will&#10; * have no effect.  The preferred method to change a node's content is to use&#10; * hook_node_presave() instead. If it is really necessary to change&#10; * the node at the validate stage, you can use form_set_value().&#10; *&#10; * @param $node&#10; *   The node being validated.&#10; * @param $form&#10; *   The form being used to edit the node.&#10; * @param $form_state&#10; *   The form state array.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_validate($node, $form, &amp;$form_state) {&#10;  if (isset($node-&gt;end) &amp;&amp; isset($node-&gt;start)) {&#10;    if ($node-&gt;start &gt; $node-&gt;end) {&#10;      form_set_error('time', t('An event may not end before it starts.'));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_validate" value="/**&#10; * Implements hook_node_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_validate($node, $form, &amp;$form_state) {&#10;  if (isset($node-&gt;end) &amp;&amp; isset($node-&gt;start)) {&#10;    if ($node-&gt;start &gt; $node-&gt;end) {&#10;      form_set_error('time', t('An event may not end before it starts.'));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_submit" value="/**&#10; * Implements hook_node_submit().&#10; *&#10; * Act on a node after validated form values have been copied to it.&#10; *&#10; * This hook is invoked when a node form is submitted with either the &quot;Save&quot; or&#10; * &quot;Preview&quot; button, after form values have been copied to the form state's node&#10; * object, but before the node is saved or previewed. It is a chance for modules&#10; * to adjust the node's properties from what they are simply after a copy from&#10; * $form_state['values']. This hook is intended for adjusting non-field-related&#10; * properties. See hook_field_attach_submit() for customizing field-related&#10; * properties.&#10; *&#10; * @param $node&#10; *   The node object being updated in response to a form submission.&#10; * @param $form&#10; *   The form being used to edit the node.&#10; * @param $form_state&#10; *   The form state array.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_submit($node, $form, &amp;$form_state) {&#10;  // Decompose the selected menu parent option into 'menu_name' and 'plid', if&#10;  // the form used the default parent selection widget.&#10;  if (!empty($form_state['values']['menu']['parent'])) {&#10;    list($node-&gt;menu['menu_name'], $node-&gt;menu['plid']) = explode(':', $form_state['values']['menu']['parent']);&#10;  }&#10;  $END$&#10;}" description="hook_node_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_submit" value="/**&#10; * Implements hook_node_submit().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_submit($node, $form, &amp;$form_state) {&#10;  // Decompose the selected menu parent option into 'menu_name' and 'plid', if&#10;  // the form used the default parent selection widget.&#10;  if (!empty($form_state['values']['menu']['parent'])) {&#10;    list($node-&gt;menu['menu_name'], $node-&gt;menu['plid']) = explode(':', $form_state['values']['menu']['parent']);&#10;  }&#10;  $END$&#10;}" description="hook_node_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_view" value="/**&#10; * Implements hook_node_view().&#10; *&#10; * Act on a node that is being assembled before rendering.&#10; *&#10; * The module may add elements to $node-&gt;content prior to rendering. This hook&#10; * will be called after hook_view(). The structure of $node-&gt;content is a&#10; * renderable array as expected by drupal_render().&#10; *&#10; * When $view_mode is 'rss', modules can also add extra RSS elements and&#10; * namespaces to $node-&gt;rss_elements and $node-&gt;rss_namespaces respectively for&#10; * the RSS item generated for this node.&#10; * For details on how this is used, see node_feed().&#10; *&#10; * @see blog_node_view()&#10; * @see forum_node_view()&#10; * @see comment_node_view()&#10; *&#10; * @param $node&#10; *   The node that is being assembled for rendering.&#10; * @param $view_mode&#10; *   The $view_mode parameter from node_view().&#10; * @param $langcode&#10; *   The language code used for rendering.&#10; *&#10; * @see hook_entity_view()&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_view($node, $view_mode, $langcode) {&#10;  $node-&gt;content['my_additional_field'] = array(&#10;    '#markup' =&gt; $additional_field,&#10;    '#weight' =&gt; 10,&#10;    '#theme' =&gt; 'mymodule_my_additional_field',&#10;  );&#10;  $END$&#10;}" description="hook_node_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_view" value="/**&#10; * Implements hook_node_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_view($node, $view_mode, $langcode) {&#10;  $node-&gt;content['my_additional_field'] = array(&#10;    '#markup' =&gt; $additional_field,&#10;    '#weight' =&gt; 10,&#10;    '#theme' =&gt; 'mymodule_my_additional_field',&#10;  );&#10;  $END$&#10;}" description="hook_node_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_view_alter" value="/**&#10; * Implements hook_node_view_alter().&#10; *&#10; * Alter the results of node_view().&#10; *&#10; * This hook is called after the content has been assembled in a structured&#10; * array and may be used for doing processing which requires that the complete&#10; * node content structure has been built.&#10; *&#10; * If the module wishes to act on the rendered HTML of the node rather than the&#10; * structured content array, it may use this hook to add a #post_render&#10; * callback.  Alternatively, it could also implement hook_preprocess_node(). See&#10; * drupal_render() and theme() documentation respectively for details.&#10; *&#10; * @param $build&#10; *   A renderable array representing the node content.&#10; *&#10; * @see node_view()&#10; * @see hook_entity_view_alter()&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_view_alter(&amp;$build) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the node.&#10;  $build['#post_render'][] = 'my_module_node_post_render';&#10;  $END$&#10;}" description="hook_node_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_view_alter" value="/**&#10; * Implements hook_node_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_view_alter(&amp;$build) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the node.&#10;  $build['#post_render'][] = 'my_module_node_post_render';&#10;  $END$&#10;}" description="hook_node_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_info" value="/**&#10; * Implements hook_node_info().&#10; *&#10; * Define module-provided node types.&#10; *&#10; * This hook allows a module to define one or more of its own node types. For&#10; * example, the blog module uses it to define a blog node-type named &quot;Blog&#10; * entry.&quot; The name and attributes of each desired node type are specified in&#10; * an array returned by the hook.&#10; *&#10; * Only module-provided node types should be defined through this hook. User-&#10; * provided (or 'custom') node types should be defined only in the 'node_type'&#10; * database table, and should be maintained by using the node_type_save() and&#10; * node_type_delete() functions.&#10; *&#10; * @return&#10; *   An array of information defining the module's node types. The array&#10; *   contains a sub-array for each node type, with the machine-readable type&#10; *   name as the key. Each sub-array has up to 10 attributes. Possible&#10; *   attributes:&#10; *   - &quot;name&quot;: the human-readable name of the node type. Required.&#10; *   - &quot;base&quot;: the base string used to construct callbacks corresponding to&#10; *      this node type.&#10; *      (i.e. if base is defined as example_foo, then example_foo_insert will&#10; *      be called when inserting a node of that type). This string is usually&#10; *      the name of the module, but not always. Required.&#10; *   - &quot;description&quot;: a brief description of the node type. Required.&#10; *   - &quot;help&quot;: help information shown to the user when creating a node of&#10; *      this type.. Optional (defaults to '').&#10; *   - &quot;has_title&quot;: boolean indicating whether or not this node type has a title&#10; *      field. Optional (defaults to TRUE).&#10; *   - &quot;title_label&quot;: the label for the title field of this content type.&#10; *      Optional (defaults to 'Title').&#10; *   - &quot;locked&quot;: boolean indicating whether the administrator can change the&#10; *      machine name of this type. FALSE = changeable (not locked),&#10; *      TRUE = unchangeable (locked). Optional (defaults to TRUE).&#10; *&#10; * The machine name of a node type should contain only letters, numbers, and&#10; * underscores. Underscores will be converted into hyphens for the purpose of&#10; * constructing URLs.&#10; *&#10; * All attributes of a node type that are defined through this hook (except for&#10; * 'locked') can be edited by a site administrator. This includes the&#10; * machine-readable name of a node type, if 'locked' is set to FALSE.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_info() {&#10;  return array(&#10;    'blog' =&gt; array(&#10;      'name' =&gt; t('Blog entry'),&#10;      'base' =&gt; 'blog',&#10;      'description' =&gt; t('Use for multi-user blogs. Every user gets a personal blog.'),&#10;    )&#10;  );&#10;  $END$&#10;}" description="hook_node_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_info" value="/**&#10; * Implements hook_node_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_info() {&#10;  return array(&#10;    'blog' =&gt; array(&#10;      'name' =&gt; t('Blog entry'),&#10;      'base' =&gt; 'blog',&#10;      'description' =&gt; t('Use for multi-user blogs. Every user gets a personal blog.'),&#10;    )&#10;  );&#10;  $END$&#10;}" description="hook_node_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ranking" value="/**&#10; * Implements hook_ranking().&#10; *&#10; * Provide additional methods of scoring for core search results for nodes.&#10; *&#10; * A node's search score is used to rank it among other nodes matched by the&#10; * search, with the highest-ranked nodes appearing first in the search listing.&#10; *&#10; * For example, a module allowing users to vote on content could expose an&#10; * option to allow search results' rankings to be influenced by the average&#10; * voting score of a node.&#10; *&#10; * All scoring mechanisms are provided as options to site administrators, and&#10; * may be tweaked based on individual sites or disabled altogether if they do&#10; * not make sense. Individual scoring mechanisms, if enabled, are assigned a&#10; * weight from 1 to 10. The weight represents the factor of magnification of&#10; * the ranking mechanism, with higher-weighted ranking mechanisms having more&#10; * influence. In order for the weight system to work, each scoring mechanism&#10; * must return a value between 0 and 1 for every node. That value is then&#10; * multiplied by the administrator-assigned weight for the ranking mechanism,&#10; * and then the weighted scores from all ranking mechanisms are added, which&#10; * brings about the same result as a weighted average.&#10; *&#10; * @return&#10; *   An associative array of ranking data. The keys should be strings,&#10; *   corresponding to the internal name of the ranking mechanism, such as&#10; *   'recent', or 'comments'. The values should be arrays themselves, with the&#10; *   following keys available:&#10; *   - &quot;title&quot;: the human readable name of the ranking mechanism. Required.&#10; *   - &quot;join&quot;: part of a query string to join to any additional necessary&#10; *     table. This is not necessary if the table required is already joined to&#10; *     by the base query, such as for the {node} table. Other tables should use&#10; *     the full table name as an alias to avoid naming collisions. Optional.&#10; *   - &quot;score&quot;: part of a query string to calculate the score for the ranking&#10; *     mechanism based on values in the database. This does not need to be&#10; *     wrapped in parentheses, as it will be done automatically; it also does&#10; *     not need to take the weighted system into account, as it will be done&#10; *     automatically. It does, however, need to calculate a decimal between&#10; *     0 and 1; be careful not to cast the entire score to an integer by&#10; *     inadvertently introducing a variable argument. Required.&#10; *   - &quot;arguments&quot;: if any arguments are required for the score, they can be&#10; *     specified in an array here.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ranking() {&#10;  // If voting is disabled, we can avoid returning the array, no hard feelings.&#10;  if (variable_get('vote_node_enabled', TRUE)) {&#10;    return array(&#10;      'vote_average' =&gt; array(&#10;        'title' =&gt; t('Average vote'),&#10;        // Note that we use i.sid, the search index's search item id, rather than&#10;        // n.nid.&#10;        'join' =&gt; 'LEFT JOIN {vote_node_data} vote_node_data ON vote_node_data.nid = i.sid',&#10;        // The highest possible score should be 1, and the lowest possible score,&#10;        // always 0, should be 0.&#10;        'score' =&gt; 'vote_node_data.average / CAST(%f AS DECIMAL)',&#10;        // Pass in the highest possible voting score as a decimal argument.&#10;        'arguments' =&gt; array(variable_get('vote_score_max', 5)),&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_ranking" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ranking" value="/**&#10; * Implements hook_ranking().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ranking() {&#10;  // If voting is disabled, we can avoid returning the array, no hard feelings.&#10;  if (variable_get('vote_node_enabled', TRUE)) {&#10;    return array(&#10;      'vote_average' =&gt; array(&#10;        'title' =&gt; t('Average vote'),&#10;        // Note that we use i.sid, the search index's search item id, rather than&#10;        // n.nid.&#10;        'join' =&gt; 'LEFT JOIN {vote_node_data} vote_node_data ON vote_node_data.nid = i.sid',&#10;        // The highest possible score should be 1, and the lowest possible score,&#10;        // always 0, should be 0.&#10;        'score' =&gt; 'vote_node_data.average / CAST(%f AS DECIMAL)',&#10;        // Pass in the highest possible voting score as a decimal argument.&#10;        'arguments' =&gt; array(variable_get('vote_score_max', 5)),&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_ranking" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_type_insert" value="/**&#10; * Implements hook_node_type_insert().&#10; *&#10; * Respond to node type creation.&#10; *&#10; * This hook is invoked from node_type_save() after the node type is added&#10; * to the database.&#10; *&#10; * @param $info&#10; *   The node type object that is being created.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_insert($info) {&#10;  $END$&#10;}" description="hook_node_type_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_type_insert" value="/**&#10; * Implements hook_node_type_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_insert($info) {&#10;  $END$&#10;}" description="hook_node_type_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_type_update" value="/**&#10; * Implements hook_node_type_update().&#10; *&#10; * Respond to node type updates.&#10; *&#10; * This hook is invoked from node_type_save() after the node type is updated&#10; * in the database.&#10; *&#10; * @param $info&#10; *   The node type object that is being updated.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_update($info) {&#10;  if (!empty($info-&gt;old_type) &amp;&amp; $info-&gt;old_type != $info-&gt;type) {&#10;    $setting = variable_get('comment_' . $info-&gt;old_type, COMMENT_NODE_OPEN);&#10;    variable_del('comment_' . $info-&gt;old_type);&#10;    variable_set('comment_' . $info-&gt;type, $setting);&#10;  }&#10;  $END$&#10;}" description="hook_node_type_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_type_update" value="/**&#10; * Implements hook_node_type_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_update($info) {&#10;  if (!empty($info-&gt;old_type) &amp;&amp; $info-&gt;old_type != $info-&gt;type) {&#10;    $setting = variable_get('comment_' . $info-&gt;old_type, COMMENT_NODE_OPEN);&#10;    variable_del('comment_' . $info-&gt;old_type);&#10;    variable_set('comment_' . $info-&gt;type, $setting);&#10;  }&#10;  $END$&#10;}" description="hook_node_type_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_type_delete" value="/**&#10; * Implements hook_node_type_delete().&#10; *&#10; * Respond to node type deletion.&#10; *&#10; * This hook is invoked from node_type_delete() after the node type is removed&#10; * from the database.&#10; *&#10; * @param $info&#10; *   The node type object that is being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_delete($info) {&#10;  variable_del('comment_' . $info-&gt;type);&#10;  $END$&#10;}" description="hook_node_type_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_type_delete" value="/**&#10; * Implements hook_node_type_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_type_delete($info) {&#10;  variable_del('comment_' . $info-&gt;type);&#10;  $END$&#10;}" description="hook_node_type_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_delete" value="/**&#10; * Implements hook_delete().&#10; *&#10; * Respond to node deletion.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_delete() to respond to all node deletions).&#10; *&#10; * This hook is invoked from node_delete_multiple() after the node has been&#10; * removed from the node table in the database, before hook_node_delete() is&#10; * invoked, and before field_attach_delete() is called.&#10; *&#10; * @param $node&#10; *   The node that is being deleted.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_delete" value="/**&#10; * Implements hook_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_delete($node) {&#10;  db_delete('mytable')&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_prepare" value="/**&#10; * Implements hook_prepare().&#10; *&#10; * Act on a node object about to be shown on the add/edit form.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_prepare() to act on all node preparations).&#10; *&#10; * This hook is invoked from node_object_prepare() before the general&#10; * hook_node_prepare() is invoked.&#10; *&#10; * @param $node&#10; *   The node that is about to be shown on the add/edit form.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_prepare($node) {&#10;  if ($file = file_check_upload($field_name)) {&#10;    $file = file_save_upload($field_name, _image_filename($file-&gt;filename, NULL, TRUE));&#10;    if ($file) {&#10;      if (!image_get_info($file-&gt;uri)) {&#10;        form_set_error($field_name, t('Uploaded file is not a valid image'));&#10;        return;&#10;      }&#10;    }&#10;    else {&#10;      return;&#10;    }&#10;    $node-&gt;images['_original'] = $file-&gt;uri;&#10;    _image_build_derivatives($node, TRUE);&#10;    $node-&gt;new_file = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_prepare" value="/**&#10; * Implements hook_prepare().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_prepare($node) {&#10;  if ($file = file_check_upload($field_name)) {&#10;    $file = file_save_upload($field_name, _image_filename($file-&gt;filename, NULL, TRUE));&#10;    if ($file) {&#10;      if (!image_get_info($file-&gt;uri)) {&#10;        form_set_error($field_name, t('Uploaded file is not a valid image'));&#10;        return;&#10;      }&#10;    }&#10;    else {&#10;      return;&#10;    }&#10;    $node-&gt;images['_original'] = $file-&gt;uri;&#10;    _image_build_derivatives($node, TRUE);&#10;    $node-&gt;new_file = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_form" value="/**&#10; * Implements hook_form().&#10; *&#10; * Display a node editing form.&#10; *&#10; * This hook, implemented by node modules, is called to retrieve the form&#10; * that is displayed to create or edit a node. This form is displayed at path&#10; * node/add/[node type] or node/[node ID]/edit.&#10; *&#10; * The submit and preview buttons, administrative and display controls, and&#10; * sections added by other modules (such as path settings, menu settings,&#10; * comment settings, and fields managed by the Field UI module) are&#10; * displayed automatically by the node module. This hook just needs to&#10; * return the node title and form editing fields specific to the node type.&#10; *&#10; * @param $node&#10; *   The node being added or edited.&#10; * @param $form_state&#10; *   The form state array.&#10; *&#10; * @return&#10; *   An array containing the title and any custom form elements to be displayed&#10; *   in the node editing form.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form($node, &amp;$form_state) {&#10;  $type = node_type_get_type($node);&#10;&#10;  $form['title'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; check_plain($type-&gt;title_label),&#10;    '#default_value' =&gt; !empty($node-&gt;title) ? $node-&gt;title : '',&#10;    '#required' =&gt; TRUE, '#weight' =&gt; -5&#10;  );&#10;&#10;  $form['field1'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; t('Custom field'),&#10;    '#default_value' =&gt; $node-&gt;field1,&#10;    '#maxlength' =&gt; 127,&#10;  );&#10;  $form['selectbox'] = array(&#10;    '#type' =&gt; 'select',&#10;    '#title' =&gt; t('Select box'),&#10;    '#default_value' =&gt; $node-&gt;selectbox,&#10;    '#options' =&gt; array(&#10;      1 =&gt; 'Option A',&#10;      2 =&gt; 'Option B',&#10;      3 =&gt; 'Option C',&#10;    ),&#10;    '#description' =&gt; t('Choose an option.'),&#10;  );&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_form" value="/**&#10; * Implements hook_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form($node, &amp;$form_state) {&#10;  $type = node_type_get_type($node);&#10;&#10;  $form['title'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; check_plain($type-&gt;title_label),&#10;    '#default_value' =&gt; !empty($node-&gt;title) ? $node-&gt;title : '',&#10;    '#required' =&gt; TRUE, '#weight' =&gt; -5&#10;  );&#10;&#10;  $form['field1'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; t('Custom field'),&#10;    '#default_value' =&gt; $node-&gt;field1,&#10;    '#maxlength' =&gt; 127,&#10;  );&#10;  $form['selectbox'] = array(&#10;    '#type' =&gt; 'select',&#10;    '#title' =&gt; t('Select box'),&#10;    '#default_value' =&gt; $node-&gt;selectbox,&#10;    '#options' =&gt; array(&#10;      1 =&gt; 'Option A',&#10;      2 =&gt; 'Option B',&#10;      3 =&gt; 'Option C',&#10;    ),&#10;    '#description' =&gt; t('Choose an option.'),&#10;  );&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_insert" value="/**&#10; * Implements hook_insert().&#10; *&#10; * Respond to creation of a new node.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_insert() to act on all node insertions).&#10; *&#10; * This hook is invoked from node_save() after the node is inserted into the&#10; * node table in the database, before field_attach_insert() is called, and&#10; * before hook_node_insert() is invoked.&#10; *&#10; * @param $node&#10; *   The node that is being created.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_insert($node) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $node-&gt;nid,&#10;      'extra' =&gt; $node-&gt;extra,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_insert" value="/**&#10; * Implements hook_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_insert($node) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $node-&gt;nid,&#10;      'extra' =&gt; $node-&gt;extra,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_load" value="/**&#10; * Implements hook_load().&#10; *&#10; * Act on nodes being loaded from the database.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_load() to respond to all node loads).&#10; *&#10; * This hook is invoked during node loading, which is handled by entity_load(),&#10; * via classes NodeController and DrupalDefaultEntityController. After the node&#10; * information is read from the database or the entity cache, hook_load() is&#10; * invoked on the node's content type module, then field_attach_node_revision()&#10; * or field_attach_load() is called, then hook_entity_load() is invoked on all&#10; * implementing modules, and finally hook_node_load() is invoked on all&#10; * implementing modules.&#10; *&#10; * This hook should only be used to add information that is not in the node or&#10; * node revisions table, not to replace information that is in these tables&#10; * (which could interfere with the entity cache). For performance reasons,&#10; * information for all available nodes should be loaded in a single query where&#10; * possible.&#10; *&#10; * @param $nodes&#10; *   An array of the nodes being loaded, keyed by nid.&#10; *&#10; * For a detailed usage example, see node_example.module.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_load($nodes) {&#10;  $result = db_query('SELECT nid, foo FROM {mytable} WHERE nid IN (:nids)', array(':nids' =&gt; array_keys($nodes)));&#10;  foreach ($result as $record) {&#10;    $nodes[$record-&gt;nid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_load" value="/**&#10; * Implements hook_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_load($nodes) {&#10;  $result = db_query('SELECT nid, foo FROM {mytable} WHERE nid IN (:nids)', array(':nids' =&gt; array_keys($nodes)));&#10;  foreach ($result as $record) {&#10;    $nodes[$record-&gt;nid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update" value="/**&#10; * Implements hook_update().&#10; *&#10; * Respond to updates to a node.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_update() to act on all node updates).&#10; *&#10; * This hook is invoked from node_save() after the node is updated in the&#10; * node table in the database, before field_attach_update() is called, and&#10; * before hook_node_update() is invoked.&#10; *&#10; * @param $node&#10; *   The node that is being updated.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update($node) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('extra' =&gt; $node-&gt;extra))&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update" value="/**&#10; * Implements hook_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update($node) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('extra' =&gt; $node-&gt;extra))&#10;    -&gt;condition('nid', $node-&gt;nid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_validate" value="/**&#10; * Implements hook_validate().&#10; *&#10; * Perform node validation before a node is created or updated.&#10; *&#10; * This hook is invoked only on the module that defines the node's content type&#10; * (use hook_node_validate() to act on all node validations).&#10; *&#10; * This hook is invoked from node_validate(), after a user has finished&#10; * editing the node and is previewing or submitting it. It is invoked at the end&#10; * of all the standard validation steps, and before hook_node_validate() is&#10; * invoked.&#10; *&#10; * To indicate a validation error, use form_set_error().&#10; *&#10; * Note: Changes made to the $node object within your hook implementation will&#10; * have no effect.  The preferred method to change a node's content is to use&#10; * hook_node_presave() instead.&#10; *&#10; * @param $node&#10; *   The node being validated.&#10; * @param $form&#10; *   The form being used to edit the node.&#10; * @param $form_state&#10; *   The form state array.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_validate($node, $form, &amp;$form_state) {&#10;  if (isset($node-&gt;end) &amp;&amp; isset($node-&gt;start)) {&#10;    if ($node-&gt;start &gt; $node-&gt;end) {&#10;      form_set_error('time', t('An event may not end before it starts.'));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_validate" value="/**&#10; * Implements hook_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_validate($node, $form, &amp;$form_state) {&#10;  if (isset($node-&gt;end) &amp;&amp; isset($node-&gt;start)) {&#10;    if ($node-&gt;start &gt; $node-&gt;end) {&#10;      form_set_error('time', t('An event may not end before it starts.'));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_view" value="/**&#10; * Implements hook_view().&#10; *&#10; * Display a node.&#10; *&#10; * This is a hook used by node modules. It allows a module to define a&#10; * custom method of displaying its nodes, usually by displaying extra&#10; * information particular to that node type.&#10; *&#10; * @param $node&#10; *   The node to be displayed, as returned by node_load().&#10; * @param $view_mode&#10; *   View mode, e.g. 'full', 'teaser', ...&#10; * @return&#10; *   $node. The passed $node parameter should be modified as necessary and&#10; *   returned so it can be properly presented. Nodes are prepared for display&#10; *   by assembling a structured array, formatted as in the Form API, in&#10; *   $node-&gt;content. As with Form API arrays, the #weight property can be&#10; *   used to control the relative positions of added elements. After this&#10; *   hook is invoked, node_view() calls field_attach_view() to add field&#10; *   views to $node-&gt;content, and then invokes hook_node_view() and&#10; *   hook_node_view_alter(), so if you want to affect the final&#10; *   view of the node, you might consider implementing one of these hooks&#10; *   instead.&#10; *&#10; * For a detailed usage example, see node_example.module.&#10; *&#10; * @ingroup node_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_view($node, $view_mode) {&#10;  if ($view_mode == 'full' &amp;&amp; node_is_page($node)) {&#10;    $breadcrumb = array();&#10;    $breadcrumb[] = l(t('Home'), NULL);&#10;    $breadcrumb[] = l(t('Example'), 'example');&#10;    $breadcrumb[] = l($node-&gt;field1, 'example/' . $node-&gt;field1);&#10;    drupal_set_breadcrumb($breadcrumb);&#10;  }&#10;&#10;  $node-&gt;content['myfield'] = array(&#10;    '#markup' =&gt; theme('mymodule_myfield', $node-&gt;myfield),&#10;    '#weight' =&gt; 1,&#10;  );&#10;&#10;  return $node;&#10;  $END$&#10;}" description="hook_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_view" value="/**&#10; * Implements hook_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_view($node, $view_mode) {&#10;  if ($view_mode == 'full' &amp;&amp; node_is_page($node)) {&#10;    $breadcrumb = array();&#10;    $breadcrumb[] = l(t('Home'), NULL);&#10;    $breadcrumb[] = l(t('Example'), 'example');&#10;    $breadcrumb[] = l($node-&gt;field1, 'example/' . $node-&gt;field1);&#10;    drupal_set_breadcrumb($breadcrumb);&#10;  }&#10;&#10;  $node-&gt;content['myfield'] = array(&#10;    '#markup' =&gt; theme('mymodule_myfield', $node-&gt;myfield),&#10;    '#weight' =&gt; 1,&#10;  );&#10;&#10;  return $node;&#10;  $END$&#10;}" description="hook_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_options_list" value="/**&#10; * Implements hook_options_list().&#10; *&#10; * Returns the list of options to be displayed for a field.&#10; *&#10; * Field types willing to enable one or several of the widgets defined in&#10; * options.module (select, radios/checkboxes, on/off checkbox) need to&#10; * implement this hook to specify the list of options to display in the&#10; * widgets.&#10; *&#10; * @param $field&#10; *   The field definition.&#10; * @param $instance&#10; *   (optional) The instance definition. The hook might be called without an&#10; *   $instance parameter in contexts where no specific instance can be targeted.&#10; *   It is recommended to only use instance level properties to filter out&#10; *   values from a list defined by field level properties.&#10; *&#10; * @return&#10; *   The array of options for the field. Array keys are the values to be&#10; *   stored, and should be of the data type (string, number...) expected by&#10; *   the first 'column' for the field type. Array values are the labels to&#10; *   display within the widgets. The labels should NOT be sanitized,&#10; *   options.module takes care of sanitation according to the needs of each&#10; *   widget. The HTML tags defined in _field_filter_xss_allowed_tags() are&#10; *   allowed, other tags will be filtered.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_options_list($field, $instance = NULL) {&#10;  // Sample structure.&#10;  $options = array(&#10;    0 =&gt; t('Zero'),&#10;    1 =&gt; t('One'),&#10;    2 =&gt; t('Two'),&#10;    3 =&gt; t('Three'),&#10;  );&#10;&#10;  // Sample structure with groups. Only one level of nesting is allowed. This&#10;  // is only supported by the 'options_select' widget. Other widgets will&#10;  // flatten the array.&#10;  $options = array(&#10;    t('First group') =&gt; array(&#10;      0 =&gt; t('Zero'),&#10;    ),&#10;    t('Second group') =&gt; array(&#10;      1 =&gt; t('One'),&#10;      2 =&gt; t('Two'),&#10;    ),&#10;    3 =&gt; t('Three'),&#10;  );&#10;&#10;  // In actual implementations, the array of options will most probably depend&#10;  // on properties of the field. Example from taxonomy.module:&#10;  $options = array();&#10;  foreach ($field['settings']['allowed_values'] as $tree) {&#10;    $terms = taxonomy_get_tree($tree['vid'], $tree['parent']);&#10;    if ($terms) {&#10;      foreach ($terms as $term) {&#10;        $options[$term-&gt;tid] = str_repeat('-', $term-&gt;depth) . $term-&gt;name;&#10;      }&#10;    }&#10;  }&#10;&#10;  return $options;&#10;  $END$&#10;}" description="hook_options_list" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_options_list" value="/**&#10; * Implements hook_options_list().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_options_list($field, $instance = NULL) {&#10;  // Sample structure.&#10;  $options = array(&#10;    0 =&gt; t('Zero'),&#10;    1 =&gt; t('One'),&#10;    2 =&gt; t('Two'),&#10;    3 =&gt; t('Three'),&#10;  );&#10;&#10;  // Sample structure with groups. Only one level of nesting is allowed. This&#10;  // is only supported by the 'options_select' widget. Other widgets will&#10;  // flatten the array.&#10;  $options = array(&#10;    t('First group') =&gt; array(&#10;      0 =&gt; t('Zero'),&#10;    ),&#10;    t('Second group') =&gt; array(&#10;      1 =&gt; t('One'),&#10;      2 =&gt; t('Two'),&#10;    ),&#10;    3 =&gt; t('Three'),&#10;  );&#10;&#10;  // In actual implementations, the array of options will most probably depend&#10;  // on properties of the field. Example from taxonomy.module:&#10;  $options = array();&#10;  foreach ($field['settings']['allowed_values'] as $tree) {&#10;    $terms = taxonomy_get_tree($tree['vid'], $tree['parent']);&#10;    if ($terms) {&#10;      foreach ($terms as $term) {&#10;        $options[$term-&gt;tid] = str_repeat('-', $term-&gt;depth) . $term-&gt;name;&#10;      }&#10;    }&#10;  }&#10;&#10;  return $options;&#10;  $END$&#10;}" description="hook_options_list" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_extra_fields" value="/**&#10; * Implements hook_field_extra_fields().&#10; *&#10; * Exposes &quot;pseudo-field&quot; components on fieldable entities.&#10; *&#10; * Field UI's &quot;Manage fields&quot; and &quot;Manage display&quot; pages let users re-order&#10; * fields, but also non-field components. For nodes, these include the title,&#10; * poll choices, and other elements exposed by modules through hook_form() or&#10; * hook_form_alter().&#10; *&#10; * Fieldable entities or modules that want to have their components supported&#10; * should expose them using this hook. The user-defined settings (weight,&#10; * visible) are automatically applied on rendered forms and displayed&#10; * entities in a #pre_render callback added by field_attach_form() and&#10; * field_attach_view().&#10; *&#10; * @see _field_extra_fields_pre_render()&#10; * @see hook_field_extra_fields_alter()&#10; *&#10; * @return&#10; *   A nested array of 'pseudo-field' components. Each list is nested within&#10; *   the following keys: entity type, bundle name, context (either 'form' or&#10; *   'display'). The keys are the name of the elements as appearing in the&#10; *   renderable array (either the entity form or the displayed entity). The&#10; *   value is an associative array:&#10; *   - label: The human readable name of the component.&#10; *   - description: A short description of the component contents.&#10; *   - weight: The default weight of the element.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields() {&#10;  $extra['node']['poll'] = array(&#10;    'form' =&gt; array(&#10;      'choice_wrapper' =&gt; array(&#10;        'label' =&gt; t('Poll choices'),&#10;        'description' =&gt; t('Poll choices'),&#10;        'weight' =&gt; -4,&#10;      ),&#10;      'settings' =&gt; array(&#10;        'label' =&gt; t('Poll settings'),&#10;        'description' =&gt; t('Poll module settings'),&#10;        'weight' =&gt; -3,&#10;      ),&#10;    ),&#10;    'display' =&gt; array(&#10;      'poll_view_voting' =&gt; array(&#10;        'label' =&gt; t('Poll vote'),&#10;        'description' =&gt; t('Poll vote'),&#10;        'weight' =&gt; 0,&#10;      ),&#10;      'poll_view_results' =&gt; array(&#10;        'label' =&gt; t('Poll results'),&#10;        'description' =&gt; t('Poll results'),&#10;        'weight' =&gt; 0,&#10;      ),&#10;    )&#10;  );&#10;&#10;  return $extra;&#10;  $END$&#10;}" description="hook_field_extra_fields" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_extra_fields" value="/**&#10; * Implements hook_field_extra_fields().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields() {&#10;  $extra['node']['poll'] = array(&#10;    'form' =&gt; array(&#10;      'choice_wrapper' =&gt; array(&#10;        'label' =&gt; t('Poll choices'),&#10;        'description' =&gt; t('Poll choices'),&#10;        'weight' =&gt; -4,&#10;      ),&#10;      'settings' =&gt; array(&#10;        'label' =&gt; t('Poll settings'),&#10;        'description' =&gt; t('Poll module settings'),&#10;        'weight' =&gt; -3,&#10;      ),&#10;    ),&#10;    'display' =&gt; array(&#10;      'poll_view_voting' =&gt; array(&#10;        'label' =&gt; t('Poll vote'),&#10;        'description' =&gt; t('Poll vote'),&#10;        'weight' =&gt; 0,&#10;      ),&#10;      'poll_view_results' =&gt; array(&#10;        'label' =&gt; t('Poll results'),&#10;        'description' =&gt; t('Poll results'),&#10;        'weight' =&gt; 0,&#10;      ),&#10;    )&#10;  );&#10;&#10;  return $extra;&#10;  $END$&#10;}" description="hook_field_extra_fields" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_extra_fields_alter" value="/**&#10; * Implements hook_field_extra_fields_alter().&#10; *&#10; * Alter &quot;pseudo-field&quot; components on fieldable entities.&#10; *&#10; * @param $info&#10; *   The associative array of 'pseudo-field' components.&#10; *&#10; * @see hook_field_extra_fields()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields_alter(&amp;$info) {&#10;  // Force node title to always be at the top of the list by default.&#10;  foreach (node_type_get_types() as $bundle) {&#10;    if (isset($info['node'][$bundle-&gt;type]['title'])) {&#10;      $info['node'][$bundle-&gt;type]['title']['weight'] = -20;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_extra_fields_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_extra_fields_alter" value="/**&#10; * Implements hook_field_extra_fields_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields_alter(&amp;$info) {&#10;  // Force node title to always be at the top of the list by default.&#10;  foreach (node_type_get_types() as $bundle) {&#10;    if (isset($info['node'][$bundle-&gt;type]['title'])) {&#10;      $info['node'][$bundle-&gt;type]['title']['weight'] = -20;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_extra_fields_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_info" value="/**&#10; * Implements hook_field_info().&#10; *&#10; * Define Field API field types.&#10; *&#10; * @return&#10; *   An array whose keys are field type names and whose values are arrays&#10; *   describing the field type, with the following key/value pairs:&#10; *   - label: The human-readable name of the field type.&#10; *   - description: A short description for the field type.&#10; *   - settings: An array whose keys are the names of the settings available&#10; *     for the field type, and whose values are the default values for those&#10; *     settings.&#10; *   - instance_settings: An array whose keys are the names of the settings&#10; *     available for instances of the field type, and whose values are the&#10; *     default values for those settings. Instance-level settings can have&#10; *     different values on each field instance, and thus allow greater&#10; *     flexibility than field-level settings. It is recommended to put settings&#10; *     at the instance level whenever possible. Notable exceptions: settings&#10; *     acting on the schema definition, or settings that Views needs to use&#10; *     across field instances (for example, the list of allowed values).&#10; *   - default_widget: The machine name of the default widget to be used by&#10; *     instances of this field type, when no widget is specified in the&#10; *     instance definition. This widget must be available whenever the field&#10; *     type is available (i.e. provided by the field type module, or by a module&#10; *     the field type module depends on).&#10; *   - default_formatter: The machine name of the default formatter to be used&#10; *     by instances of this field type, when no formatter is specified in the&#10; *     instance definition. This formatter must be available whenever the field&#10; *     type is available (i.e. provided by the field type module, or by a module&#10; *     the field type module depends on).&#10; *   - no_ui: (optional) A boolean specifying that users should not be allowed&#10; *     to create fields and instances of this field type through the UI. Such&#10; *     fields can only be created programmatically with field_create_field()&#10; *     and field_create_instance(). Defaults to FALSE.&#10; *&#10; * @see hook_field_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info() {&#10;  return array(&#10;    'text' =&gt; array(&#10;      'label' =&gt; t('Text'),&#10;      'description' =&gt; t('This field stores varchar text in the database.'),&#10;      'settings' =&gt; array('max_length' =&gt; 255),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textfield',&#10;      'default_formatter' =&gt; 'text_default',&#10;    ),&#10;    'text_long' =&gt; array(&#10;      'label' =&gt; t('Long text'),&#10;      'description' =&gt; t('This field stores long text in the database.'),&#10;      'settings' =&gt; array('max_length' =&gt; ''),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textarea',&#10;      'default_formatter' =&gt; 'text_default',&#10;    ),&#10;    'text_with_summary' =&gt; array(&#10;      'label' =&gt; t('Long text and summary'),&#10;      'description' =&gt; t('This field stores long text in the database along with optional summary text.'),&#10;      'settings' =&gt; array('max_length' =&gt; ''),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 1, 'display_summary' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textarea_with_summary',&#10;      'default_formatter' =&gt; 'text_summary_or_trimmed',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_info" value="/**&#10; * Implements hook_field_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info() {&#10;  return array(&#10;    'text' =&gt; array(&#10;      'label' =&gt; t('Text'),&#10;      'description' =&gt; t('This field stores varchar text in the database.'),&#10;      'settings' =&gt; array('max_length' =&gt; 255),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textfield',&#10;      'default_formatter' =&gt; 'text_default',&#10;    ),&#10;    'text_long' =&gt; array(&#10;      'label' =&gt; t('Long text'),&#10;      'description' =&gt; t('This field stores long text in the database.'),&#10;      'settings' =&gt; array('max_length' =&gt; ''),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textarea',&#10;      'default_formatter' =&gt; 'text_default',&#10;    ),&#10;    'text_with_summary' =&gt; array(&#10;      'label' =&gt; t('Long text and summary'),&#10;      'description' =&gt; t('This field stores long text in the database along with optional summary text.'),&#10;      'settings' =&gt; array('max_length' =&gt; ''),&#10;      'instance_settings' =&gt; array('text_processing' =&gt; 1, 'display_summary' =&gt; 0),&#10;      'default_widget' =&gt; 'text_textarea_with_summary',&#10;      'default_formatter' =&gt; 'text_summary_or_trimmed',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_info_alter" value="/**&#10; * Implements hook_field_info_alter().&#10; *&#10; * Perform alterations on Field API field types.&#10; *&#10; * @param $info&#10; *   Array of information on field types exposed by hook_field_info()&#10; *   implementations.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info_alter(&amp;$info) {&#10;  // Add a setting to all field types.&#10;  foreach ($info as $field_type =&gt; $field_type_info) {&#10;    $info[$field_type]['settings'] += array(&#10;      'mymodule_additional_setting' =&gt; 'default value',&#10;    );&#10;  }&#10;&#10;  // Change the default widget for fields of type 'foo'.&#10;  if (isset($info['foo'])) {&#10;    $info['foo']['default widget'] = 'mymodule_widget';&#10;  }&#10;  $END$&#10;}" description="hook_field_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_info_alter" value="/**&#10; * Implements hook_field_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info_alter(&amp;$info) {&#10;  // Add a setting to all field types.&#10;  foreach ($info as $field_type =&gt; $field_type_info) {&#10;    $info[$field_type]['settings'] += array(&#10;      'mymodule_additional_setting' =&gt; 'default value',&#10;    );&#10;  }&#10;&#10;  // Change the default widget for fields of type 'foo'.&#10;  if (isset($info['foo'])) {&#10;    $info['foo']['default widget'] = 'mymodule_widget';&#10;  }&#10;  $END$&#10;}" description="hook_field_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_schema" value="/**&#10; * Implements hook_field_schema().&#10; *&#10; * Define the Field API schema for a field structure.&#10; *&#10; * This hook MUST be defined in .install for it to be detected during&#10; * installation and upgrade.&#10; *&#10; * @param $field&#10; *   A field structure.&#10; *&#10; * @return&#10; *   An associative array with the following keys:&#10; *   - columns: An array of Schema API column specifications, keyed by column&#10; *     name. This specifies what comprises a value for a given field. For&#10; *     example, a value for a number field is simply 'value', while a value for&#10; *     a formatted text field is the combination of 'value' and 'format'. It is&#10; *     recommended to avoid having the column definitions depend on field&#10; *     settings when possible. No assumptions should be made on how storage&#10; *     engines internally use the original column name to structure their&#10; *     storage.&#10; *   - indexes: (optional) An array of Schema API indexes definitions. Only&#10; *     columns that appear in the 'columns' array are allowed. Those indexes&#10; *     will be used as default indexes. Callers of field_create_field() can&#10; *     specify additional indexes, or, at their own risk, modify the default&#10; *     indexes specified by the field-type module. Some storage engines might&#10; *     not support indexes.&#10; *   - foreign keys: (optional) An array of Schema API foreign keys&#10; *     definitions.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_schema($field) {&#10;  if ($field['type'] == 'text_long') {&#10;    $columns = array(&#10;      'value' =&gt; array(&#10;        'type' =&gt; 'text',&#10;        'size' =&gt; 'big',&#10;        'not null' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;  else {&#10;    $columns = array(&#10;      'value' =&gt; array(&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; $field['settings']['max_length'],&#10;        'not null' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;  $columns += array(&#10;    'format' =&gt; array(&#10;      'type' =&gt; 'varchar',&#10;      'length' =&gt; 255,&#10;      'not null' =&gt; FALSE,&#10;    ),&#10;  );&#10;  return array(&#10;    'columns' =&gt; $columns,&#10;    'indexes' =&gt; array(&#10;      'format' =&gt; array('format'),&#10;    ),&#10;    'foreign keys' =&gt; array(&#10;      'format' =&gt; array(&#10;        'table' =&gt; 'filter_format',&#10;        'columns' =&gt; array('format' =&gt; 'format'),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_schema" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_schema" value="/**&#10; * Implements hook_field_schema().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_schema($field) {&#10;  if ($field['type'] == 'text_long') {&#10;    $columns = array(&#10;      'value' =&gt; array(&#10;        'type' =&gt; 'text',&#10;        'size' =&gt; 'big',&#10;        'not null' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;  else {&#10;    $columns = array(&#10;      'value' =&gt; array(&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; $field['settings']['max_length'],&#10;        'not null' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;  $columns += array(&#10;    'format' =&gt; array(&#10;      'type' =&gt; 'varchar',&#10;      'length' =&gt; 255,&#10;      'not null' =&gt; FALSE,&#10;    ),&#10;  );&#10;  return array(&#10;    'columns' =&gt; $columns,&#10;    'indexes' =&gt; array(&#10;      'format' =&gt; array('format'),&#10;    ),&#10;    'foreign keys' =&gt; array(&#10;      'format' =&gt; array(&#10;        'table' =&gt; 'filter_format',&#10;        'columns' =&gt; array('format' =&gt; 'format'),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_schema" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_load" value="/**&#10; * Implements hook_field_load().&#10; *&#10; * Define custom load behavior for this module's field types.&#10; *&#10; * Unlike most other field hooks, this hook operates on multiple entities. The&#10; * $entities, $instances and $items parameters are arrays keyed by entity ID.&#10; * For performance reasons, information for all available entity should be&#10; * loaded in a single query where possible.&#10; *&#10; * Note that the changes made to the field values get cached by the field cache&#10; * for subsequent loads. You should never use this hook to load fieldable&#10; * entities, since this is likely to cause infinite recursions when&#10; * hook_field_load() is run on those as well. Use&#10; * hook_field_formatter_prepare_view() instead.&#10; *&#10; * Make changes or additions to field values by altering the $items parameter by&#10; * reference. There is no return value.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entities&#10; *   Array of entities being loaded, keyed by entity ID.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instances&#10; *   Array of instance structures for $field for each entity, keyed by entity&#10; *   ID.&#10; * @param $langcode&#10; *   The language code associated with $items.&#10; * @param $items&#10; *   Array of field values already loaded for the entities, keyed by entity ID.&#10; *   Store your changes in this parameter (passed by reference).&#10; * @param $age&#10; *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or&#10; *   FIELD_LOAD_REVISION to load the version indicated by each entity.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_load($entity_type, $entities, $field, $instances, $langcode, &amp;$items, $age) {&#10;  // Sample code from text.module: precompute sanitized strings so they are&#10;  // stored in the field cache.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    foreach ($items[$id] as $delta =&gt; $item) {&#10;      // Only process items with a cacheable format, the rest will be handled&#10;      // by formatters if needed.&#10;      if (empty($instances[$id]['settings']['text_processing']) || filter_format_allowcache($item['format'])) {&#10;        $items[$id][$delta]['safe_value'] = isset($item['value']) ? _text_sanitize($instances[$id], $langcode, $item, 'value') : '';&#10;        if ($field['type'] == 'text_with_summary') {&#10;          $items[$id][$delta]['safe_summary'] = isset($item['summary']) ? _text_sanitize($instances[$id], $langcode, $item, 'summary') : '';&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_load" value="/**&#10; * Implements hook_field_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_load($entity_type, $entities, $field, $instances, $langcode, &amp;$items, $age) {&#10;  // Sample code from text.module: precompute sanitized strings so they are&#10;  // stored in the field cache.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    foreach ($items[$id] as $delta =&gt; $item) {&#10;      // Only process items with a cacheable format, the rest will be handled&#10;      // by formatters if needed.&#10;      if (empty($instances[$id]['settings']['text_processing']) || filter_format_allowcache($item['format'])) {&#10;        $items[$id][$delta]['safe_value'] = isset($item['value']) ? _text_sanitize($instances[$id], $langcode, $item, 'value') : '';&#10;        if ($field['type'] == 'text_with_summary') {&#10;          $items[$id][$delta]['safe_summary'] = isset($item['summary']) ? _text_sanitize($instances[$id], $langcode, $item, 'summary') : '';&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_prepare_view" value="/**&#10; * Implements hook_field_prepare_view().&#10; *&#10; * Prepare field values prior to display.&#10; *&#10; * This hook is invoked before the field values are handed to formatters&#10; * for display, and runs before the formatters' own&#10; * hook_field_formatter_prepare_view().&#10; *&#10; * Unlike most other field hooks, this hook operates on multiple entities. The&#10; * $entities, $instances and $items parameters are arrays keyed by entity ID.&#10; * For performance reasons, information for all available entities should be&#10; * loaded in a single query where possible.&#10; *&#10; * Make changes or additions to field values by altering the $items parameter by&#10; * reference. There is no return value.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entities&#10; *   Array of entities being displayed, keyed by entity ID.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instances&#10; *   Array of instance structures for $field for each entity, keyed by entity&#10; *   ID.&#10; * @param $langcode&#10; *   The language associated to $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}, or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &amp;$items) {&#10;  // Sample code from image.module: if there are no images specified at all,&#10;  // use the default image.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    if (empty($items[$id]) &amp;&amp; $field['settings']['default_image']) {&#10;      if ($file = file_load($field['settings']['default_image'])) {&#10;        $items[$id][0] = (array) $file + array(&#10;          'is_default' =&gt; TRUE,&#10;          'alt' =&gt; '',&#10;          'title' =&gt; '',&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_prepare_view" value="/**&#10; * Implements hook_field_prepare_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &amp;$items) {&#10;  // Sample code from image.module: if there are no images specified at all,&#10;  // use the default image.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    if (empty($items[$id]) &amp;&amp; $field['settings']['default_image']) {&#10;      if ($file = file_load($field['settings']['default_image'])) {&#10;        $items[$id][0] = (array) $file + array(&#10;          'is_default' =&gt; TRUE,&#10;          'alt' =&gt; '',&#10;          'title' =&gt; '',&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_validate" value="/**&#10; * Implements hook_field_validate().&#10; *&#10; * Validate this module's field data.&#10; *&#10; * If there are validation problems, add to the $errors array (passed by&#10; * reference). There is no return value.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; * @param $errors&#10; *   The array of errors (keyed by field name, language code, and delta) that&#10; *   have already been reported for the entity. The function should add its&#10; *   errors to this array. Each error is an associative array with the following&#10; *   keys and values:&#10; *   - error: An error code (should be a string prefixed with the module name).&#10; *   - message: The human readable message to be displayed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &amp;$errors) {&#10;  foreach ($items as $delta =&gt; $item) {&#10;    if (!empty($item['value'])) {&#10;      if (!empty($field['settings']['max_length']) &amp;&amp; drupal_strlen($item['value']) &gt; $field['settings']['max_length']) {&#10;        $errors[$field['field_name']][$langcode][$delta][] = array(&#10;          'error' =&gt; 'text_max_length',&#10;          'message' =&gt; t('%name: the value may not be longer than %max characters.', array('%name' =&gt; $instance['label'], '%max' =&gt; $field['settings']['max_length'])),&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_validate" value="/**&#10; * Implements hook_field_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &amp;$errors) {&#10;  foreach ($items as $delta =&gt; $item) {&#10;    if (!empty($item['value'])) {&#10;      if (!empty($field['settings']['max_length']) &amp;&amp; drupal_strlen($item['value']) &gt; $field['settings']['max_length']) {&#10;        $errors[$field['field_name']][$langcode][$delta][] = array(&#10;          'error' =&gt; 'text_max_length',&#10;          'message' =&gt; t('%name: the value may not be longer than %max characters.', array('%name' =&gt; $instance['label'], '%max' =&gt; $field['settings']['max_length'])),&#10;        );&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_presave" value="/**&#10; * Implements hook_field_presave().&#10; *&#10; * Define custom presave behavior for this module's field types.&#10; *&#10; * Make changes or additions to field values by altering the $items parameter by&#10; * reference. There is no return value.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_presave($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if ($field['type'] == 'number_decimal') {&#10;    // Let PHP round the value to ensure consistent behavior across storage&#10;    // backends.&#10;    foreach ($items as $delta =&gt; $item) {&#10;      if (isset($item['value'])) {&#10;        $items[$delta]['value'] = round($item['value'], $field['settings']['scale']);&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_presave" value="/**&#10; * Implements hook_field_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_presave($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if ($field['type'] == 'number_decimal') {&#10;    // Let PHP round the value to ensure consistent behavior across storage&#10;    // backends.&#10;    foreach ($items as $delta =&gt; $item) {&#10;      if (isset($item['value'])) {&#10;        $items[$delta]['value'] = round($item['value'], $field['settings']['scale']);&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_insert" value="/**&#10; * Implements hook_field_insert().&#10; *&#10; * Define custom insert behavior for this module's field types.&#10; *&#10; * Invoked from field_attach_insert().&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_insert($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if (variable_get('taxonomy_maintain_index_table', TRUE) &amp;&amp; $field['storage']['type'] == 'field_sql_storage' &amp;&amp; $entity_type == 'node' &amp;&amp; $entity-&gt;status) {&#10;    $query = db_insert('taxonomy_index')-&gt;fields(array('nid', 'tid', 'sticky', 'created', ));&#10;    foreach ($items as $item) {&#10;      $query-&gt;values(array(&#10;        'nid' =&gt; $entity-&gt;nid,&#10;        'tid' =&gt; $item['tid'],&#10;        'sticky' =&gt; $entity-&gt;sticky,&#10;        'created' =&gt; $entity-&gt;created,&#10;      ));&#10;    }&#10;    $query-&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_field_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_insert" value="/**&#10; * Implements hook_field_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_insert($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if (variable_get('taxonomy_maintain_index_table', TRUE) &amp;&amp; $field['storage']['type'] == 'field_sql_storage' &amp;&amp; $entity_type == 'node' &amp;&amp; $entity-&gt;status) {&#10;    $query = db_insert('taxonomy_index')-&gt;fields(array('nid', 'tid', 'sticky', 'created', ));&#10;    foreach ($items as $item) {&#10;      $query-&gt;values(array(&#10;        'nid' =&gt; $entity-&gt;nid,&#10;        'tid' =&gt; $item['tid'],&#10;        'sticky' =&gt; $entity-&gt;sticky,&#10;        'created' =&gt; $entity-&gt;created,&#10;      ));&#10;    }&#10;    $query-&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_field_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_update" value="/**&#10; * Implements hook_field_update().&#10; *&#10; * Define custom update behavior for this module's field types.&#10; *&#10; * Invoked from field_attach_update().&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if (variable_get('taxonomy_maintain_index_table', TRUE) &amp;&amp; $field['storage']['type'] == 'field_sql_storage' &amp;&amp; $entity_type == 'node') {&#10;    $first_call = &amp;drupal_static(__FUNCTION__, array());&#10;&#10;    // We don't maintain data for old revisions, so clear all previous values&#10;    // from the table. Since this hook runs once per field, per object, make&#10;    // sure we only wipe values once.&#10;    if (!isset($first_call[$entity-&gt;nid])) {&#10;      $first_call[$entity-&gt;nid] = FALSE;&#10;      db_delete('taxonomy_index')-&gt;condition('nid', $entity-&gt;nid)-&gt;execute();&#10;    }&#10;    // Only save data to the table if the node is published.&#10;    if ($entity-&gt;status) {&#10;      $query = db_insert('taxonomy_index')-&gt;fields(array('nid', 'tid', 'sticky', 'created'));&#10;      foreach ($items as $item) {&#10;        $query-&gt;values(array(&#10;          'nid' =&gt; $entity-&gt;nid,&#10;          'tid' =&gt; $item['tid'],&#10;          'sticky' =&gt; $entity-&gt;sticky,&#10;          'created' =&gt; $entity-&gt;created,&#10;        ));&#10;      }&#10;      $query-&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_update" value="/**&#10; * Implements hook_field_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  if (variable_get('taxonomy_maintain_index_table', TRUE) &amp;&amp; $field['storage']['type'] == 'field_sql_storage' &amp;&amp; $entity_type == 'node') {&#10;    $first_call = &amp;drupal_static(__FUNCTION__, array());&#10;&#10;    // We don't maintain data for old revisions, so clear all previous values&#10;    // from the table. Since this hook runs once per field, per object, make&#10;    // sure we only wipe values once.&#10;    if (!isset($first_call[$entity-&gt;nid])) {&#10;      $first_call[$entity-&gt;nid] = FALSE;&#10;      db_delete('taxonomy_index')-&gt;condition('nid', $entity-&gt;nid)-&gt;execute();&#10;    }&#10;    // Only save data to the table if the node is published.&#10;    if ($entity-&gt;status) {&#10;      $query = db_insert('taxonomy_index')-&gt;fields(array('nid', 'tid', 'sticky', 'created'));&#10;      foreach ($items as $item) {&#10;        $query-&gt;values(array(&#10;          'nid' =&gt; $entity-&gt;nid,&#10;          'tid' =&gt; $item['tid'],&#10;          'sticky' =&gt; $entity-&gt;sticky,&#10;          'created' =&gt; $entity-&gt;created,&#10;        ));&#10;      }&#10;      $query-&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_update_field" value="/**&#10; * Implements hook_field_storage_update_field().&#10; *&#10; * Update the storage information for a field.&#10; *&#10; * This is invoked on the field's storage module from field_update_field(),&#10; * before the new field information is saved to the database. The field storage&#10; * module should update its storage tables to agree with the new field&#10; * information. If there is a problem, the field storage module should throw an&#10; * exception.&#10; *&#10; * @param $field&#10; *   The updated field structure to be saved.&#10; * @param $prior_field&#10; *   The previously-saved field structure.&#10; * @param $has_data&#10; *   TRUE if the field has data in storage currently.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_update_field($field, $prior_field, $has_data) {&#10;  if (!$has_data) {&#10;    // There is no data. Re-create the tables completely.&#10;    $prior_schema = _field_sql_storage_schema($prior_field);&#10;    foreach ($prior_schema as $name =&gt; $table) {&#10;      db_drop_table($name, $table);&#10;    }&#10;    $schema = _field_sql_storage_schema($field);&#10;    foreach ($schema as $name =&gt; $table) {&#10;      db_create_table($name, $table);&#10;    }&#10;  }&#10;  else {&#10;    // There is data. See field_sql_storage_field_storage_update_field() for&#10;    // an example of what to do to modify the schema in place, preserving the&#10;    // old data as much as possible.&#10;  }&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_update_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_update_field" value="/**&#10; * Implements hook_field_storage_update_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_update_field($field, $prior_field, $has_data) {&#10;  if (!$has_data) {&#10;    // There is no data. Re-create the tables completely.&#10;    $prior_schema = _field_sql_storage_schema($prior_field);&#10;    foreach ($prior_schema as $name =&gt; $table) {&#10;      db_drop_table($name, $table);&#10;    }&#10;    $schema = _field_sql_storage_schema($field);&#10;    foreach ($schema as $name =&gt; $table) {&#10;      db_create_table($name, $table);&#10;    }&#10;  }&#10;  else {&#10;    // There is data. See field_sql_storage_field_storage_update_field() for&#10;    // an example of what to do to modify the schema in place, preserving the&#10;    // old data as much as possible.&#10;  }&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_update_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_delete" value="/**&#10; * Implements hook_field_delete().&#10; *&#10; * Define custom delete behavior for this module's field types.&#10; *&#10; * This hook is invoked just before the data is deleted from field storage&#10; * in field_attach_delete().&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;  foreach ($items as $delta =&gt; $item) {&#10;    // For hook_file_references(), remember that this is being deleted.&#10;    $item['file_field_name'] = $field['field_name'];&#10;    // Pass in the ID of the object that is being removed so all references can&#10;    // be counted in hook_file_references().&#10;    $item['file_field_type'] = $entity_type;&#10;    $item['file_field_id'] = $id;&#10;    file_field_delete_file($item, $field);&#10;  }&#10;  $END$&#10;}" description="hook_field_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_delete" value="/**&#10; * Implements hook_field_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;  foreach ($items as $delta =&gt; $item) {&#10;    // For hook_file_references(), remember that this is being deleted.&#10;    $item['file_field_name'] = $field['field_name'];&#10;    // Pass in the ID of the object that is being removed so all references can&#10;    // be counted in hook_file_references().&#10;    $item['file_field_type'] = $entity_type;&#10;    $item['file_field_id'] = $id;&#10;    file_field_delete_file($item, $field);&#10;  }&#10;  $END$&#10;}" description="hook_field_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_delete_revision" value="/**&#10; * Implements hook_field_delete_revision().&#10; *&#10; * Define custom revision delete behavior for this module's field types.&#10; *&#10; * This hook is invoked just before the data is deleted from field storage&#10; * in field_attach_delete_revision(), and will only be called for fieldable&#10; * types that are versioned.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  foreach ($items as $delta =&gt; $item) {&#10;    // For hook_file_references, remember that this file is being deleted.&#10;    $item['file_field_name'] = $field['field_name'];&#10;    if (file_field_delete_file($item, $field)) {&#10;      $items[$delta] = NULL;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_delete_revision" value="/**&#10; * Implements hook_field_delete_revision().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &amp;$items) {&#10;  foreach ($items as $delta =&gt; $item) {&#10;    // For hook_file_references, remember that this file is being deleted.&#10;    $item['file_field_name'] = $field['field_name'];&#10;    if (file_field_delete_file($item, $field)) {&#10;      $items[$delta] = NULL;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_prepare_translation" value="/**&#10; * Implements hook_field_prepare_translation().&#10; *&#10; * Define custom prepare_translation behavior for this module's field types.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity for the operation.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structure for $field on $entity's bundle.&#10; * @param $langcode&#10; *   The language associated to $items.&#10; * @param $items&#10; *   $entity-&gt;{$field['field_name']}[$langcode], or an empty array if unset.&#10; * @param $source_entity&#10; *   The source entity from which field values are being copied.&#10; * @param $source_langcode&#10; *   The source language from which field values are being copied.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &amp;$items, $source_entity, $source_langcode) {&#10;  // If the translating user is not permitted to use the assigned text format,&#10;  // we must not expose the source values.&#10;  $field_name = $field['field_name'];&#10;  $formats = filter_formats();&#10;  $format_id = $source_entity-&gt;{$field_name}[$source_langcode][0]['format'];&#10;  if (!filter_access($formats[$format_id])) {&#10;    $items = array();&#10;  }&#10;  $END$&#10;}" description="hook_field_prepare_translation" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_prepare_translation" value="/**&#10; * Implements hook_field_prepare_translation().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &amp;$items, $source_entity, $source_langcode) {&#10;  // If the translating user is not permitted to use the assigned text format,&#10;  // we must not expose the source values.&#10;  $field_name = $field['field_name'];&#10;  $formats = filter_formats();&#10;  $format_id = $source_entity-&gt;{$field_name}[$source_langcode][0]['format'];&#10;  if (!filter_access($formats[$format_id])) {&#10;    $items = array();&#10;  }&#10;  $END$&#10;}" description="hook_field_prepare_translation" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_is_empty" value="/**&#10; * Implements hook_field_is_empty().&#10; *&#10; * Define what constitutes an empty item for a field type.&#10; *&#10; * @param $item&#10; *   An item that may or may not be empty.&#10; * @param $field&#10; *   The field to which $item belongs.&#10; *&#10; * @return&#10; *   TRUE if $field's type considers $item not to contain any data;&#10; *   FALSE otherwise.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_is_empty($item, $field) {&#10;  if (empty($item['value']) &amp;&amp; (string) $item['value'] !== '0') {&#10;    return TRUE;&#10;  }&#10;  return FALSE;&#10;  $END$&#10;}" description="hook_field_is_empty" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_is_empty" value="/**&#10; * Implements hook_field_is_empty().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_is_empty($item, $field) {&#10;  if (empty($item['value']) &amp;&amp; (string) $item['value'] !== '0') {&#10;    return TRUE;&#10;  }&#10;  return FALSE;&#10;  $END$&#10;}" description="hook_field_is_empty" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_info" value="/**&#10; * Implements hook_field_widget_info().&#10; *&#10; * Expose Field API widget types.&#10; *&#10; * Widgets are Form API elements with additional processing capabilities.&#10; * Widget hooks are typically called by the Field Attach API during the&#10; * creation of the field form structure with field_attach_form().&#10; *&#10; * @return&#10; *   An array describing the widget types implemented by the module.&#10; *   The keys are widget type names. To avoid name clashes, widget type&#10; *   names should be prefixed with the name of the module that exposes them.&#10; *   The values are arrays describing the widget type, with the following&#10; *   key/value pairs:&#10; *   - label: The human-readable name of the widget type.&#10; *   - description: A short description for the widget type.&#10; *   - field types: An array of field types the widget supports.&#10; *   - settings: An array whose keys are the names of the settings available&#10; *     for the widget type, and whose values are the default values for those&#10; *     settings.&#10; *   - behaviors: (optional) An array describing behaviors of the widget, with&#10; *     the following elements:&#10; *     - multiple values: One of the following constants:&#10; *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget allows the input of&#10; *         one single field value (most common case). The widget will be&#10; *         repeated for each value input.&#10; *       - FIELD_BEHAVIOR_CUSTOM: If one single copy of the widget can receive&#10; *         several field values. Examples: checkboxes, multiple select,&#10; *         comma-separated textfield.&#10; *     - default value: One of the following constants:&#10; *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget accepts default&#10; *         values.&#10; *       - FIELD_BEHAVIOR_NONE: if the widget does not support default values.&#10; *&#10; * @see hook_field_widget_info_alter()&#10; * @see hook_field_widget_form()&#10; * @see hook_field_widget_form_alter()&#10; * @see hook_field_widget_WIDGET_TYPE_form_alter()&#10; * @see hook_field_widget_error()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_info() {&#10;    return array(&#10;    'text_textfield' =&gt; array(&#10;      'label' =&gt; t('Text field'),&#10;      'field types' =&gt; array('text'),&#10;      'settings' =&gt; array('size' =&gt; 60),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;    'text_textarea' =&gt; array(&#10;      'label' =&gt; t('Text area (multiple rows)'),&#10;      'field types' =&gt; array('text_long'),&#10;      'settings' =&gt; array('rows' =&gt; 5),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;    'text_textarea_with_summary' =&gt; array(&#10;      'label' =&gt; t('Text area with a summary'),&#10;      'field types' =&gt; array('text_with_summary'),&#10;      'settings' =&gt; array('rows' =&gt; 20, 'summary_rows' =&gt; 5),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_widget_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_info" value="/**&#10; * Implements hook_field_widget_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_info() {&#10;    return array(&#10;    'text_textfield' =&gt; array(&#10;      'label' =&gt; t('Text field'),&#10;      'field types' =&gt; array('text'),&#10;      'settings' =&gt; array('size' =&gt; 60),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;    'text_textarea' =&gt; array(&#10;      'label' =&gt; t('Text area (multiple rows)'),&#10;      'field types' =&gt; array('text_long'),&#10;      'settings' =&gt; array('rows' =&gt; 5),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;    'text_textarea_with_summary' =&gt; array(&#10;      'label' =&gt; t('Text area with a summary'),&#10;      'field types' =&gt; array('text_with_summary'),&#10;      'settings' =&gt; array('rows' =&gt; 20, 'summary_rows' =&gt; 5),&#10;      'behaviors' =&gt; array(&#10;        'multiple values' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;        'default value' =&gt; FIELD_BEHAVIOR_DEFAULT,&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_widget_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_info_alter" value="/**&#10; * Implements hook_field_widget_info_alter().&#10; *&#10; * Perform alterations on Field API widget types.&#10; *&#10; * @param $info&#10; *   Array of informations on widget types exposed by hook_field_widget_info()&#10; *   implementations.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_info_alter(&amp;$info) {&#10;  // Add a setting to a widget type.&#10;  $info['text_textfield']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;&#10;  // Let a new field type re-use an existing widget.&#10;  $info['options_select']['field types'][] = 'my_field_type';&#10;  $END$&#10;}" description="hook_field_widget_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_info_alter" value="/**&#10; * Implements hook_field_widget_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_info_alter(&amp;$info) {&#10;  // Add a setting to a widget type.&#10;  $info['text_textfield']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;&#10;  // Let a new field type re-use an existing widget.&#10;  $info['options_select']['field types'][] = 'my_field_type';&#10;  $END$&#10;}" description="hook_field_widget_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_form" value="/**&#10; * Implements hook_field_widget_form().&#10; *&#10; * Return the form for a single field widget.&#10; *&#10; * Field widget form elements should be based on the passed-in $element, which&#10; * contains the base form element properties derived from the field&#10; * configuration.&#10; *&#10; * Field API will set the weight, field name and delta values for each form&#10; * element. If there are multiple values for this field, the Field API will&#10; * invoke this hook as many times as needed.&#10; *&#10; * Note that, depending on the context in which the widget is being included&#10; * (regular entity form, field configuration form, advanced search form...),&#10; * the values for $field and $instance might be different from the &quot;official&quot;&#10; * definitions returned by field_info_field() and field_info_instance().&#10; * Examples: mono-value widget even if the field is multi-valued, non-required&#10; * widget even if the field is 'required'...&#10; *&#10; * Therefore, the FAPI element callbacks (such as #process, #element_validate,&#10; * #value_callback...) used by the widget cannot use the field_info_field()&#10; * or field_info_instance() functions to retrieve the $field or $instance&#10; * definitions they should operate on. The field_widget_field() and&#10; * field_widget_instance() functions should be used instead to fetch the&#10; * current working definitions from $form_state, where Field API stores them.&#10; *&#10; * Alternatively, hook_field_widget_form() can extract the needed specific&#10; * properties from $field and $instance and set them as ad-hoc&#10; * $element['#custom'] properties, for later use by its element callbacks.&#10; *&#10; * Other modules may alter the form element provided by this function using&#10; * hook_field_widget_form_alter().&#10; *&#10; * @param $form&#10; *   The form structure where widgets are being attached to. This might be a&#10; *   full form structure, or a sub-element of a larger form.&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; * @param $field&#10; *   The field structure.&#10; * @param $instance&#10; *   The field instance.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   Array of default values for this field.&#10; * @param $delta&#10; *   The order of this item in the array of subelements (0, 1, 2, etc).&#10; * @param $element&#10; *   A form element array containing basic properties for the widget:&#10; *   - #entity_type: The name of the entity the field is attached to.&#10; *   - #bundle: The name of the field bundle the field is contained in.&#10; *   - #field_name: The name of the field.&#10; *   - #language: The language the field is being edited in.&#10; *   - #field_parents: The 'parents' space for the field in the form. Most&#10; *       widgets can simply overlook this property. This identifies the&#10; *       location where the field values are placed within&#10; *       $form_state['values'], and is used to access processing information&#10; *       for the field through the field_form_get_state() and&#10; *       field_form_set_state() functions.&#10; *   - #columns: A list of field storage columns of the field.&#10; *   - #title: The sanitized element label for the field instance, ready for&#10; *     output.&#10; *   - #description: The sanitized element description for the field instance,&#10; *     ready for output.&#10; *   - #required: A Boolean indicating whether the element value is required;&#10; *     for required multiple value fields, only the first widget's values are&#10; *     required.&#10; *   - #delta: The order of this item in the array of subelements; see $delta&#10; *     above.&#10; *&#10; * @return&#10; *   The form elements for a single widget for this field.&#10; *&#10; * @see field_widget_field()&#10; * @see field_widget_instance()&#10; * @see hook_field_widget_form_alter()&#10; * @see hook_field_widget_WIDGET_TYPE_form_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_form(&amp;$form, &amp;$form_state, $field, $instance, $langcode, $items, $delta, $element) {&#10;  $element += array(&#10;    '#type' =&gt; $instance['widget']['type'],&#10;    '#default_value' =&gt; isset($items[$delta]) ? $items[$delta] : '',&#10;  );&#10;  return $element;&#10;  $END$&#10;}" description="hook_field_widget_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_form" value="/**&#10; * Implements hook_field_widget_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_form(&amp;$form, &amp;$form_state, $field, $instance, $langcode, $items, $delta, $element) {&#10;  $element += array(&#10;    '#type' =&gt; $instance['widget']['type'],&#10;    '#default_value' =&gt; isset($items[$delta]) ? $items[$delta] : '',&#10;  );&#10;  return $element;&#10;  $END$&#10;}" description="hook_field_widget_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_form_alter" value="/**&#10; * Implements hook_field_widget_form_alter().&#10; *&#10; * Alter forms for field widgets provided by other modules.&#10; *&#10; * @param $element&#10; *   The field widget form element as constructed by hook_field_widget_form().&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; * @param $context&#10; *   An associative array containing the following key-value pairs, matching the&#10; *   arguments received by hook_field_widget_form():&#10; *   - &quot;form&quot;: The form structure where widgets are being attached to. This&#10; *     might be a full form structure, or a sub-element of a larger form.&#10; *   - &quot;field&quot;: The field structure.&#10; *   - &quot;instance&quot;: The field instance structure.&#10; *   - &quot;langcode&quot;: The language associated with $items.&#10; *   - &quot;items&quot;: Array of default values for this field.&#10; *   - &quot;delta&quot;: The order of this item in the array of subelements (0, 1, 2,&#10; *     etc).&#10; *&#10; * @see hook_field_widget_form()&#10; * @see hook_field_widget_WIDGET_TYPE_form_alter&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_form_alter(&amp;$element, &amp;$form_state, $context) {&#10;  // Add a css class to widget form elements for all fields of type mytype.&#10;  if ($context['field']['type'] == 'mytype') {&#10;    // Be sure not to overwrite existing attributes.&#10;    $element['#attributes']['class'][] = 'myclass';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_form_alter" value="/**&#10; * Implements hook_field_widget_form_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_form_alter(&amp;$element, &amp;$form_state, $context) {&#10;  // Add a css class to widget form elements for all fields of type mytype.&#10;  if ($context['field']['type'] == 'mytype') {&#10;    // Be sure not to overwrite existing attributes.&#10;    $element['#attributes']['class'][] = 'myclass';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_WIDGET_TYPE_form_alter" value="/**&#10; * Implements hook_field_widget_WIDGET_TYPE_form_alter().&#10; *&#10; * Alter widget forms for a specific widget provided by another module.&#10; *&#10; * Modules can implement hook_field_widget_WIDGET_TYPE_form_alter() to modify a&#10; * specific widget form, rather than using hook_field_widget_form_alter() and&#10; * checking the widget type.&#10; *&#10; * @param $element&#10; *   The field widget form element as constructed by hook_field_widget_form().&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; * @param $context&#10; *   An associative array containing the following key-value pairs, matching the&#10; *   arguments received by hook_field_widget_form():&#10; *   - &quot;form&quot;: The form structure where widgets are being attached to. This&#10; *     might be a full form structure, or a sub-element of a larger form.&#10; *   - &quot;field&quot;: The field structure.&#10; *   - &quot;instance&quot;: The field instance structure.&#10; *   - &quot;langcode&quot;: The language associated with $items.&#10; *   - &quot;items&quot;: Array of default values for this field.&#10; *   - &quot;delta&quot;: The order of this item in the array of subelements (0, 1, 2,&#10; *     etc).&#10; *&#10; * @see hook_field_widget_form()&#10; * @see hook_field_widget_form_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_WIDGET_TYPE_form_alter(&amp;$element, &amp;$form_state, $context) {&#10;  // Code here will only act on widgets of type WIDGET_TYPE.  For example,&#10;  // hook_field_widget_mymodule_autocomplete_form_alter() will only act on&#10;  // widgets of type 'mymodule_autocomplete'.&#10;  $element['#autocomplete_path'] = 'mymodule/autocomplete_path';&#10;  $END$&#10;}" description="hook_field_widget_WIDGET_TYPE_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_WIDGET_TYPE_form_alter" value="/**&#10; * Implements hook_field_widget_WIDGET_TYPE_form_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_WIDGET_TYPE_form_alter(&amp;$element, &amp;$form_state, $context) {&#10;  // Code here will only act on widgets of type WIDGET_TYPE.  For example,&#10;  // hook_field_widget_mymodule_autocomplete_form_alter() will only act on&#10;  // widgets of type 'mymodule_autocomplete'.&#10;  $element['#autocomplete_path'] = 'mymodule/autocomplete_path';&#10;  $END$&#10;}" description="hook_field_widget_WIDGET_TYPE_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_error" value="/**&#10; * Implements hook_field_widget_error().&#10; *&#10; * Flag a field-level validation error.&#10; *&#10; * @param $element&#10; *   An array containing the form element for the widget. The error needs to be&#10; *   flagged on the right sub-element, according to the widget's internal&#10; *   structure.&#10; * @param $error&#10; *   An associative array with the following key-value pairs, as returned by&#10; *   hook_field_validate():&#10; *   - error: the error code. Complex widgets might need to report different&#10; *     errors to different form elements inside the widget.&#10; *   - message: the human readable message to be displayed.&#10; * @param $form&#10; *   The form structure where field elements are attached to. This might be a&#10; *   full form structure, or a sub-element of a larger form.&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_error($element, $error, $form, &amp;$form_state) {&#10;  form_error($element['value'], $error['message']);&#10;  $END$&#10;}" description="hook_field_widget_error" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_error" value="/**&#10; * Implements hook_field_widget_error().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_error($element, $error, $form, &amp;$form_state) {&#10;  form_error($element['value'], $error['message']);&#10;  $END$&#10;}" description="hook_field_widget_error" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_info" value="/**&#10; * Implements hook_field_formatter_info().&#10; *&#10; * Expose Field API formatter types.&#10; *&#10; * Formatters handle the display of field values. Formatter hooks are typically&#10; * called by the Field Attach API field_attach_prepare_view() and&#10; * field_attach_view() functions.&#10; *&#10; * @return&#10; *   An array describing the formatter types implemented by the module.&#10; *   The keys are formatter type names. To avoid name clashes, formatter type&#10; *   names should be prefixed with the name of the module that exposes them.&#10; *   The values are arrays describing the formatter type, with the following&#10; *   key/value pairs:&#10; *   - label: The human-readable name of the formatter type.&#10; *   - description: A short description for the formatter type.&#10; *   - field types: An array of field types the formatter supports.&#10; *   - settings: An array whose keys are the names of the settings available&#10; *     for the formatter type, and whose values are the default values for&#10; *     those settings.&#10; *&#10; * @see hook_field_formatter_info_alter()&#10; * @see hook_field_formatter_view()&#10; * @see hook_field_formatter_prepare_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_info() {&#10;  return array(&#10;    'text_default' =&gt; array(&#10;      'label' =&gt; t('Default'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;    'text_plain' =&gt; array(&#10;      'label' =&gt; t('Plain text'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;&#10;    // The text_trimmed formatter displays the trimmed version of the&#10;    // full element of the field. It is intended to be used with text&#10;    // and text_long fields. It also works with text_with_summary&#10;    // fields though the text_summary_or_trimmed formatter makes more&#10;    // sense for that field type.&#10;    'text_trimmed' =&gt; array(&#10;      'label' =&gt; t('Trimmed'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;&#10;    // The 'summary or trimmed' field formatter for text_with_summary&#10;    // fields displays returns the summary element of the field or, if&#10;    // the summary is empty, the trimmed version of the full element&#10;    // of the field.&#10;    'text_summary_or_trimmed' =&gt; array(&#10;      'label' =&gt; t('Summary or trimmed'),&#10;      'field types' =&gt; array('text_with_summary'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_formatter_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_info" value="/**&#10; * Implements hook_field_formatter_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_info() {&#10;  return array(&#10;    'text_default' =&gt; array(&#10;      'label' =&gt; t('Default'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;    'text_plain' =&gt; array(&#10;      'label' =&gt; t('Plain text'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;&#10;    // The text_trimmed formatter displays the trimmed version of the&#10;    // full element of the field. It is intended to be used with text&#10;    // and text_long fields. It also works with text_with_summary&#10;    // fields though the text_summary_or_trimmed formatter makes more&#10;    // sense for that field type.&#10;    'text_trimmed' =&gt; array(&#10;      'label' =&gt; t('Trimmed'),&#10;      'field types' =&gt; array('text', 'text_long', 'text_with_summary'),&#10;    ),&#10;&#10;    // The 'summary or trimmed' field formatter for text_with_summary&#10;    // fields displays returns the summary element of the field or, if&#10;    // the summary is empty, the trimmed version of the full element&#10;    // of the field.&#10;    'text_summary_or_trimmed' =&gt; array(&#10;      'label' =&gt; t('Summary or trimmed'),&#10;      'field types' =&gt; array('text_with_summary'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_formatter_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_info_alter" value="/**&#10; * Implements hook_field_formatter_info_alter().&#10; *&#10; * Perform alterations on Field API formatter types.&#10; *&#10; * @param $info&#10; *   Array of informations on formatter types exposed by&#10; *   hook_field_field_formatter_info() implementations.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_info_alter(&amp;$info) {&#10;  // Add a setting to a formatter type.&#10;  $info['text_default']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;&#10;  // Let a new field type re-use an existing formatter.&#10;  $info['text_default']['field types'][] = 'my_field_type';&#10;  $END$&#10;}" description="hook_field_formatter_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_info_alter" value="/**&#10; * Implements hook_field_formatter_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_info_alter(&amp;$info) {&#10;  // Add a setting to a formatter type.&#10;  $info['text_default']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;&#10;  // Let a new field type re-use an existing formatter.&#10;  $info['text_default']['field types'][] = 'my_field_type';&#10;  $END$&#10;}" description="hook_field_formatter_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_prepare_view" value="/**&#10; * Implements hook_field_formatter_prepare_view().&#10; *&#10; * Allow formatters to load information for field values being displayed.&#10; *&#10; * This should be used when a formatter needs to load additional information&#10; * from the database in order to render a field, for example a reference field&#10; * which displays properties of the referenced entities such as name or type.&#10; *&#10; * This hook is called after the field type's own hook_field_prepare_view().&#10; *&#10; * Unlike most other field hooks, this hook operates on multiple entities. The&#10; * $entities, $instances and $items parameters are arrays keyed by entity ID.&#10; * For performance reasons, information for all available entities should be&#10; * loaded in a single query where possible.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entities&#10; *   Array of entities being displayed, keyed by entity ID.&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instances&#10; *   Array of instance structures for $field for each entity, keyed by entity&#10; *   ID.&#10; * @param $langcode&#10; *   The language the field values are to be shown in. If no language is&#10; *   provided the current language is used.&#10; * @param $items&#10; *   Array of field values for the entities, keyed by entity ID.&#10; * @param $displays&#10; *   Array of display settings to use for each entity, keyed by entity ID.&#10; *&#10; * @return&#10; *   Changes or additions to field values are done by altering the $items&#10; *   parameter by reference.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &amp;$items, $displays) {&#10;  $tids = array();&#10;&#10;  // Collect every possible term attached to any of the fieldable entities.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    foreach ($items[$id] as $delta =&gt; $item) {&#10;      // Force the array key to prevent duplicates.&#10;      $tids[$item['tid']] = $item['tid'];&#10;    }&#10;  }&#10;&#10;  if ($tids) {&#10;    $terms = taxonomy_term_load_multiple($tids);&#10;&#10;    // Iterate through the fieldable entities again to attach the loaded term&#10;    // data.&#10;    foreach ($entities as $id =&gt; $entity) {&#10;      $rekey = FALSE;&#10;&#10;      foreach ($items[$id] as $delta =&gt; $item) {&#10;        // Check whether the taxonomy term field instance value could be loaded.&#10;        if (isset($terms[$item['tid']])) {&#10;          // Replace the instance value with the term data.&#10;          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];&#10;        }&#10;        // Otherwise, unset the instance value, since the term does not exist.&#10;        else {&#10;          unset($items[$id][$delta]);&#10;          $rekey = TRUE;&#10;        }&#10;      }&#10;&#10;      if ($rekey) {&#10;        // Rekey the items array.&#10;        $items[$id] = array_values($items[$id]);&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_formatter_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_prepare_view" value="/**&#10; * Implements hook_field_formatter_prepare_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &amp;$items, $displays) {&#10;  $tids = array();&#10;&#10;  // Collect every possible term attached to any of the fieldable entities.&#10;  foreach ($entities as $id =&gt; $entity) {&#10;    foreach ($items[$id] as $delta =&gt; $item) {&#10;      // Force the array key to prevent duplicates.&#10;      $tids[$item['tid']] = $item['tid'];&#10;    }&#10;  }&#10;&#10;  if ($tids) {&#10;    $terms = taxonomy_term_load_multiple($tids);&#10;&#10;    // Iterate through the fieldable entities again to attach the loaded term&#10;    // data.&#10;    foreach ($entities as $id =&gt; $entity) {&#10;      $rekey = FALSE;&#10;&#10;      foreach ($items[$id] as $delta =&gt; $item) {&#10;        // Check whether the taxonomy term field instance value could be loaded.&#10;        if (isset($terms[$item['tid']])) {&#10;          // Replace the instance value with the term data.&#10;          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];&#10;        }&#10;        // Otherwise, unset the instance value, since the term does not exist.&#10;        else {&#10;          unset($items[$id][$delta]);&#10;          $rekey = TRUE;&#10;        }&#10;      }&#10;&#10;      if ($rekey) {&#10;        // Rekey the items array.&#10;        $items[$id] = array_values($items[$id]);&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_formatter_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_view" value="/**&#10; * Implements hook_field_formatter_view().&#10; *&#10; * Build a renderable array for a field value.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity.&#10; * @param $entity&#10; *   The entity being displayed.&#10; * @param $field&#10; *   The field structure.&#10; * @param $instance&#10; *   The field instance.&#10; * @param $langcode&#10; *   The language associated with $items.&#10; * @param $items&#10; *   Array of values for this field.&#10; * @param $display&#10; *   The display settings to use, as found in the 'display' entry of instance&#10; *   definitions. The array notably contains the following keys and values;&#10; *   - type: The name of the formatter to use.&#10; *   - settings: The array of formatter settings.&#10; *&#10; * @return&#10; *   A renderable array for the $items, as an array of child elements keyed&#10; *   by numeric indexes starting from 0.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {&#10;  $element = array();&#10;  $settings = $display['settings'];&#10;&#10;  switch ($display['type']) {&#10;    case 'sample_field_formatter_simple':&#10;      // Common case: each value is displayed individually in a sub-element&#10;      // keyed by delta. The field.tpl.php template specifies the markup&#10;      // wrapping each value.&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $element[$delta] = array('#markup' =&gt; $settings['some_setting'] . $item['value']);&#10;      }&#10;      break;&#10;&#10;    case 'sample_field_formatter_themeable':&#10;      // More elaborate formatters can defer to a theme function for easier&#10;      // customization.&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $element[$delta] = array(&#10;          '#theme' =&gt; 'mymodule_theme_sample_field_formatter_themeable',&#10;          '#data' =&gt; $item['value'],&#10;          '#some_setting' =&gt; $settings['some_setting'],&#10;        );&#10;      }&#10;      break;&#10;&#10;    case 'sample_field_formatter_combined':&#10;      // Some formatters might need to display all values within a single piece&#10;      // of markup.&#10;      $rows = array();&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $rows[] = array($delta, $item['value']);&#10;      }&#10;      $element[0] = array(&#10;        '#theme' =&gt; 'table',&#10;        '#header' =&gt; array(t('Delta'), t('Value')),&#10;        '#rows' =&gt; $rows,&#10;      );&#10;      break;&#10;  }&#10;&#10;  return $element;&#10;  $END$&#10;}" description="hook_field_formatter_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_view" value="/**&#10; * Implements hook_field_formatter_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {&#10;  $element = array();&#10;  $settings = $display['settings'];&#10;&#10;  switch ($display['type']) {&#10;    case 'sample_field_formatter_simple':&#10;      // Common case: each value is displayed individually in a sub-element&#10;      // keyed by delta. The field.tpl.php template specifies the markup&#10;      // wrapping each value.&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $element[$delta] = array('#markup' =&gt; $settings['some_setting'] . $item['value']);&#10;      }&#10;      break;&#10;&#10;    case 'sample_field_formatter_themeable':&#10;      // More elaborate formatters can defer to a theme function for easier&#10;      // customization.&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $element[$delta] = array(&#10;          '#theme' =&gt; 'mymodule_theme_sample_field_formatter_themeable',&#10;          '#data' =&gt; $item['value'],&#10;          '#some_setting' =&gt; $settings['some_setting'],&#10;        );&#10;      }&#10;      break;&#10;&#10;    case 'sample_field_formatter_combined':&#10;      // Some formatters might need to display all values within a single piece&#10;      // of markup.&#10;      $rows = array();&#10;      foreach ($items as $delta =&gt; $item) {&#10;        $rows[] = array($delta, $item['value']);&#10;      }&#10;      $element[0] = array(&#10;        '#theme' =&gt; 'table',&#10;        '#header' =&gt; array(t('Delta'), t('Value')),&#10;        '#rows' =&gt; $rows,&#10;      );&#10;      break;&#10;  }&#10;&#10;  return $element;&#10;  $END$&#10;}" description="hook_field_formatter_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_form" value="/**&#10; * Implements hook_field_attach_form().&#10; *&#10; * Act on field_attach_form().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; * Implementing modules should alter the $form or $form_state parameters.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The entity for which an edit form is being built.&#10; * @param $form&#10; *   The form structure where field elements are attached to. This might be a&#10; *   full form structure, or a sub-element of a larger form. The&#10; *   $form['#parents'] property can be used to identify the corresponding part&#10; *   of $form_state['values']. Hook implementations that need to act on the&#10; *   top-level properties of the global form (like #submit, #validate...) can&#10; *   add a #process callback to the array received in the $form parameter, and&#10; *   act on the $complete_form parameter in the process callback.&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; * @param $langcode&#10; *   The language the field values are going to be entered in. If no language&#10; *   is provided the default site language will be used.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_form($entity_type, $entity, &amp;$form, &amp;$form_state, $langcode) {&#10;  // Add a checkbox allowing a given field to be emptied.&#10;  // See hook_field_attach_submit() for the corresponding processing code.&#10;  $form['empty_field_foo'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;Empty the 'field_foo' field&quot;),&#10;  );&#10;  $END$&#10;}" description="hook_field_attach_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_form" value="/**&#10; * Implements hook_field_attach_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_form($entity_type, $entity, &amp;$form, &amp;$form_state, $langcode) {&#10;  // Add a checkbox allowing a given field to be emptied.&#10;  // See hook_field_attach_submit() for the corresponding processing code.&#10;  $form['empty_field_foo'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;Empty the 'field_foo' field&quot;),&#10;  );&#10;  $END$&#10;}" description="hook_field_attach_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_load" value="/**&#10; * Implements hook_field_attach_load().&#10; *&#10; * Act on field_attach_load().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * Unlike other field_attach hooks, this hook accounts for 'multiple loads'.&#10; * Instead of the usual $entity parameter, it accepts an array of entities,&#10; * indexed by entity ID. For performance reasons, information for all available&#10; * entities should be loaded in a single query where possible.&#10; *&#10; * The changes made to the entities' field values get cached by the field cache&#10; * for subsequent loads.&#10; *&#10; * See field_attach_load() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_load($entity_type, $entities, $age, $options) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_load" value="/**&#10; * Implements hook_field_attach_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_load($entity_type, $entities, $age, $options) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_validate" value="/**&#10; * Implements hook_field_attach_validate().&#10; *&#10; * Act on field_attach_validate().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_validate() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_validate($entity_type, $entity, &amp;$errors) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_validate" value="/**&#10; * Implements hook_field_attach_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_validate($entity_type, $entity, &amp;$errors) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_submit" value="/**&#10; * Implements hook_field_attach_submit().&#10; *&#10; * Act on field_attach_submit().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The entity for which an edit form is being submitted. The incoming form&#10; *   values have been extracted as field values of the $entity object.&#10; * @param $form&#10; *   The form structure where field elements are attached to. This might be a&#10; *   full form structure, or a sub-part of a larger form. The $form['#parents']&#10; *   property can be used to identify the corresponding part of&#10; *   $form_state['values'].&#10; * @param $form_state&#10; *   An associative array containing the current state of the form.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_submit($entity_type, $entity, $form, &amp;$form_state) {&#10;  // Sample case of an 'Empty the field' checkbox added on the form, allowing&#10;  // a given field to be emptied.&#10;  $values = drupal_array_get_nested_value($form_state['values'], $form['#parents']);&#10;  if (!empty($values['empty_field_foo'])) {&#10;    unset($entity-&gt;field_foo);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_submit" value="/**&#10; * Implements hook_field_attach_submit().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_submit($entity_type, $entity, $form, &amp;$form_state) {&#10;  // Sample case of an 'Empty the field' checkbox added on the form, allowing&#10;  // a given field to be emptied.&#10;  $values = drupal_array_get_nested_value($form_state['values'], $form['#parents']);&#10;  if (!empty($values['empty_field_foo'])) {&#10;    unset($entity-&gt;field_foo);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_presave" value="/**&#10; * Implements hook_field_attach_presave().&#10; *&#10; * Act on field_attach_presave().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_presave() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_presave($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_presave" value="/**&#10; * Implements hook_field_attach_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_presave($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_insert" value="/**&#10; * Implements hook_field_attach_insert().&#10; *&#10; * Act on field_attach_insert().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_insert() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_insert($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_insert" value="/**&#10; * Implements hook_field_attach_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_insert($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_update" value="/**&#10; * Implements hook_field_attach_update().&#10; *&#10; * Act on field_attach_update().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_update() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_update($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_update" value="/**&#10; * Implements hook_field_attach_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_update($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_preprocess_alter" value="/**&#10; * Implements hook_field_attach_preprocess_alter().&#10; *&#10; * Alter field_attach_preprocess() variables.&#10; *&#10; * This hook is invoked while preprocessing the field.tpl.php template file&#10; * in field_attach_preprocess().&#10; *&#10; * @param $variables&#10; *   The variables array is passed by reference and will be populated with field&#10; *   values.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The type of $entity; for example, 'node' or 'user'.&#10; *   - entity: The entity with fields to render.&#10; *   - element: The structured array containing the values ready for rendering.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_preprocess_alter(&amp;$variables, $context) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_preprocess_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_preprocess_alter" value="/**&#10; * Implements hook_field_attach_preprocess_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_preprocess_alter(&amp;$variables, $context) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_preprocess_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_delete" value="/**&#10; * Implements hook_field_attach_delete().&#10; *&#10; * Act on field_attach_delete().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_delete() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_delete" value="/**&#10; * Implements hook_field_attach_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_delete_revision" value="/**&#10; * Implements hook_field_attach_delete_revision().&#10; *&#10; * Act on field_attach_delete_revision().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_delete_revision() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete_revision($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_delete_revision" value="/**&#10; * Implements hook_field_attach_delete_revision().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete_revision($entity_type, $entity) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_attach_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_purge" value="/**&#10; * Implements hook_field_attach_purge().&#10; *&#10; * Act on field_purge_data().&#10; *&#10; * This hook is invoked in field_purge_data() and allows modules to act on&#10; * purging data from a single field pseudo-entity. For example, if a module&#10; * relates data in the field with its own data, it may purge its own data&#10; * during this process as well.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The pseudo-entity whose field data is being purged.&#10; * @param $field&#10; *   The (possibly deleted) field whose data is being purged.&#10; * @param $instance&#10; *   The deleted field instance whose data is being purged.&#10; *&#10; * @see @link field_purge Field API bulk data deletion @endlink&#10; * @see field_purge_data()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_purge($entity_type, $entity, $field, $instance) {&#10;  // find the corresponding data in mymodule and purge it&#10;  if ($entity_type == 'node' &amp;&amp; $field-&gt;field_name == 'my_field_name') {&#10;    mymodule_remove_mydata($entity-&gt;nid);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_purge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_purge" value="/**&#10; * Implements hook_field_attach_purge().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_purge($entity_type, $entity, $field, $instance) {&#10;  // find the corresponding data in mymodule and purge it&#10;  if ($entity_type == 'node' &amp;&amp; $field-&gt;field_name == 'my_field_name') {&#10;    mymodule_remove_mydata($entity-&gt;nid);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_purge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_view_alter" value="/**&#10; * Implements hook_field_attach_view_alter().&#10; *&#10; * Perform alterations on field_attach_view() or field_view_field().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * @param $output&#10; *   The structured content array tree for all of the entity's fields.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The type of $entity; for example, 'node' or 'user'.&#10; *   - entity: The entity with fields to render.&#10; *   - view_mode: View mode; for example, 'full' or 'teaser'.&#10; *   - display: Either a view mode string or an array of display settings. If&#10; *     this hook is being invoked from field_attach_view(), the 'display'&#10; *     element is set to the view mode string. If this hook is being invoked&#10; *     from field_view_field(), this element is set to the $display argument&#10; *     and the view_mode element is set to '_custom'. See field_view_field()&#10; *     for more information on what its $display argument contains.&#10; *   - language: The language code used for rendering.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_view_alter(&amp;$output, $context) {&#10;  // Append RDF term mappings on displayed taxonomy links.&#10;  foreach (element_children($output) as $field_name) {&#10;    $element = &amp;$output[$field_name];&#10;    if ($element['#field_type'] == 'taxonomy_term_reference' &amp;&amp; $element['#formatter'] == 'taxonomy_term_reference_link') {&#10;      foreach ($element['#items'] as $delta =&gt; $item) {&#10;        $term = $item['taxonomy_term'];&#10;        if (!empty($term-&gt;rdf_mapping['rdftype'])) {&#10;          $element[$delta]['#options']['attributes']['typeof'] = $term-&gt;rdf_mapping['rdftype'];&#10;        }&#10;        if (!empty($term-&gt;rdf_mapping['name']['predicates'])) {&#10;          $element[$delta]['#options']['attributes']['property'] = $term-&gt;rdf_mapping['name']['predicates'];&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_view_alter" value="/**&#10; * Implements hook_field_attach_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_view_alter(&amp;$output, $context) {&#10;  // Append RDF term mappings on displayed taxonomy links.&#10;  foreach (element_children($output) as $field_name) {&#10;    $element = &amp;$output[$field_name];&#10;    if ($element['#field_type'] == 'taxonomy_term_reference' &amp;&amp; $element['#formatter'] == 'taxonomy_term_reference_link') {&#10;      foreach ($element['#items'] as $delta =&gt; $item) {&#10;        $term = $item['taxonomy_term'];&#10;        if (!empty($term-&gt;rdf_mapping['rdftype'])) {&#10;          $element[$delta]['#options']['attributes']['typeof'] = $term-&gt;rdf_mapping['rdftype'];&#10;        }&#10;        if (!empty($term-&gt;rdf_mapping['name']['predicates'])) {&#10;          $element[$delta]['#options']['attributes']['property'] = $term-&gt;rdf_mapping['name']['predicates'];&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_prepare_translation_alter" value="/**&#10; * Implements hook_field_attach_prepare_translation_alter().&#10; *&#10; * Perform alterations on field_attach_prepare_translation().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * @param $entity&#10; *   The entity being prepared for translation.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The type of $entity; e.g. 'node' or 'user'.&#10; *   - langcode: The language the entity has to be translated in.&#10; *   - source_entity: The entity holding the field values to be translated.&#10; *   - source_langcode: The source language from which translate.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_prepare_translation_alter(&amp;$entity, $context) {&#10;  if ($context['entity_type'] == 'custom_entity_type') {&#10;    $entity-&gt;custom_field = $context['source_entity']-&gt;custom_field;&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_prepare_translation_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_prepare_translation_alter" value="/**&#10; * Implements hook_field_attach_prepare_translation_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_prepare_translation_alter(&amp;$entity, $context) {&#10;  if ($context['entity_type'] == 'custom_entity_type') {&#10;    $entity-&gt;custom_field = $context['source_entity']-&gt;custom_field;&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_prepare_translation_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_language_alter" value="/**&#10; * Implements hook_field_language_alter().&#10; *&#10; * Perform alterations on field_language() values.&#10; *&#10; * This hook is invoked to alter the array of display languages for the given&#10; * entity.&#10; *&#10; * @param $display_language&#10; *   A reference to an array of language codes keyed by field name.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The type of the entity to be displayed.&#10; *   - entity: The entity with fields to render.&#10; *   - langcode: The language code $entity has to be displayed in.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_language_alter(&amp;$display_language, $context) {&#10;  // Do not apply core language fallback rules if they are disabled or if Locale&#10;  // is not registered as a translation handler.&#10;  if (variable_get('locale_field_language_fallback', TRUE) &amp;&amp; field_has_translation_handler($context['entity_type'], 'locale')) {&#10;    locale_field_language_fallback($display_language, $context['entity'], $context['language']);&#10;  }&#10;  $END$&#10;}" description="hook_field_language_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_language_alter" value="/**&#10; * Implements hook_field_language_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_language_alter(&amp;$display_language, $context) {&#10;  // Do not apply core language fallback rules if they are disabled or if Locale&#10;  // is not registered as a translation handler.&#10;  if (variable_get('locale_field_language_fallback', TRUE) &amp;&amp; field_has_translation_handler($context['entity_type'], 'locale')) {&#10;    locale_field_language_fallback($display_language, $context['entity'], $context['language']);&#10;  }&#10;  $END$&#10;}" description="hook_field_language_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_available_languages_alter" value="/**&#10; * Implements hook_field_available_languages_alter().&#10; *&#10; * Alter field_available_languages() values.&#10; *&#10; * This hook is invoked from field_available_languages() to allow modules to&#10; * alter the array of available languages for the given field.&#10; *&#10; * @param $languages&#10; *   A reference to an array of language codes to be made available.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The type of the entity the field is attached to.&#10; *   - field: A field data structure.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_available_languages_alter(&amp;$languages, $context) {&#10;  // Add an unavailable language.&#10;  $languages[] = 'xx';&#10;&#10;  // Remove an available language.&#10;  $index = array_search('yy', $languages);&#10;  unset($languages[$index]);&#10;  $END$&#10;}" description="hook_field_available_languages_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_available_languages_alter" value="/**&#10; * Implements hook_field_available_languages_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_available_languages_alter(&amp;$languages, $context) {&#10;  // Add an unavailable language.&#10;  $languages[] = 'xx';&#10;&#10;  // Remove an available language.&#10;  $index = array_search('yy', $languages);&#10;  unset($languages[$index]);&#10;  $END$&#10;}" description="hook_field_available_languages_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_create_bundle" value="/**&#10; * Implements hook_field_attach_create_bundle().&#10; *&#10; * Act on field_attach_create_bundle().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_create_bundle() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_create_bundle($entity_type, $bundle) {&#10;  // When a new bundle is created, the menu needs to be rebuilt to add the&#10;  // Field UI menu item tabs.&#10;  variable_set('menu_rebuild_needed', TRUE);&#10;  $END$&#10;}" description="hook_field_attach_create_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_create_bundle" value="/**&#10; * Implements hook_field_attach_create_bundle().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_create_bundle($entity_type, $bundle) {&#10;  // When a new bundle is created, the menu needs to be rebuilt to add the&#10;  // Field UI menu item tabs.&#10;  variable_set('menu_rebuild_needed', TRUE);&#10;  $END$&#10;}" description="hook_field_attach_create_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_rename_bundle" value="/**&#10; * Implements hook_field_attach_rename_bundle().&#10; *&#10; * Act on field_attach_rename_bundle().&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * See field_attach_rename_bundle() for details and arguments.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {&#10;  // Update the extra weights variable with new information.&#10;  if ($bundle_old !== $bundle_new) {&#10;    $extra_weights = variable_get('field_extra_weights', array());&#10;    if (isset($info[$entity_type][$bundle_old])) {&#10;      $extra_weights[$entity_type][$bundle_new] = $extra_weights[$entity_type][$bundle_old];&#10;      unset($extra_weights[$entity_type][$bundle_old]);&#10;      variable_set('field_extra_weights', $extra_weights);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_rename_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_rename_bundle" value="/**&#10; * Implements hook_field_attach_rename_bundle().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {&#10;  // Update the extra weights variable with new information.&#10;  if ($bundle_old !== $bundle_new) {&#10;    $extra_weights = variable_get('field_extra_weights', array());&#10;    if (isset($info[$entity_type][$bundle_old])) {&#10;      $extra_weights[$entity_type][$bundle_new] = $extra_weights[$entity_type][$bundle_old];&#10;      unset($extra_weights[$entity_type][$bundle_old]);&#10;      variable_set('field_extra_weights', $extra_weights);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_rename_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_attach_delete_bundle" value="/**&#10; * Implements hook_field_attach_delete_bundle().&#10; *&#10; * Act on field_attach_delete_bundle.&#10; *&#10; * This hook is invoked after the field module has performed the operation.&#10; *&#10; * @param $entity_type&#10; *   The type of entity; for example, 'node' or 'user'.&#10; * @param $bundle&#10; *   The bundle that was just deleted.&#10; * @param $instances&#10; *   An array of all instances that existed for the bundle before it was&#10; *   deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete_bundle($entity_type, $bundle, $instances) {&#10;  // Remove the extra weights variable information for this bundle.&#10;  $extra_weights = variable_get('field_extra_weights', array());&#10;  if (isset($extra_weights[$entity_type][$bundle])) {&#10;    unset($extra_weights[$entity_type][$bundle]);&#10;    variable_set('field_extra_weights', $extra_weights);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_delete_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_attach_delete_bundle" value="/**&#10; * Implements hook_field_attach_delete_bundle().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_attach_delete_bundle($entity_type, $bundle, $instances) {&#10;  // Remove the extra weights variable information for this bundle.&#10;  $extra_weights = variable_get('field_extra_weights', array());&#10;  if (isset($extra_weights[$entity_type][$bundle])) {&#10;    unset($extra_weights[$entity_type][$bundle]);&#10;    variable_set('field_extra_weights', $extra_weights);&#10;  }&#10;  $END$&#10;}" description="hook_field_attach_delete_bundle" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_info" value="/**&#10; * Implements hook_field_storage_info().&#10; *&#10; * Expose Field API storage backends.&#10; *&#10; * @return&#10; *   An array describing the storage backends implemented by the module.&#10; *   The keys are storage backend names. To avoid name clashes, storage backend&#10; *   names should be prefixed with the name of the module that exposes them.&#10; *   The values are arrays describing the storage backend, with the following&#10; *   key/value pairs:&#10; *   - label: The human-readable name of the storage backend.&#10; *   - description: A short description for the storage backend.&#10; *   - settings: An array whose keys are the names of the settings available&#10; *     for the storage backend, and whose values are the default values for&#10; *     those settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_info() {&#10;  return array(&#10;    'field_sql_storage' =&gt; array(&#10;      'label' =&gt; t('Default SQL storage'),&#10;      'description' =&gt; t('Stores fields in the local SQL database, using per-field tables.'),&#10;      'settings' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_info" value="/**&#10; * Implements hook_field_storage_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_info() {&#10;  return array(&#10;    'field_sql_storage' =&gt; array(&#10;      'label' =&gt; t('Default SQL storage'),&#10;      'description' =&gt; t('Stores fields in the local SQL database, using per-field tables.'),&#10;      'settings' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_info_alter" value="/**&#10; * Implements hook_field_storage_info_alter().&#10; *&#10; * Perform alterations on Field API storage types.&#10; *&#10; * @param $info&#10; *   Array of informations on storage types exposed by&#10; *   hook_field_field_storage_info() implementations.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_info_alter(&amp;$info) {&#10;  // Add a setting to a storage type.&#10;  $info['field_sql_storage']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_info_alter" value="/**&#10; * Implements hook_field_storage_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_info_alter(&amp;$info) {&#10;  // Add a setting to a storage type.&#10;  $info['field_sql_storage']['settings'] += array(&#10;    'mymodule_additional_setting' =&gt; 'default value',&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_details" value="/**&#10; * Implements hook_field_storage_details().&#10; *&#10; * Reveal the internal details about the storage for a field.&#10; *&#10; * For example, an SQL storage module might return the Schema API structure for&#10; * the table. A key/value storage module might return the server name,&#10; * authentication credentials, and bin name.&#10; *&#10; * Field storage modules are not obligated to implement this hook. Modules&#10; * that rely on these details must only use them for read operations.&#10; *&#10; * @param $field&#10; *   A field structure.&#10; *&#10; * @return&#10; *   An array of details.&#10; *    - The first dimension is a store type (sql, solr, etc).&#10; *    - The second dimension indicates the age of the values in the store&#10; *      FIELD_LOAD_CURRENT or FIELD_LOAD_REVISION.&#10; *    - Other dimensions are specific to the field storage module.&#10; *&#10; * @see hook_field_storage_details_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_details($field) {&#10;  $details = array();&#10;&#10;  // Add field columns.&#10;  foreach ((array) $field['columns'] as $column_name =&gt; $attributes) {&#10;    $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);&#10;    $columns[$column_name] = $real_name;&#10;  }&#10;  return array(&#10;    'sql' =&gt; array(&#10;      FIELD_LOAD_CURRENT =&gt; array(&#10;        _field_sql_storage_tablename($field) =&gt; $columns,&#10;      ),&#10;      FIELD_LOAD_REVISION =&gt; array(&#10;        _field_sql_storage_revision_tablename($field) =&gt; $columns,&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_details" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_details" value="/**&#10; * Implements hook_field_storage_details().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_details($field) {&#10;  $details = array();&#10;&#10;  // Add field columns.&#10;  foreach ((array) $field['columns'] as $column_name =&gt; $attributes) {&#10;    $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);&#10;    $columns[$column_name] = $real_name;&#10;  }&#10;  return array(&#10;    'sql' =&gt; array(&#10;      FIELD_LOAD_CURRENT =&gt; array(&#10;        _field_sql_storage_tablename($field) =&gt; $columns,&#10;      ),&#10;      FIELD_LOAD_REVISION =&gt; array(&#10;        _field_sql_storage_revision_tablename($field) =&gt; $columns,&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_field_storage_details" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_details_alter" value="/**&#10; * Implements hook_field_storage_details_alter().&#10; *&#10; * Perform alterations on Field API storage details.&#10; *&#10; * @param $details&#10; *   An array of storage details for fields as exposed by&#10; *   hook_field_storage_details() implementations.&#10; * @param $field&#10; *   A field structure.&#10; *&#10; * @see hook_field_storage_details()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_details_alter(&amp;$details, $field) {&#10;  if ($field['field_name'] == 'field_of_interest') {&#10;    $columns = array();&#10;    foreach ((array) $field['columns'] as $column_name =&gt; $attributes) {&#10;      $columns[$column_name] = $column_name;&#10;    }&#10;    $details['drupal_variables'] = array(&#10;      FIELD_LOAD_CURRENT =&gt; array(&#10;        'moon' =&gt; $columns,&#10;      ),&#10;      FIELD_LOAD_REVISION =&gt; array(&#10;        'mars' =&gt; $columns,&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_details_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_details_alter" value="/**&#10; * Implements hook_field_storage_details_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_details_alter(&amp;$details, $field) {&#10;  if ($field['field_name'] == 'field_of_interest') {&#10;    $columns = array();&#10;    foreach ((array) $field['columns'] as $column_name =&gt; $attributes) {&#10;      $columns[$column_name] = $column_name;&#10;    }&#10;    $details['drupal_variables'] = array(&#10;      FIELD_LOAD_CURRENT =&gt; array(&#10;        'moon' =&gt; $columns,&#10;      ),&#10;      FIELD_LOAD_REVISION =&gt; array(&#10;        'mars' =&gt; $columns,&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_details_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_load" value="/**&#10; * Implements hook_field_storage_load().&#10; *&#10; * Load field data for a set of entities.&#10; *&#10; * This hook is invoked from field_attach_load() to ask the field storage&#10; * module to load field data.&#10; *&#10; * Modules implementing this hook should load field values and add them to&#10; * objects in $entities. Fields with no values should be added as empty&#10; * arrays.&#10; *&#10; * @param $entity_type&#10; *   The type of entity, such as 'node' or 'user'.&#10; * @param $entities&#10; *   The array of entity objects to add fields to, keyed by entity ID.&#10; * @param $age&#10; *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or&#10; *   FIELD_LOAD_REVISION to load the version indicated by each entity.&#10; * @param $fields&#10; *   An array listing the fields to be loaded. The keys of the array are field&#10; *   IDs, and the values of the array are the entity IDs (or revision IDs,&#10; *   depending on the $age parameter) to add each field to.&#10; * @param $options&#10; *   An associative array of additional options, with the following keys:&#10; *   - deleted: If TRUE, deleted fields should be loaded as well as&#10; *     non-deleted fields. If unset or FALSE, only non-deleted fields should be&#10; *     loaded.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_load($entity_type, $entities, $age, $fields, $options) {&#10;  $field_info = field_info_field_by_ids();&#10;  $load_current = $age == FIELD_LOAD_CURRENT;&#10;&#10;  foreach ($fields as $field_id =&gt; $ids) {&#10;    $field = $field_info[$field_id];&#10;    $field_name = $field['field_name'];&#10;    $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);&#10;&#10;    $query = db_select($table, 't')&#10;      -&gt;fields('t')&#10;      -&gt;condition('entity_type', $entity_type)&#10;      -&gt;condition($load_current ? 'entity_id' : 'revision_id', $ids, 'IN')&#10;      -&gt;condition('language', field_available_languages($entity_type, $field), 'IN')&#10;      -&gt;orderBy('delta');&#10;&#10;    if (empty($options['deleted'])) {&#10;      $query-&gt;condition('deleted', 0);&#10;    }&#10;&#10;    $results = $query-&gt;execute();&#10;&#10;    $delta_count = array();&#10;    foreach ($results as $row) {&#10;      if (!isset($delta_count[$row-&gt;entity_id][$row-&gt;language])) {&#10;        $delta_count[$row-&gt;entity_id][$row-&gt;language] = 0;&#10;      }&#10;&#10;      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta_count[$row-&gt;entity_id][$row-&gt;language] &lt; $field['cardinality']) {&#10;        $item = array();&#10;        // For each column declared by the field, populate the item&#10;        // from the prefixed database column.&#10;        foreach ($field['columns'] as $column =&gt; $attributes) {&#10;          $column_name = _field_sql_storage_columnname($field_name, $column);&#10;          $item[$column] = $row-&gt;$column_name;&#10;        }&#10;&#10;        // Add the item to the field values for the entity.&#10;        $entities[$row-&gt;entity_id]-&gt;{$field_name}[$row-&gt;language][] = $item;&#10;        $delta_count[$row-&gt;entity_id][$row-&gt;language]++;&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_load" value="/**&#10; * Implements hook_field_storage_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_load($entity_type, $entities, $age, $fields, $options) {&#10;  $field_info = field_info_field_by_ids();&#10;  $load_current = $age == FIELD_LOAD_CURRENT;&#10;&#10;  foreach ($fields as $field_id =&gt; $ids) {&#10;    $field = $field_info[$field_id];&#10;    $field_name = $field['field_name'];&#10;    $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);&#10;&#10;    $query = db_select($table, 't')&#10;      -&gt;fields('t')&#10;      -&gt;condition('entity_type', $entity_type)&#10;      -&gt;condition($load_current ? 'entity_id' : 'revision_id', $ids, 'IN')&#10;      -&gt;condition('language', field_available_languages($entity_type, $field), 'IN')&#10;      -&gt;orderBy('delta');&#10;&#10;    if (empty($options['deleted'])) {&#10;      $query-&gt;condition('deleted', 0);&#10;    }&#10;&#10;    $results = $query-&gt;execute();&#10;&#10;    $delta_count = array();&#10;    foreach ($results as $row) {&#10;      if (!isset($delta_count[$row-&gt;entity_id][$row-&gt;language])) {&#10;        $delta_count[$row-&gt;entity_id][$row-&gt;language] = 0;&#10;      }&#10;&#10;      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta_count[$row-&gt;entity_id][$row-&gt;language] &lt; $field['cardinality']) {&#10;        $item = array();&#10;        // For each column declared by the field, populate the item&#10;        // from the prefixed database column.&#10;        foreach ($field['columns'] as $column =&gt; $attributes) {&#10;          $column_name = _field_sql_storage_columnname($field_name, $column);&#10;          $item[$column] = $row-&gt;$column_name;&#10;        }&#10;&#10;        // Add the item to the field values for the entity.&#10;        $entities[$row-&gt;entity_id]-&gt;{$field_name}[$row-&gt;language][] = $item;&#10;        $delta_count[$row-&gt;entity_id][$row-&gt;language]++;&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_write" value="/**&#10; * Implements hook_field_storage_write().&#10; *&#10; * Write field data for an entity.&#10; *&#10; * This hook is invoked from field_attach_insert() and field_attach_update(),&#10; * to ask the field storage module to save field data.&#10; *&#10; * @param $entity_type&#10; *   The entity type of entity, such as 'node' or 'user'.&#10; * @param $entity&#10; *   The entity on which to operate.&#10; * @param $op&#10; *   FIELD_STORAGE_UPDATE when updating an existing entity,&#10; *   FIELD_STORAGE_INSERT when inserting a new entity.&#10; * @param $fields&#10; *   An array listing the fields to be written. The keys and values of the&#10; *   array are field IDs.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_write($entity_type, $entity, $op, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;  if (!isset($vid)) {&#10;    $vid = $id;&#10;  }&#10;&#10;  foreach ($fields as $field_id) {&#10;    $field = field_info_field_by_id($field_id);&#10;    $field_name = $field['field_name'];&#10;    $table_name = _field_sql_storage_tablename($field);&#10;    $revision_name = _field_sql_storage_revision_tablename($field);&#10;&#10;    $all_languages = field_available_languages($entity_type, $field);&#10;    $field_languages = array_intersect($all_languages, array_keys((array) $entity-&gt;$field_name));&#10;&#10;    // Delete and insert, rather than update, in case a value was added.&#10;    if ($op == FIELD_STORAGE_UPDATE) {&#10;      // Delete languages present in the incoming $entity-&gt;$field_name.&#10;      // Delete all languages if $entity-&gt;$field_name is empty.&#10;      $languages = !empty($entity-&gt;$field_name) ? $field_languages : $all_languages;&#10;      if ($languages) {&#10;        db_delete($table_name)&#10;          -&gt;condition('entity_type', $entity_type)&#10;          -&gt;condition('entity_id', $id)&#10;          -&gt;condition('language', $languages, 'IN')&#10;          -&gt;execute();&#10;        db_delete($revision_name)&#10;          -&gt;condition('entity_type', $entity_type)&#10;          -&gt;condition('entity_id', $id)&#10;          -&gt;condition('revision_id', $vid)&#10;          -&gt;condition('language', $languages, 'IN')&#10;          -&gt;execute();&#10;      }&#10;    }&#10;&#10;    // Prepare the multi-insert query.&#10;    $do_insert = FALSE;&#10;    $columns = array('entity_type', 'entity_id', 'revision_id', 'bundle', 'delta', 'language');&#10;    foreach ($field['columns'] as $column =&gt; $attributes) {&#10;      $columns[] = _field_sql_storage_columnname($field_name, $column);&#10;    }&#10;    $query = db_insert($table_name)-&gt;fields($columns);&#10;    $revision_query = db_insert($revision_name)-&gt;fields($columns);&#10;&#10;    foreach ($field_languages as $langcode) {&#10;      $items = (array) $entity-&gt;{$field_name}[$langcode];&#10;      $delta_count = 0;&#10;      foreach ($items as $delta =&gt; $item) {&#10;        // We now know we have someting to insert.&#10;        $do_insert = TRUE;&#10;        $record = array(&#10;          'entity_type' =&gt; $entity_type,&#10;          'entity_id' =&gt; $id,&#10;          'revision_id' =&gt; $vid,&#10;          'bundle' =&gt; $bundle,&#10;          'delta' =&gt; $delta,&#10;          'language' =&gt; $langcode,&#10;        );&#10;        foreach ($field['columns'] as $column =&gt; $attributes) {&#10;          $record[_field_sql_storage_columnname($field_name, $column)] = isset($item[$column]) ? $item[$column] : NULL;&#10;        }&#10;        $query-&gt;values($record);&#10;        if (isset($vid)) {&#10;          $revision_query-&gt;values($record);&#10;        }&#10;&#10;        if ($field['cardinality'] != FIELD_CARDINALITY_UNLIMITED &amp;&amp; ++$delta_count == $field['cardinality']) {&#10;          break;&#10;        }&#10;      }&#10;    }&#10;&#10;    // Execute the query if we have values to insert.&#10;    if ($do_insert) {&#10;      $query-&gt;execute();&#10;      $revision_query-&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_write" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_write" value="/**&#10; * Implements hook_field_storage_write().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_write($entity_type, $entity, $op, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;  if (!isset($vid)) {&#10;    $vid = $id;&#10;  }&#10;&#10;  foreach ($fields as $field_id) {&#10;    $field = field_info_field_by_id($field_id);&#10;    $field_name = $field['field_name'];&#10;    $table_name = _field_sql_storage_tablename($field);&#10;    $revision_name = _field_sql_storage_revision_tablename($field);&#10;&#10;    $all_languages = field_available_languages($entity_type, $field);&#10;    $field_languages = array_intersect($all_languages, array_keys((array) $entity-&gt;$field_name));&#10;&#10;    // Delete and insert, rather than update, in case a value was added.&#10;    if ($op == FIELD_STORAGE_UPDATE) {&#10;      // Delete languages present in the incoming $entity-&gt;$field_name.&#10;      // Delete all languages if $entity-&gt;$field_name is empty.&#10;      $languages = !empty($entity-&gt;$field_name) ? $field_languages : $all_languages;&#10;      if ($languages) {&#10;        db_delete($table_name)&#10;          -&gt;condition('entity_type', $entity_type)&#10;          -&gt;condition('entity_id', $id)&#10;          -&gt;condition('language', $languages, 'IN')&#10;          -&gt;execute();&#10;        db_delete($revision_name)&#10;          -&gt;condition('entity_type', $entity_type)&#10;          -&gt;condition('entity_id', $id)&#10;          -&gt;condition('revision_id', $vid)&#10;          -&gt;condition('language', $languages, 'IN')&#10;          -&gt;execute();&#10;      }&#10;    }&#10;&#10;    // Prepare the multi-insert query.&#10;    $do_insert = FALSE;&#10;    $columns = array('entity_type', 'entity_id', 'revision_id', 'bundle', 'delta', 'language');&#10;    foreach ($field['columns'] as $column =&gt; $attributes) {&#10;      $columns[] = _field_sql_storage_columnname($field_name, $column);&#10;    }&#10;    $query = db_insert($table_name)-&gt;fields($columns);&#10;    $revision_query = db_insert($revision_name)-&gt;fields($columns);&#10;&#10;    foreach ($field_languages as $langcode) {&#10;      $items = (array) $entity-&gt;{$field_name}[$langcode];&#10;      $delta_count = 0;&#10;      foreach ($items as $delta =&gt; $item) {&#10;        // We now know we have someting to insert.&#10;        $do_insert = TRUE;&#10;        $record = array(&#10;          'entity_type' =&gt; $entity_type,&#10;          'entity_id' =&gt; $id,&#10;          'revision_id' =&gt; $vid,&#10;          'bundle' =&gt; $bundle,&#10;          'delta' =&gt; $delta,&#10;          'language' =&gt; $langcode,&#10;        );&#10;        foreach ($field['columns'] as $column =&gt; $attributes) {&#10;          $record[_field_sql_storage_columnname($field_name, $column)] = isset($item[$column]) ? $item[$column] : NULL;&#10;        }&#10;        $query-&gt;values($record);&#10;        if (isset($vid)) {&#10;          $revision_query-&gt;values($record);&#10;        }&#10;&#10;        if ($field['cardinality'] != FIELD_CARDINALITY_UNLIMITED &amp;&amp; ++$delta_count == $field['cardinality']) {&#10;          break;&#10;        }&#10;      }&#10;    }&#10;&#10;    // Execute the query if we have values to insert.&#10;    if ($do_insert) {&#10;      $query-&gt;execute();&#10;      $revision_query-&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_write" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_delete" value="/**&#10; * Implements hook_field_storage_delete().&#10; *&#10; * Delete all field data for an entity.&#10; *&#10; * This hook is invoked from field_attach_delete() to ask the field storage&#10; * module to delete field data.&#10; *&#10; * @param $entity_type&#10; *   The entity type of entity, such as 'node' or 'user'.&#10; * @param $entity&#10; *   The entity on which to operate.&#10; * @param $fields&#10; *   An array listing the fields to delete. The keys and values of the&#10; *   array are field IDs.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete($entity_type, $entity, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  foreach (field_info_instances($entity_type, $bundle) as $instance) {&#10;    if (isset($fields[$instance['field_id']])) {&#10;      $field = field_info_field_by_id($instance['field_id']);&#10;      field_sql_storage_field_storage_purge($entity_type, $entity, $field, $instance);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_delete" value="/**&#10; * Implements hook_field_storage_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete($entity_type, $entity, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  foreach (field_info_instances($entity_type, $bundle) as $instance) {&#10;    if (isset($fields[$instance['field_id']])) {&#10;      $field = field_info_field_by_id($instance['field_id']);&#10;      field_sql_storage_field_storage_purge($entity_type, $entity, $field, $instance);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_delete_revision" value="/**&#10; * Implements hook_field_storage_delete_revision().&#10; *&#10; * Delete a single revision of field data for an entity.&#10; *&#10; * This hook is invoked from field_attach_delete_revision() to ask the field&#10; * storage module to delete field revision data.&#10; *&#10; * Deleting the current (most recently written) revision is not&#10; * allowed as has undefined results.&#10; *&#10; * @param $entity_type&#10; *   The entity type of entity, such as 'node' or 'user'.&#10; * @param $entity&#10; *   The entity on which to operate. The revision to delete is&#10; *   indicated by the entity's revision ID property, as identified by&#10; *   hook_fieldable_info() for $entity_type.&#10; * @param $fields&#10; *   An array listing the fields to delete. The keys and values of the&#10; *   array are field IDs.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_revision($entity_type, $entity, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  if (isset($vid)) {&#10;    foreach ($fields as $field_id) {&#10;      $field = field_info_field_by_id($field_id);&#10;      $revision_name = _field_sql_storage_revision_tablename($field);&#10;      db_delete($revision_name)&#10;        -&gt;condition('entity_type', $entity_type)&#10;        -&gt;condition('entity_id', $id)&#10;        -&gt;condition('revision_id', $vid)&#10;        -&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_delete_revision" value="/**&#10; * Implements hook_field_storage_delete_revision().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_revision($entity_type, $entity, $fields) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  if (isset($vid)) {&#10;    foreach ($fields as $field_id) {&#10;      $field = field_info_field_by_id($field_id);&#10;      $revision_name = _field_sql_storage_revision_tablename($field);&#10;      db_delete($revision_name)&#10;        -&gt;condition('entity_type', $entity_type)&#10;        -&gt;condition('entity_id', $id)&#10;        -&gt;condition('revision_id', $vid)&#10;        -&gt;execute();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_delete_revision" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_query" value="/**&#10; * Implements hook_field_storage_query().&#10; *&#10; * Execute an EntityFieldQuery.&#10; *&#10; * This hook is called to find the entities having certain entity and field&#10; * conditions and sort them in the given field order. If the field storage&#10; * engine also handles property sorts and orders, it should unset those&#10; * properties in the called object to signal that those have been handled.&#10; *&#10; * @param EntityFieldQuery $query&#10; *   An EntityFieldQuery.&#10; *&#10; * @return&#10; *   See EntityFieldQuery::execute() for the return values.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_query($query) {&#10;  $groups = array();&#10;  if ($query-&gt;age == FIELD_LOAD_CURRENT) {&#10;    $tablename_function = '_field_sql_storage_tablename';&#10;    $id_key = 'entity_id';&#10;  }&#10;  else {&#10;    $tablename_function = '_field_sql_storage_revision_tablename';&#10;    $id_key = 'revision_id';&#10;  }&#10;  $table_aliases = array();&#10;  // Add tables for the fields used.&#10;  foreach ($query-&gt;fields as $key =&gt; $field) {&#10;    $tablename = $tablename_function($field);&#10;    // Every field needs a new table.&#10;    $table_alias = $tablename . $key;&#10;    $table_aliases[$key] = $table_alias;&#10;    if ($key) {&#10;      $select_query-&gt;join($tablename, $table_alias, &quot;$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key&quot;);&#10;    }&#10;    else {&#10;      $select_query = db_select($tablename, $table_alias);&#10;      $select_query-&gt;addTag('entity_field_access');&#10;      $select_query-&gt;addMetaData('base_table', $tablename);&#10;      $select_query-&gt;fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));&#10;      $field_base_table = $table_alias;&#10;    }&#10;    if ($field['cardinality'] != 1) {&#10;      $select_query-&gt;distinct();&#10;    }&#10;  }&#10;&#10;  // Add field conditions.&#10;  foreach ($query-&gt;fieldConditions as $key =&gt; $condition) {&#10;    $table_alias = $table_aliases[$key];&#10;    $field = $condition['field'];&#10;    // Add the specified condition.&#10;    $sql_field = &quot;$table_alias.&quot; . _field_sql_storage_columnname($field['field_name'], $condition['column']);&#10;    $query-&gt;addCondition($select_query, $sql_field, $condition);&#10;    // Add delta / language group conditions.&#10;    foreach (array('delta', 'language') as $column) {&#10;      if (isset($condition[$column . '_group'])) {&#10;        $group_name = $condition[$column . '_group'];&#10;        if (!isset($groups[$column][$group_name])) {&#10;          $groups[$column][$group_name] = $table_alias;&#10;        }&#10;        else {&#10;          $select_query-&gt;where(&quot;$table_alias.$column = &quot; . $groups[$column][$group_name] . &quot;.$column&quot;);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  if (isset($query-&gt;deleted)) {&#10;    $select_query-&gt;condition(&quot;$field_base_table.deleted&quot;, (int) $query-&gt;deleted);&#10;  }&#10;&#10;  // Is there a need to sort the query by property?&#10;  $has_property_order = FALSE;&#10;  foreach ($query-&gt;order as $order) {&#10;    if ($order['type'] == 'property') {&#10;      $has_property_order = TRUE;&#10;    }&#10;  }&#10;&#10;  if ($query-&gt;propertyConditions || $has_property_order) {&#10;    if (empty($query-&gt;entityConditions['entity_type']['value'])) {&#10;      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');&#10;    }&#10;    $entity_type = $query-&gt;entityConditions['entity_type']['value'];&#10;    $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);&#10;    $query-&gt;entityConditions['entity_type']['operator'] = '=';&#10;    foreach ($query-&gt;propertyConditions as $property_condition) {&#10;      $query-&gt;addCondition($select_query, &quot;$entity_base_table.&quot; . $property_condition['column'], $property_condition);&#10;    }&#10;  }&#10;  foreach ($query-&gt;entityConditions as $key =&gt; $condition) {&#10;    $query-&gt;addCondition($select_query, &quot;$field_base_table.$key&quot;, $condition);&#10;  }&#10;&#10;  // Order the query.&#10;  foreach ($query-&gt;order as $order) {&#10;    if ($order['type'] == 'entity') {&#10;      $key = $order['specifier'];&#10;      $select_query-&gt;orderBy(&quot;$field_base_table.$key&quot;, $order['direction']);&#10;    }&#10;    elseif ($order['type'] == 'field') {&#10;      $specifier = $order['specifier'];&#10;      $field = $specifier['field'];&#10;      $table_alias = $table_aliases[$specifier['index']];&#10;      $sql_field = &quot;$table_alias.&quot; . _field_sql_storage_columnname($field['field_name'], $specifier['column']);&#10;      $select_query-&gt;orderBy($sql_field, $order['direction']);&#10;    }&#10;    elseif ($order['type'] == 'property') {&#10;      $select_query-&gt;orderBy(&quot;$entity_base_table.&quot; . $order['specifier'], $order['direction']);&#10;    }&#10;  }&#10;&#10;  return $query-&gt;finishQuery($select_query, $id_key);&#10;  $END$&#10;}" description="hook_field_storage_query" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_query" value="/**&#10; * Implements hook_field_storage_query().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_query($query) {&#10;  $groups = array();&#10;  if ($query-&gt;age == FIELD_LOAD_CURRENT) {&#10;    $tablename_function = '_field_sql_storage_tablename';&#10;    $id_key = 'entity_id';&#10;  }&#10;  else {&#10;    $tablename_function = '_field_sql_storage_revision_tablename';&#10;    $id_key = 'revision_id';&#10;  }&#10;  $table_aliases = array();&#10;  // Add tables for the fields used.&#10;  foreach ($query-&gt;fields as $key =&gt; $field) {&#10;    $tablename = $tablename_function($field);&#10;    // Every field needs a new table.&#10;    $table_alias = $tablename . $key;&#10;    $table_aliases[$key] = $table_alias;&#10;    if ($key) {&#10;      $select_query-&gt;join($tablename, $table_alias, &quot;$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key&quot;);&#10;    }&#10;    else {&#10;      $select_query = db_select($tablename, $table_alias);&#10;      $select_query-&gt;addTag('entity_field_access');&#10;      $select_query-&gt;addMetaData('base_table', $tablename);&#10;      $select_query-&gt;fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));&#10;      $field_base_table = $table_alias;&#10;    }&#10;    if ($field['cardinality'] != 1) {&#10;      $select_query-&gt;distinct();&#10;    }&#10;  }&#10;&#10;  // Add field conditions.&#10;  foreach ($query-&gt;fieldConditions as $key =&gt; $condition) {&#10;    $table_alias = $table_aliases[$key];&#10;    $field = $condition['field'];&#10;    // Add the specified condition.&#10;    $sql_field = &quot;$table_alias.&quot; . _field_sql_storage_columnname($field['field_name'], $condition['column']);&#10;    $query-&gt;addCondition($select_query, $sql_field, $condition);&#10;    // Add delta / language group conditions.&#10;    foreach (array('delta', 'language') as $column) {&#10;      if (isset($condition[$column . '_group'])) {&#10;        $group_name = $condition[$column . '_group'];&#10;        if (!isset($groups[$column][$group_name])) {&#10;          $groups[$column][$group_name] = $table_alias;&#10;        }&#10;        else {&#10;          $select_query-&gt;where(&quot;$table_alias.$column = &quot; . $groups[$column][$group_name] . &quot;.$column&quot;);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  if (isset($query-&gt;deleted)) {&#10;    $select_query-&gt;condition(&quot;$field_base_table.deleted&quot;, (int) $query-&gt;deleted);&#10;  }&#10;&#10;  // Is there a need to sort the query by property?&#10;  $has_property_order = FALSE;&#10;  foreach ($query-&gt;order as $order) {&#10;    if ($order['type'] == 'property') {&#10;      $has_property_order = TRUE;&#10;    }&#10;  }&#10;&#10;  if ($query-&gt;propertyConditions || $has_property_order) {&#10;    if (empty($query-&gt;entityConditions['entity_type']['value'])) {&#10;      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');&#10;    }&#10;    $entity_type = $query-&gt;entityConditions['entity_type']['value'];&#10;    $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);&#10;    $query-&gt;entityConditions['entity_type']['operator'] = '=';&#10;    foreach ($query-&gt;propertyConditions as $property_condition) {&#10;      $query-&gt;addCondition($select_query, &quot;$entity_base_table.&quot; . $property_condition['column'], $property_condition);&#10;    }&#10;  }&#10;  foreach ($query-&gt;entityConditions as $key =&gt; $condition) {&#10;    $query-&gt;addCondition($select_query, &quot;$field_base_table.$key&quot;, $condition);&#10;  }&#10;&#10;  // Order the query.&#10;  foreach ($query-&gt;order as $order) {&#10;    if ($order['type'] == 'entity') {&#10;      $key = $order['specifier'];&#10;      $select_query-&gt;orderBy(&quot;$field_base_table.$key&quot;, $order['direction']);&#10;    }&#10;    elseif ($order['type'] == 'field') {&#10;      $specifier = $order['specifier'];&#10;      $field = $specifier['field'];&#10;      $table_alias = $table_aliases[$specifier['index']];&#10;      $sql_field = &quot;$table_alias.&quot; . _field_sql_storage_columnname($field['field_name'], $specifier['column']);&#10;      $select_query-&gt;orderBy($sql_field, $order['direction']);&#10;    }&#10;    elseif ($order['type'] == 'property') {&#10;      $select_query-&gt;orderBy(&quot;$entity_base_table.&quot; . $order['specifier'], $order['direction']);&#10;    }&#10;  }&#10;&#10;  return $query-&gt;finishQuery($select_query, $id_key);&#10;  $END$&#10;}" description="hook_field_storage_query" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_create_field" value="/**&#10; * Implements hook_field_storage_create_field().&#10; *&#10; * Act on creation of a new field.&#10; *&#10; * This hook is invoked from field_create_field() to ask the field storage&#10; * module to save field information and prepare for storing field instances.&#10; * If there is a problem, the field storage module should throw an exception.&#10; *&#10; * @param $field&#10; *   The field structure being created.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_create_field($field) {&#10;  $schema = _field_sql_storage_schema($field);&#10;  foreach ($schema as $name =&gt; $table) {&#10;    db_create_table($name, $table);&#10;  }&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_create_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_create_field" value="/**&#10; * Implements hook_field_storage_create_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_create_field($field) {&#10;  $schema = _field_sql_storage_schema($field);&#10;  foreach ($schema as $name =&gt; $table) {&#10;    db_create_table($name, $table);&#10;  }&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_create_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_delete_field" value="/**&#10; * Implements hook_field_storage_delete_field().&#10; *&#10; * Act on deletion of a field.&#10; *&#10; * This hook is invoked from field_delete_field() to ask the field storage&#10; * module to mark all information stored in the field for deletion.&#10; *&#10; * @param $field&#10; *   The field being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_field($field) {&#10;  // Mark all data associated with the field for deletion.&#10;  $field['deleted'] = 0;&#10;  $table = _field_sql_storage_tablename($field);&#10;  $revision_table = _field_sql_storage_revision_tablename($field);&#10;  db_update($table)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;execute();&#10;&#10;  // Move the table to a unique name while the table contents are being deleted.&#10;  $field['deleted'] = 1;&#10;  $new_table = _field_sql_storage_tablename($field);&#10;  $revision_new_table = _field_sql_storage_revision_tablename($field);&#10;  db_rename_table($table, $new_table);&#10;  db_rename_table($revision_table, $revision_new_table);&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_delete_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_delete_field" value="/**&#10; * Implements hook_field_storage_delete_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_field($field) {&#10;  // Mark all data associated with the field for deletion.&#10;  $field['deleted'] = 0;&#10;  $table = _field_sql_storage_tablename($field);&#10;  $revision_table = _field_sql_storage_revision_tablename($field);&#10;  db_update($table)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;execute();&#10;&#10;  // Move the table to a unique name while the table contents are being deleted.&#10;  $field['deleted'] = 1;&#10;  $new_table = _field_sql_storage_tablename($field);&#10;  $revision_new_table = _field_sql_storage_revision_tablename($field);&#10;  db_rename_table($table, $new_table);&#10;  db_rename_table($revision_table, $revision_new_table);&#10;  drupal_get_schema(NULL, TRUE);&#10;  $END$&#10;}" description="hook_field_storage_delete_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_delete_instance" value="/**&#10; * Implements hook_field_storage_delete_instance().&#10; *&#10; * Act on deletion of a field instance.&#10; *&#10; * This hook is invoked from field_delete_instance() to ask the field storage&#10; * module to mark all information stored for the field instance for deletion.&#10; *&#10; * @param $instance&#10; *   The instance being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_instance($instance) {&#10;  $field = field_info_field($instance['field_name']);&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_update($table_name)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;condition('entity_type', $instance['entity_type'])&#10;    -&gt;condition('bundle', $instance['bundle'])&#10;    -&gt;execute();&#10;  db_update($revision_name)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;condition('entity_type', $instance['entity_type'])&#10;    -&gt;condition('bundle', $instance['bundle'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_delete_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_delete_instance" value="/**&#10; * Implements hook_field_storage_delete_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_delete_instance($instance) {&#10;  $field = field_info_field($instance['field_name']);&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_update($table_name)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;condition('entity_type', $instance['entity_type'])&#10;    -&gt;condition('bundle', $instance['bundle'])&#10;    -&gt;execute();&#10;  db_update($revision_name)&#10;    -&gt;fields(array('deleted' =&gt; 1))&#10;    -&gt;condition('entity_type', $instance['entity_type'])&#10;    -&gt;condition('bundle', $instance['bundle'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_delete_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_pre_load" value="/**&#10; * Implements hook_field_storage_pre_load().&#10; *&#10; * Act before the storage backends load field data.&#10; *&#10; * This hook allows modules to load data before the Field Storage API,&#10; * optionally preventing the field storage module from doing so.&#10; *&#10; * This lets 3rd party modules override, mirror, shard, or otherwise store a&#10; * subset of fields in a different way than the current storage engine.&#10; * Possible use cases include per-bundle storage, per-combo-field storage, etc.&#10; *&#10; * Modules implementing this hook should load field values and add them to&#10; * objects in $entities. Fields with no values should be added as empty&#10; * arrays. In addition, fields loaded should be added as keys to $skip_fields.&#10; *&#10; * @param $entity_type&#10; *   The type of entity, such as 'node' or 'user'.&#10; * @param $entities&#10; *   The array of entity objects to add fields to, keyed by entity ID.&#10; * @param $age&#10; *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or&#10; *   FIELD_LOAD_REVISION to load the version indicated by each entity.&#10; * @param $skip_fields&#10; *   An array keyed by field IDs whose data has already been loaded and&#10; *   therefore should not be loaded again. Add a key to this array to indicate&#10; *   that your module has already loaded a field.&#10; * @param $options&#10; *   An associative array of additional options, with the following keys:&#10; *   - field_id: The field ID that should be loaded. If unset, all fields&#10; *     should be loaded.&#10; *   - deleted: If TRUE, deleted fields should be loaded as well as&#10; *     non-deleted fields. If unset or FALSE, only non-deleted fields should be&#10; *     loaded.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_load($entity_type, $entities, $age, &amp;$skip_fields, $options) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_storage_pre_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_pre_load" value="/**&#10; * Implements hook_field_storage_pre_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_load($entity_type, $entities, $age, &amp;$skip_fields, $options) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_storage_pre_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_pre_insert" value="/**&#10; * Implements hook_field_storage_pre_insert().&#10; *&#10; * Act before the storage backends insert field data.&#10; *&#10; * This hook allows modules to store data before the Field Storage API,&#10; * optionally preventing the field storage module from doing so.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The entity with fields to save.&#10; * @param $skip_fields&#10; *   An array keyed by field IDs whose data has already been written and&#10; *   therefore should not be written again. The values associated with these&#10; *   keys are not specified.&#10; * @return&#10; *   Saved field IDs are set set as keys in $skip_fields.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_insert($entity_type, $entity, &amp;$skip_fields) {&#10;  if ($entity_type == 'node' &amp;&amp; $entity-&gt;status &amp;&amp; _forum_node_check_node_type($entity)) {&#10;    $query = db_insert('forum_index')-&gt;fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));&#10;    foreach ($entity-&gt;taxonomy_forums as $language) {&#10;      foreach ($language as $delta) {&#10;        $query-&gt;values(array(&#10;          'nid' =&gt; $entity-&gt;nid,&#10;          'title' =&gt; $entity-&gt;title,&#10;          'tid' =&gt; $delta['value'],&#10;          'sticky' =&gt; $entity-&gt;sticky,&#10;          'created' =&gt; $entity-&gt;created,&#10;          'comment_count' =&gt; 0,&#10;          'last_comment_timestamp' =&gt; $entity-&gt;created,&#10;        ));&#10;      }&#10;    }&#10;    $query-&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_pre_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_pre_insert" value="/**&#10; * Implements hook_field_storage_pre_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_insert($entity_type, $entity, &amp;$skip_fields) {&#10;  if ($entity_type == 'node' &amp;&amp; $entity-&gt;status &amp;&amp; _forum_node_check_node_type($entity)) {&#10;    $query = db_insert('forum_index')-&gt;fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));&#10;    foreach ($entity-&gt;taxonomy_forums as $language) {&#10;      foreach ($language as $delta) {&#10;        $query-&gt;values(array(&#10;          'nid' =&gt; $entity-&gt;nid,&#10;          'title' =&gt; $entity-&gt;title,&#10;          'tid' =&gt; $delta['value'],&#10;          'sticky' =&gt; $entity-&gt;sticky,&#10;          'created' =&gt; $entity-&gt;created,&#10;          'comment_count' =&gt; 0,&#10;          'last_comment_timestamp' =&gt; $entity-&gt;created,&#10;        ));&#10;      }&#10;    }&#10;    $query-&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_pre_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_pre_update" value="/**&#10; * Implements hook_field_storage_pre_update().&#10; *&#10; * Act before the storage backends update field data.&#10; *&#10; * This hook allows modules to store data before the Field Storage API,&#10; * optionally preventing the field storage module from doing so.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The entity with fields to save.&#10; * @param $skip_fields&#10; *   An array keyed by field IDs whose data has already been written and&#10; *   therefore should not be written again. The values associated with these&#10; *   keys are not specified.&#10; * @return&#10; *   Saved field IDs are set set as keys in $skip_fields.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_update($entity_type, $entity, &amp;$skip_fields) {&#10;  $first_call = &amp;drupal_static(__FUNCTION__, array());&#10;&#10;  if ($entity_type == 'node' &amp;&amp; $entity-&gt;status &amp;&amp; _forum_node_check_node_type($entity)) {&#10;    // We don't maintain data for old revisions, so clear all previous values&#10;    // from the table. Since this hook runs once per field, per entity, make&#10;    // sure we only wipe values once.&#10;    if (!isset($first_call[$entity-&gt;nid])) {&#10;      $first_call[$entity-&gt;nid] = FALSE;&#10;      db_delete('forum_index')-&gt;condition('nid', $entity-&gt;nid)-&gt;execute();&#10;    }&#10;    // Only save data to the table if the node is published.&#10;    if ($entity-&gt;status) {&#10;      $query = db_insert('forum_index')-&gt;fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));&#10;      foreach ($entity-&gt;taxonomy_forums as $language) {&#10;        foreach ($language as $delta) {&#10;          $query-&gt;values(array(&#10;            'nid' =&gt; $entity-&gt;nid,&#10;            'title' =&gt; $entity-&gt;title,&#10;            'tid' =&gt; $delta['value'],&#10;            'sticky' =&gt; $entity-&gt;sticky,&#10;            'created' =&gt; $entity-&gt;created,&#10;            'comment_count' =&gt; 0,&#10;            'last_comment_timestamp' =&gt; $entity-&gt;created,&#10;          ));&#10;        }&#10;      }&#10;      $query-&gt;execute();&#10;      // The logic for determining last_comment_count is fairly complex, so&#10;      // call _forum_update_forum_index() too.&#10;      _forum_update_forum_index($entity-&gt;nid);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_pre_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_pre_update" value="/**&#10; * Implements hook_field_storage_pre_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_pre_update($entity_type, $entity, &amp;$skip_fields) {&#10;  $first_call = &amp;drupal_static(__FUNCTION__, array());&#10;&#10;  if ($entity_type == 'node' &amp;&amp; $entity-&gt;status &amp;&amp; _forum_node_check_node_type($entity)) {&#10;    // We don't maintain data for old revisions, so clear all previous values&#10;    // from the table. Since this hook runs once per field, per entity, make&#10;    // sure we only wipe values once.&#10;    if (!isset($first_call[$entity-&gt;nid])) {&#10;      $first_call[$entity-&gt;nid] = FALSE;&#10;      db_delete('forum_index')-&gt;condition('nid', $entity-&gt;nid)-&gt;execute();&#10;    }&#10;    // Only save data to the table if the node is published.&#10;    if ($entity-&gt;status) {&#10;      $query = db_insert('forum_index')-&gt;fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));&#10;      foreach ($entity-&gt;taxonomy_forums as $language) {&#10;        foreach ($language as $delta) {&#10;          $query-&gt;values(array(&#10;            'nid' =&gt; $entity-&gt;nid,&#10;            'title' =&gt; $entity-&gt;title,&#10;            'tid' =&gt; $delta['value'],&#10;            'sticky' =&gt; $entity-&gt;sticky,&#10;            'created' =&gt; $entity-&gt;created,&#10;            'comment_count' =&gt; 0,&#10;            'last_comment_timestamp' =&gt; $entity-&gt;created,&#10;          ));&#10;        }&#10;      }&#10;      $query-&gt;execute();&#10;      // The logic for determining last_comment_count is fairly complex, so&#10;      // call _forum_update_forum_index() too.&#10;      _forum_update_forum_index($entity-&gt;nid);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_storage_pre_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_info_max_weight" value="/**&#10; * Implements hook_field_info_max_weight().&#10; *&#10; * Returns the maximum weight for the entity components handled by the module.&#10; *&#10; * Field API takes care of fields and 'extra_fields'. This hook is intended for&#10; * third-party modules adding other entity components (e.g. field_group).&#10; *&#10; * @param $entity_type&#10; *   The type of entity; e.g. 'node' or 'user'.&#10; * @param $bundle&#10; *   The bundle name.&#10; * @param $context&#10; *   The context for which the maximum weight is requested. Either 'form', or&#10; *   the name of a view mode.&#10; * @return&#10; *   The maximum weight of the entity's components, or NULL if no components&#10; *   were found.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info_max_weight($entity_type, $bundle, $context) {&#10;  $weights = array();&#10;&#10;  foreach (my_module_entity_additions($entity_type, $bundle, $context) as $addition) {&#10;    $weights[] = $addition['weight'];&#10;  }&#10;&#10;  return $weights ? max($weights) : NULL;&#10;  $END$&#10;}" description="hook_field_info_max_weight" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_info_max_weight" value="/**&#10; * Implements hook_field_info_max_weight().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_info_max_weight($entity_type, $bundle, $context) {&#10;  $weights = array();&#10;&#10;  foreach (my_module_entity_additions($entity_type, $bundle, $context) as $addition) {&#10;    $weights[] = $addition['weight'];&#10;  }&#10;&#10;  return $weights ? max($weights) : NULL;&#10;  $END$&#10;}" description="hook_field_info_max_weight" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_display_alter" value="/**&#10; * Implements hook_field_display_alter().&#10; *&#10; * Alters the display settings of a field before it gets displayed.&#10; *&#10; * Note that instead of hook_field_display_alter(), which is called for all&#10; * fields on all entity types, hook_field_display_ENTITY_TYPE_alter() may be&#10; * used to alter display settings for fields on a specific entity type only.&#10; *&#10; * This hook is called once per field per displayed entity. If the result of the&#10; * hook involves reading from the database, it is highly recommended to&#10; * statically cache the information.&#10; *&#10; * @param $display&#10; *   The display settings that will be used to display the field values, as&#10; *   found in the 'display' key of $instance definitions.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The entity type; e.g., 'node' or 'user'.&#10; *   - field: The field being rendered.&#10; *   - instance: The instance being rendered.&#10; *   - entity: The entity being rendered.&#10; *   - view_mode: The view mode, e.g. 'full', 'teaser'...&#10; *&#10; * @see hook_field_display_ENTITY_TYPE_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_display_alter(&amp;$display, $context) {&#10;  // Leave field labels out of the search index.&#10;  // Note: The check against $context['entity_type'] == 'node' could be avoided&#10;  // by using hook_field_display_node_alter() instead of&#10;  // hook_field_display_alter(), resulting in less function calls when&#10;  // rendering non-node entities.&#10;  if ($context['entity_type'] == 'node' &amp;&amp; $context['view_mode'] == 'search_index') {&#10;    $display['label'] = 'hidden';&#10;  }&#10;  $END$&#10;}" description="hook_field_display_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_display_alter" value="/**&#10; * Implements hook_field_display_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_display_alter(&amp;$display, $context) {&#10;  // Leave field labels out of the search index.&#10;  // Note: The check against $context['entity_type'] == 'node' could be avoided&#10;  // by using hook_field_display_node_alter() instead of&#10;  // hook_field_display_alter(), resulting in less function calls when&#10;  // rendering non-node entities.&#10;  if ($context['entity_type'] == 'node' &amp;&amp; $context['view_mode'] == 'search_index') {&#10;    $display['label'] = 'hidden';&#10;  }&#10;  $END$&#10;}" description="hook_field_display_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_display_ENTITY_TYPE_alter" value="/**&#10; * Implements hook_field_display_ENTITY_TYPE_alter().&#10; *&#10; * Alters the display settings of a field on a given entity type before it gets displayed.&#10; *&#10; * Modules can implement hook_field_display_ENTITY_TYPE_alter() to alter display&#10; * settings for fields on a specific entity type, rather than implementing&#10; * hook_field_display_alter().&#10; *&#10; * This hook is called once per field per displayed entity. If the result of the&#10; * hook involves reading from the database, it is highly recommended to&#10; * statically cache the information.&#10; *&#10; * @param $display&#10; *   The display settings that will be used to display the field values, as&#10; *   found in the 'display' key of $instance definitions.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The entity type; e.g., 'node' or 'user'.&#10; *   - field: The field being rendered.&#10; *   - instance: The instance being rendered.&#10; *   - entity: The entity being rendered.&#10; *   - view_mode: The view mode, e.g. 'full', 'teaser'...&#10; *&#10; * @see hook_field_display_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_display_ENTITY_TYPE_alter(&amp;$display, $context) {&#10;  // Leave field labels out of the search index.&#10;  if ($context['view_mode'] == 'search_index') {&#10;    $display['label'] = 'hidden';&#10;  }&#10;  $END$&#10;}" description="hook_field_display_ENTITY_TYPE_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_display_ENTITY_TYPE_alter" value="/**&#10; * Implements hook_field_display_ENTITY_TYPE_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_display_ENTITY_TYPE_alter(&amp;$display, $context) {&#10;  // Leave field labels out of the search index.&#10;  if ($context['view_mode'] == 'search_index') {&#10;    $display['label'] = 'hidden';&#10;  }&#10;  $END$&#10;}" description="hook_field_display_ENTITY_TYPE_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_extra_fields_display_alter" value="/**&#10; * Implements hook_field_extra_fields_display_alter().&#10; *&#10; * Alters the display settings of pseudo-fields before an entity is displayed.&#10; *&#10; * This hook is called once per displayed entity. If the result of the hook&#10; * involves reading from the database, it is highly recommended to statically&#10; * cache the information.&#10; *&#10; * @param $displays&#10; *   An array of display settings for the pseudo-fields in the entity, keyed&#10; *   by pseudo-field names.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The entity type; e.g., 'node' or 'user'.&#10; *   - bundle: The bundle name.&#10; *   - view_mode: The view mode, e.g. 'full', 'teaser'...&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields_display_alter(&amp;$displays, $context) {&#10;  if ($context['entity_type'] == 'taxonomy_term' &amp;&amp; $context['view_mode'] == 'full') {&#10;    $displays['description']['visible'] = FALSE;&#10;  }&#10;  $END$&#10;}" description="hook_field_extra_fields_display_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_extra_fields_display_alter" value="/**&#10; * Implements hook_field_extra_fields_display_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_extra_fields_display_alter(&amp;$displays, $context) {&#10;  if ($context['entity_type'] == 'taxonomy_term' &amp;&amp; $context['view_mode'] == 'full') {&#10;    $displays['description']['visible'] = FALSE;&#10;  }&#10;  $END$&#10;}" description="hook_field_extra_fields_display_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_properties_alter" value="/**&#10; * Implements hook_field_widget_properties_alter().&#10; *&#10; * Alters the widget properties of a field instance before it gets displayed.&#10; *&#10; * Note that instead of hook_field_widget_properties_alter(), which is called&#10; * for all fields on all entity types,&#10; * hook_field_widget_properties_ENTITY_TYPE_alter() may be used to alter widget&#10; * properties for fields on a specific entity type only.&#10; *&#10; * This hook is called once per field per added or edit entity. If the result&#10; * of the hook involves reading from the database, it is highly recommended to&#10; * statically cache the information.&#10; *&#10; * @param $widget&#10; *   The instance's widget properties.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The entity type; e.g., 'node' or 'user'.&#10; *   - entity: The entity object.&#10; *   - field: The field that the widget belongs to.&#10; *   - instance: The instance of the field.&#10; *&#10; * @see hook_field_widget_properties_ENTITY_TYPE_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_properties_alter(&amp;$widget, $context) {&#10;  // Change a widget's type according to the time of day.&#10;  $field = $context['field'];&#10;  if ($context['entity_type'] == 'node' &amp;&amp; $field['field_name'] == 'field_foo') {&#10;    $time = date('H');&#10;    $widget['type'] = $time &lt; 12 ? 'widget_am' : 'widget_pm';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_properties_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_properties_alter" value="/**&#10; * Implements hook_field_widget_properties_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_properties_alter(&amp;$widget, $context) {&#10;  // Change a widget's type according to the time of day.&#10;  $field = $context['field'];&#10;  if ($context['entity_type'] == 'node' &amp;&amp; $field['field_name'] == 'field_foo') {&#10;    $time = date('H');&#10;    $widget['type'] = $time &lt; 12 ? 'widget_am' : 'widget_pm';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_properties_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_properties_ENTITY_TYPE_alter" value="/**&#10; * Implements hook_field_widget_properties_ENTITY_TYPE_alter().&#10; *&#10; * Alters the widget properties of a field instance on a given entity type&#10; * before it gets displayed.&#10; *&#10; * Modules can implement hook_field_widget_properties_ENTITY_TYPE_alter() to&#10; * alter the widget properties for fields on a specific entity type, rather than&#10; * implementing hook_field_widget_properties_alter().&#10; *&#10; * This hook is called once per field per displayed widget entity. If the result&#10; * of the hook involves reading from the database, it is highly recommended to&#10; * statically cache the information.&#10; *&#10; * @param $widget&#10; *   The instance's widget properties.&#10; * @param $context&#10; *   An associative array containing:&#10; *   - entity_type: The entity type; e.g., 'node' or 'user'.&#10; *   - entity: The entity object.&#10; *   - field: The field that the widget belongs to.&#10; *   - instance: The instance of the field.&#10; *&#10; * @see hook_field_widget_properties_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_properties_ENTITY_TYPE_alter(&amp;$widget, $context) {&#10;  // Change a widget's type according to the time of day.&#10;  $field = $context['field'];&#10;  if ($field['field_name'] == 'field_foo') {&#10;    $time = date('H');&#10;    $widget['type'] = $time &lt; 12 ? 'widget_am' : 'widget_pm';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_properties_ENTITY_TYPE_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_properties_ENTITY_TYPE_alter" value="/**&#10; * Implements hook_field_widget_properties_ENTITY_TYPE_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_properties_ENTITY_TYPE_alter(&amp;$widget, $context) {&#10;  // Change a widget's type according to the time of day.&#10;  $field = $context['field'];&#10;  if ($field['field_name'] == 'field_foo') {&#10;    $time = date('H');&#10;    $widget['type'] = $time &lt; 12 ? 'widget_am' : 'widget_pm';&#10;  }&#10;  $END$&#10;}" description="hook_field_widget_properties_ENTITY_TYPE_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_create_field" value="/**&#10; * Implements hook_field_create_field().&#10; *&#10; * Act on a field being created.&#10; *&#10; * This hook is invoked from field_create_field() after the field is created, to&#10; * allow modules to act on field creation.&#10; *&#10; * @param $field&#10; *   The field just created.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_create_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_create_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_create_field" value="/**&#10; * Implements hook_field_create_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_create_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_create_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_create_instance" value="/**&#10; * Implements hook_field_create_instance().&#10; *&#10; * Act on a field instance being created.&#10; *&#10; * This hook is invoked from field_create_instance() after the instance record&#10; * is saved, so it cannot be used to modify the instance itself.&#10; *&#10; * @param $instance&#10; *   The instance just created.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_create_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_create_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_create_instance" value="/**&#10; * Implements hook_field_create_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_create_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_create_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_update_forbid" value="/**&#10; * Implements hook_field_update_forbid().&#10; *&#10; * Forbid a field update from occurring.&#10; *&#10; * Any module may forbid any update for any reason. For example, the&#10; * field's storage module might forbid an update if it would change&#10; * the storage schema while data for the field exists. A field type&#10; * module might forbid an update if it would change existing data's&#10; * semantics, or if there are external dependencies on field settings&#10; * that cannot be updated.&#10; *&#10; * To forbid the update from occurring, throw a FieldUpdateForbiddenException.&#10; *&#10; * @param $field&#10; *   The field as it will be post-update.&#10; * @param $prior_field&#10; *   The field as it is pre-update.&#10; * @param $has_data&#10; *   Whether any data already exists for this field.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_forbid($field, $prior_field, $has_data) {&#10;  // A 'list' field stores integer keys mapped to display values. If&#10;  // the new field will have fewer values, and any data exists for the&#10;  // abandoned keys, the field will have no way to display them. So,&#10;  // forbid such an update.&#10;  if ($has_data &amp;&amp; count($field['settings']['allowed_values']) &lt; count($prior_field['settings']['allowed_values'])) {&#10;    // Identify the keys that will be lost.&#10;    $lost_keys = array_diff(array_keys($field['settings']['allowed_values']), array_keys($prior_field['settings']['allowed_values']));&#10;    // If any data exist for those keys, forbid the update.&#10;    $query = new EntityFieldQuery();&#10;    $found = $query&#10;      -&gt;fieldCondition($prior_field['field_name'], 'value', $lost_keys)&#10;      -&gt;range(0, 1)&#10;      -&gt;execute();&#10;    if ($found) {&#10;      throw new FieldUpdateForbiddenException(&quot;Cannot update a list field not to include keys with existing data&quot;);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_update_forbid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_update_forbid" value="/**&#10; * Implements hook_field_update_forbid().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_forbid($field, $prior_field, $has_data) {&#10;  // A 'list' field stores integer keys mapped to display values. If&#10;  // the new field will have fewer values, and any data exists for the&#10;  // abandoned keys, the field will have no way to display them. So,&#10;  // forbid such an update.&#10;  if ($has_data &amp;&amp; count($field['settings']['allowed_values']) &lt; count($prior_field['settings']['allowed_values'])) {&#10;    // Identify the keys that will be lost.&#10;    $lost_keys = array_diff(array_keys($field['settings']['allowed_values']), array_keys($prior_field['settings']['allowed_values']));&#10;    // If any data exist for those keys, forbid the update.&#10;    $query = new EntityFieldQuery();&#10;    $found = $query&#10;      -&gt;fieldCondition($prior_field['field_name'], 'value', $lost_keys)&#10;      -&gt;range(0, 1)&#10;      -&gt;execute();&#10;    if ($found) {&#10;      throw new FieldUpdateForbiddenException(&quot;Cannot update a list field not to include keys with existing data&quot;);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_field_update_forbid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_update_field" value="/**&#10; * Implements hook_field_update_field().&#10; *&#10; * Act on a field being updated.&#10; *&#10; * This hook is invoked just after field is updated in field_update_field().&#10; *&#10; * @param $field&#10; *   The field as it is post-update.&#10; * @param $prior_field&#10; *   The field as it was pre-update.&#10; * @param $has_data&#10; *   Whether any data already exists for this field.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_field($field, $prior_field, $has_data) {&#10;  // Reset the static value that keeps track of allowed values for list fields.&#10;  drupal_static_reset('list_allowed_values');&#10;  $END$&#10;}" description="hook_field_update_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_update_field" value="/**&#10; * Implements hook_field_update_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_field($field, $prior_field, $has_data) {&#10;  // Reset the static value that keeps track of allowed values for list fields.&#10;  drupal_static_reset('list_allowed_values');&#10;  $END$&#10;}" description="hook_field_update_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_delete_field" value="/**&#10; * Implements hook_field_delete_field().&#10; *&#10; * Act on a field being deleted.&#10; *&#10; * This hook is invoked just after a field is deleted by field_delete_field().&#10; *&#10; * @param $field&#10; *   The field just deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_delete_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_delete_field" value="/**&#10; * Implements hook_field_delete_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_delete_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_update_instance" value="/**&#10; * Implements hook_field_update_instance().&#10; *&#10; * Act on a field instance being updated.&#10; *&#10; * This hook is invoked from field_update_instance() after the instance record&#10; * is saved, so it cannot be used by a module to modify the instance itself.&#10; *&#10; * @param $instance&#10; *   The instance as it is post-update.&#10; * @param $prior_$instance&#10; *   The instance as it was pre-update.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_instance($instance, $prior_instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_update_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_update_instance" value="/**&#10; * Implements hook_field_update_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_update_instance($instance, $prior_instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_update_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_delete_instance" value="/**&#10; * Implements hook_field_delete_instance().&#10; *&#10; * Act on a field instance being deleted.&#10; *&#10; * This hook is invoked from field_delete_instance() after the instance is&#10; * deleted.&#10; *&#10; * @param $instance&#10; *   The instance just deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_delete_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_delete_instance" value="/**&#10; * Implements hook_field_delete_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_delete_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_delete_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_read_field" value="/**&#10; * Implements hook_field_read_field().&#10; *&#10; * Act on field records being read from the database.&#10; *&#10; * This hook is invoked from field_read_fields() on each field being read.&#10; *&#10; * @param $field&#10; *   The field record just read from the database.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_read_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_read_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_read_field" value="/**&#10; * Implements hook_field_read_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_read_field($field) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_read_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_read_instance" value="/**&#10; * Implements hook_field_read_instance().&#10; *&#10; * Act on a field record being read from the database.&#10; *&#10; * This hook is invoked from field_read_instances() on each instance being read.&#10; *&#10; * @param $instance&#10; *   The instance record just read from the database.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_read_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_read_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_read_instance" value="/**&#10; * Implements hook_field_read_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_read_instance($instance) {&#10;  // @todo Needs function body.&#10;  $END$&#10;}" description="hook_field_read_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_purge_field" value="/**&#10; * Implements hook_field_purge_field().&#10; *&#10; * Acts when a field record is being purged.&#10; *&#10; * In field_purge_field(), after the field configuration has been&#10; * removed from the database, the field storage module has had a chance to&#10; * run its hook_field_storage_purge_field(), and the field info cache&#10; * has been cleared, this hook is invoked on all modules to allow them to&#10; * respond to the field being purged.&#10; *&#10; * @param $field&#10; *   The field being purged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_purge_field($field) {&#10;  db_delete('my_module_field_info')&#10;    -&gt;condition('id', $field['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_purge_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_purge_field" value="/**&#10; * Implements hook_field_purge_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_purge_field($field) {&#10;  db_delete('my_module_field_info')&#10;    -&gt;condition('id', $field['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_purge_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_purge_instance" value="/**&#10; * Implements hook_field_purge_instance().&#10; *&#10; * Acts when a field instance is being purged.&#10; *&#10; * In field_purge_instance(), after the field instance has been&#10; * removed from the database, the field storage module has had a chance to&#10; * run its hook_field_storage_purge_instance(), and the field info cache&#10; * has been cleared, this hook is invoked on all modules to allow them to&#10; * respond to the field instance being purged.&#10; *&#10; * @param $instance&#10; *   The instance being purged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_purge_instance($instance) {&#10;  db_delete('my_module_field_instance_info')&#10;    -&gt;condition('id', $instance['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_purge_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_purge_instance" value="/**&#10; * Implements hook_field_purge_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_purge_instance($instance) {&#10;  db_delete('my_module_field_instance_info')&#10;    -&gt;condition('id', $instance['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_purge_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_purge_field" value="/**&#10; * Implements hook_field_storage_purge_field().&#10; *&#10; * Remove field storage information when a field record is purged.&#10; *&#10; * Called from field_purge_field() to allow the field storage module&#10; * to remove field information when a field is being purged.&#10; *&#10; * @param $field&#10; *   The field being purged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge_field($field) {&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_drop_table($table_name);&#10;  db_drop_table($revision_name);&#10;  $END$&#10;}" description="hook_field_storage_purge_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_purge_field" value="/**&#10; * Implements hook_field_storage_purge_field().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge_field($field) {&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_drop_table($table_name);&#10;  db_drop_table($revision_name);&#10;  $END$&#10;}" description="hook_field_storage_purge_field" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_purge_field_instance" value="/**&#10; * Implements hook_field_storage_purge_field_instance().&#10; *&#10; * Remove field storage information when a field instance is purged.&#10; *&#10; * Called from field_purge_instance() to allow the field storage module&#10; * to remove field instance information when a field instance is being&#10; * purged.&#10; *&#10; * @param $instance&#10; *   The instance being purged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge_field_instance($instance) {&#10;  db_delete('my_module_field_instance_info')&#10;    -&gt;condition('id', $instance['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_purge_field_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_purge_field_instance" value="/**&#10; * Implements hook_field_storage_purge_field_instance().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge_field_instance($instance) {&#10;  db_delete('my_module_field_instance_info')&#10;    -&gt;condition('id', $instance['id'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_purge_field_instance" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_storage_purge" value="/**&#10; * Implements hook_field_storage_purge().&#10; *&#10; * Remove field storage information when field data is purged.&#10; *&#10; * Called from field_purge_data() to allow the field storage&#10; * module to delete field data information.&#10; *&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The pseudo-entity whose field data to delete.&#10; * @param $field&#10; *   The (possibly deleted) field whose data is being purged.&#10; * @param $instance&#10; *   The deleted field instance whose data is being purged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge($entity_type, $entity, $field, $instance) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_delete($table_name)&#10;    -&gt;condition('entity_type', $entity_type)&#10;    -&gt;condition('entity_id', $id)&#10;    -&gt;execute();&#10;  db_delete($revision_name)&#10;    -&gt;condition('entity_type', $entity_type)&#10;    -&gt;condition('entity_id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_purge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_storage_purge" value="/**&#10; * Implements hook_field_storage_purge().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_storage_purge($entity_type, $entity, $field, $instance) {&#10;  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);&#10;&#10;  $table_name = _field_sql_storage_tablename($field);&#10;  $revision_name = _field_sql_storage_revision_tablename($field);&#10;  db_delete($table_name)&#10;    -&gt;condition('entity_type', $entity_type)&#10;    -&gt;condition('entity_id', $id)&#10;    -&gt;execute();&#10;  db_delete($revision_name)&#10;    -&gt;condition('entity_type', $entity_type)&#10;    -&gt;condition('entity_id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_field_storage_purge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_access" value="/**&#10; * Implements hook_field_access().&#10; *&#10; * Determine whether the user has access to a given field.&#10; *&#10; * This hook is invoked from field_access() to let modules block access to&#10; * operations on fields. If no module returns FALSE, the operation is allowed.&#10; *&#10; * @param $op&#10; *   The operation to be performed. Possible values: 'edit', 'view'.&#10; * @param $field&#10; *   The field on which the operation is to be performed.&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   (optional) The entity for the operation.&#10; * @param $account&#10; *   (optional) The account to check; if not given use currently logged in user.&#10; *&#10; * @return&#10; *   TRUE if the operation is allowed, and FALSE if the operation is denied.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_access($op, $field, $entity_type, $entity, $account) {&#10;  if ($field['field_name'] == 'field_of_interest' &amp;&amp; $op == 'edit') {&#10;    return user_access('edit field of interest', $account);&#10;  }&#10;  return TRUE;&#10;  $END$&#10;}" description="hook_field_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_access" value="/**&#10; * Implements hook_field_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_access($op, $field, $entity_type, $entity, $account) {&#10;  if ($field['field_name'] == 'field_of_interest' &amp;&amp; $op == 'edit') {&#10;    return user_access('edit field of interest', $account);&#10;  }&#10;  return TRUE;&#10;  $END$&#10;}" description="hook_field_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_shortcut_default_set" value="/**&#10; * Implements hook_shortcut_default_set().&#10; *&#10; * Return the name of a default shortcut set for the provided user account.&#10; *&#10; * This hook allows modules to define default shortcut sets for a particular&#10; * user that differ from the site-wide default (for example, a module may want&#10; * to define default shortcuts on a per-role basis).&#10; *&#10; * The default shortcut set is used only when the user does not have any other&#10; * shortcut set explicitly assigned to them.&#10; *&#10; * Note that only one default shortcut set can exist per user, so when multiple&#10; * modules implement this hook, the last (i.e., highest weighted) module which&#10; * returns a valid shortcut set name will prevail.&#10; *&#10; * @param $account&#10; *   The user account whose default shortcut set is being requested.&#10; * @return&#10; *   The name of the shortcut set that this module recommends for that user, if&#10; *   there is one.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_shortcut_default_set($account) {&#10;  // Use a special set of default shortcuts for administrators only.&#10;  if (in_array(variable_get('user_admin_role', 0), $account-&gt;roles)) {&#10;    return variable_get('mymodule_shortcut_admin_default_set');&#10;  }&#10;  $END$&#10;}" description="hook_shortcut_default_set" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_shortcut_default_set" value="/**&#10; * Implements hook_shortcut_default_set().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_shortcut_default_set($account) {&#10;  // Use a special set of default shortcuts for administrators only.&#10;  if (in_array(variable_get('user_admin_role', 0), $account-&gt;roles)) {&#10;    return variable_get('mymodule_shortcut_admin_default_set');&#10;  }&#10;  $END$&#10;}" description="hook_shortcut_default_set" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid" value="/**&#10; * Implements hook_openid().&#10; *&#10; * Allow modules to modify the OpenID request parameters.&#10; *&#10; * @param $op&#10; *   The operation to be performed.&#10; *   Possible values:&#10; *   - request: Modify parameters before they are sent to the OpenID provider.&#10; * @param $request&#10; *   An associative array of parameter defaults to which to modify or append.&#10; * @return&#10; *   An associative array of parameters to be merged with the default list.&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid($op, $request) {&#10;  if ($op == 'request') {&#10;    $request['openid.identity'] = 'http://myname.myopenid.com/';&#10;  }&#10;  return $request;&#10;  $END$&#10;}" description="hook_openid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid" value="/**&#10; * Implements hook_openid().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid($op, $request) {&#10;  if ($op == 'request') {&#10;    $request['openid.identity'] = 'http://myname.myopenid.com/';&#10;  }&#10;  return $request;&#10;  $END$&#10;}" description="hook_openid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid_response" value="/**&#10; * Implements hook_openid_response().&#10; *&#10; * Allow modules to act upon a successful OpenID login.&#10; *&#10; * @param $response&#10; *   Response values from the OpenID Provider.&#10; * @param $account&#10; *   The Drupal user account that logged in&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_response($response, $account) {&#10;  if (isset($response['openid.ns.ax'])) {&#10;    _mymodule_store_ax_fields($response, $account);&#10;  }&#10;  $END$&#10;}" description="hook_openid_response" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid_response" value="/**&#10; * Implements hook_openid_response().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_response($response, $account) {&#10;  if (isset($response['openid.ns.ax'])) {&#10;    _mymodule_store_ax_fields($response, $account);&#10;  }&#10;  $END$&#10;}" description="hook_openid_response" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid_discovery_method_info" value="/**&#10; * Implements hook_openid_discovery_method_info().&#10; *&#10; * Allow modules to declare OpenID discovery methods.&#10; *&#10; * The discovery function callbacks will be called in turn with an unique&#10; * parameter, the claimed identifier. They have to return an associative array&#10; * with array of services and claimed identifier in the same form as returned by&#10; * openid_discover(). The resulting array must contain following keys:&#10; *   - 'services' (required) an array of discovered services (including OpenID&#10; *   version, endpoint URI, etc).&#10; *   - 'claimed_id' (optional) new claimed identifer, found by following HTTP&#10; *   redirects during the services discovery.&#10; *&#10; * The first discovery method that succeed (return at least one services) will&#10; * stop the discovery process.&#10; *&#10; * @return&#10; *   An associative array which keys are the name of the discovery methods and&#10; *   values are function callbacks.&#10; *&#10; * @see hook_openid_discovery_method_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_discovery_method_info() {&#10;  return array(&#10;    'new_discovery_idea' =&gt; '_my_discovery_method',&#10;  );&#10;  $END$&#10;}" description="hook_openid_discovery_method_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid_discovery_method_info" value="/**&#10; * Implements hook_openid_discovery_method_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_discovery_method_info() {&#10;  return array(&#10;    'new_discovery_idea' =&gt; '_my_discovery_method',&#10;  );&#10;  $END$&#10;}" description="hook_openid_discovery_method_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid_discovery_method_info_alter" value="/**&#10; * Implements hook_openid_discovery_method_info_alter().&#10; *&#10; * Allow modules to alter discovery methods.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_discovery_method_info_alter(&amp;$methods) {&#10;  // Remove XRI discovery scheme.&#10;  unset($methods['xri']);&#10;  $END$&#10;}" description="hook_openid_discovery_method_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid_discovery_method_info_alter" value="/**&#10; * Implements hook_openid_discovery_method_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_discovery_method_info_alter(&amp;$methods) {&#10;  // Remove XRI discovery scheme.&#10;  unset($methods['xri']);&#10;  $END$&#10;}" description="hook_openid_discovery_method_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid_normalization_method_info" value="/**&#10; * Implements hook_openid_normalization_method_info().&#10; *&#10; * Allow modules to declare OpenID normalization methods.&#10; *&#10; * The discovery function callbacks will be called in turn with an unique&#10; * parameter, the identifier to normalize. They have to return a normalized&#10; * identifier, or NULL if the identifier is not in a form they can handle.&#10; *&#10; * The first normalization method that succeed (return a value that is not NULL)&#10; * will stop the normalization process.&#10; *&#10; * @return&#10; *   An array with a set of function callbacks, that will be called in turn&#10; *   when normalizing an OpenID identifier. The normalization functions have&#10; *   to return a normalized identifier, or NULL if the identifier is not in&#10; *   a form they can handle.&#10; * @see hook_openid_normalization_method_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_normalization_method_info() {&#10;  return array(&#10;    'new_normalization_idea' =&gt; '_my_normalization_method',&#10;  );&#10;  $END$&#10;}" description="hook_openid_normalization_method_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid_normalization_method_info" value="/**&#10; * Implements hook_openid_normalization_method_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_normalization_method_info() {&#10;  return array(&#10;    'new_normalization_idea' =&gt; '_my_normalization_method',&#10;  );&#10;  $END$&#10;}" description="hook_openid_normalization_method_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_openid_normalization_method_info_alter" value="/**&#10; * Implements hook_openid_normalization_method_info_alter().&#10; *&#10; * Allow modules to alter normalization methods.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_normalization_method_info_alter(&amp;$methods) {&#10;  // Remove Google IDP normalization.&#10;  unset($methods['google_idp']);&#10;  $END$&#10;}" description="hook_openid_normalization_method_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_openid_normalization_method_info_alter" value="/**&#10; * Implements hook_openid_normalization_method_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_openid_normalization_method_info_alter(&amp;$methods) {&#10;  // Remove Google IDP normalization.&#10;  unset($methods['google_idp']);&#10;  $END$&#10;}" description="hook_openid_normalization_method_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_help" value="/**&#10; * Implements hook_help().&#10; *&#10; * Provide online user help.&#10; *&#10; * By implementing hook_help(), a module can make documentation available to&#10; * the user for the module as a whole, or for specific paths.  Help for&#10; * developers should usually be provided via function header comments in the&#10; * code, or in special API example files.&#10; *&#10; * For a detailed usage example, see page_example.module.&#10; *&#10; * @param $path&#10; *   The router menu path, as defined in hook_menu(), for the help that is&#10; *   being requested; e.g., 'admin/people' or 'user/register'.  If the router&#10; *   path includes a wildcard, then this will appear in $path as %, even if it&#10; *   is a named %autoloader wildcard in the hook_menu() implementation; for&#10; *   example, node pages would have $path equal to 'node/%' or 'node/%/view'.&#10; *   To provide a help page for a whole module with a listing on admin/help,&#10; *   your hook implementation should match a path with a special descriptor&#10; *   after a &quot;#&quot; sign:&#10; *     'admin/help#modulename'&#10; *       The main module help text, displayed on the admin/help/modulename&#10; *       page and linked to from the admin/help page.&#10; * @param $arg&#10; *   An array that corresponds to the return value of the arg() function, for&#10; *   modules that want to provide help that is specific to certain values&#10; *   of wildcards in $path. For example, you could provide help for the path&#10; *   'user/1' by looking for the path 'user/%' and $arg[1] == '1'. This given&#10; *   array should always be used rather than directly invoking arg(), because&#10; *   your hook implementation may be called for other purposes besides building&#10; *   the current page's help. Note that depending on which module is invoking&#10; *   hook_help, $arg may contain only empty strings. Regardless, $arg[0] to&#10; *   $arg[11] will always be set.&#10; * @return&#10; *   A localized string containing the help text.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_help($path, $arg) {&#10;  switch ($path) {&#10;    // Main module help for the block module&#10;    case 'admin/help#block':&#10;      return '&lt;p&gt;' . t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Bartik, for example, implements the regions &quot;Sidebar first&quot;, &quot;Sidebar second&quot;, &quot;Featured&quot;, &quot;Content&quot;, &quot;Header&quot;, &quot;Footer&quot;, etc., and a block may appear in any one of these areas. The &lt;a href=&quot;@blocks&quot;&gt;blocks administration page&lt;/a&gt; provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' =&gt; url('admin/structure/block'))) . '&lt;/p&gt;';&#10;&#10;    // Help for another path in the block module&#10;    case 'admin/structure/block':&#10;      return '&lt;p&gt;' . t('This page provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions. Since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis. Remember that your changes will not be saved until you click the &lt;em&gt;Save blocks&lt;/em&gt; button at the bottom of the page.') . '&lt;/p&gt;';&#10;  }&#10;  $END$&#10;}" description="hook_help" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_help" value="/**&#10; * Implements hook_help().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_help($path, $arg) {&#10;  switch ($path) {&#10;    // Main module help for the block module&#10;    case 'admin/help#block':&#10;      return '&lt;p&gt;' . t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Bartik, for example, implements the regions &quot;Sidebar first&quot;, &quot;Sidebar second&quot;, &quot;Featured&quot;, &quot;Content&quot;, &quot;Header&quot;, &quot;Footer&quot;, etc., and a block may appear in any one of these areas. The &lt;a href=&quot;@blocks&quot;&gt;blocks administration page&lt;/a&gt; provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' =&gt; url('admin/structure/block'))) . '&lt;/p&gt;';&#10;&#10;    // Help for another path in the block module&#10;    case 'admin/structure/block':&#10;      return '&lt;p&gt;' . t('This page provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions. Since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis. Remember that your changes will not be saved until you click the &lt;em&gt;Save blocks&lt;/em&gt; button at the bottom of the page.') . '&lt;/p&gt;';&#10;  }&#10;  $END$&#10;}" description="hook_help" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_hook_info" value="/**&#10; * Implements hook_hook_info().&#10; *&#10; * Defines one or more hooks that are exposed by a module.&#10; *&#10; * Normally hooks do not need to be explicitly defined. However, by declaring a&#10; * hook explicitly, a module may define a &quot;group&quot; for it. Modules that implement&#10; * a hook may then place their implementation in either $module.module or in&#10; * $module.$group.inc. If the hook is located in $module.$group.inc, then that&#10; * file will be automatically loaded when needed.&#10; * In general, hooks that are rarely invoked and/or are very large should be&#10; * placed in a separate include file, while hooks that are very short or very&#10; * frequently called should be left in the main module file so that they are&#10; * always available.&#10; *&#10; * @return&#10; *   An associative array whose keys are hook names and whose values are an&#10; *   associative array containing:&#10; *   - group: A string defining the group to which the hook belongs. The module&#10; *     system will determine whether a file with the name $module.$group.inc&#10; *     exists, and automatically load it when required.&#10; *&#10; * See system_hook_info() for all hook groups defined by Drupal core.&#10; *&#10; * @see hook_hook_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_hook_info() {&#10;  $hooks['token_info'] = array(&#10;    'group' =&gt; 'tokens',&#10;  );&#10;  $hooks['tokens'] = array(&#10;    'group' =&gt; 'tokens',&#10;  );&#10;  return $hooks;&#10;  $END$&#10;}" description="hook_hook_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_hook_info" value="/**&#10; * Implements hook_hook_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_hook_info() {&#10;  $hooks['token_info'] = array(&#10;    'group' =&gt; 'tokens',&#10;  );&#10;  $hooks['tokens'] = array(&#10;    'group' =&gt; 'tokens',&#10;  );&#10;  return $hooks;&#10;  $END$&#10;}" description="hook_hook_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_hook_info_alter" value="/**&#10; * Implements hook_hook_info_alter().&#10; *&#10; * Alter information from hook_hook_info().&#10; *&#10; * @param $hooks&#10; *   Information gathered by module_hook_info() from other modules'&#10; *   implementations of hook_hook_info(). Alter this array directly.&#10; *   See hook_hook_info() for information on what this may contain.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_hook_info_alter(&amp;$hooks) {&#10;  // Our module wants to completely override the core tokens, so make&#10;  // sure the core token hooks are not found.&#10;  $hooks['token_info']['group'] = 'mytokens';&#10;  $hooks['tokens']['group'] = 'mytokens';&#10;  $END$&#10;}" description="hook_hook_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_hook_info_alter" value="/**&#10; * Implements hook_hook_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_hook_info_alter(&amp;$hooks) {&#10;  // Our module wants to completely override the core tokens, so make&#10;  // sure the core token hooks are not found.&#10;  $hooks['token_info']['group'] = 'mytokens';&#10;  $hooks['tokens']['group'] = 'mytokens';&#10;  $END$&#10;}" description="hook_hook_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_info" value="/**&#10; * Implements hook_entity_info().&#10; *&#10; * Inform the base system and the Field API about one or more entity types.&#10; *&#10; * Inform the system about one or more entity types (i.e., object types that&#10; * can be loaded via entity_load() and, optionally, to which fields can be&#10; * attached).&#10; *&#10; * @return&#10; *   An array whose keys are entity type names and whose values identify&#10; *   properties of those types that the system needs to know about:&#10; *   - label: The human-readable name of the type.&#10; *   - controller class: The name of the class that is used to load the objects.&#10; *     The class has to implement the DrupalEntityControllerInterface interface.&#10; *     Leave blank to use the DrupalDefaultEntityController implementation.&#10; *   - base table: (used by DrupalDefaultEntityController) The name of the&#10; *     entity type's base table.&#10; *   - revision table: The name of the entity type's revision table (if any).&#10; *   - static cache: (used by DrupalDefaultEntityController) FALSE to disable&#10; *     static caching of entities during a page request. Defaults to TRUE.&#10; *   - field cache: (used by Field API loading and saving of field data) FALSE&#10; *     to disable Field API's persistent cache of field data. Only recommended&#10; *     if a higher level persistent cache is available for the entity type.&#10; *     Defaults to TRUE.&#10; *   - load hook: The name of the hook which should be invoked by&#10; *     DrupalDefaultEntityController:attachLoad(), for example 'node_load'.&#10; *   - uri callback: A function taking an entity as argument and returning the&#10; *     uri elements of the entity, e.g. 'path' and 'options'. The actual entity&#10; *     uri can be constructed by passing these elements to url().&#10; *   - label callback: (optional) A function taking an entity and an entity type&#10; *     as arguments and returning the label of the entity. The entity label is&#10; *     the main string associated with an entity; for example, the title of a&#10; *     node or the subject of a comment. If there is an entity object property&#10; *     that defines the label, use the 'label' element of the 'entity keys'&#10; *     return value component to provide this information (see below). If more&#10; *     complex logic is needed to determine the label of an entity, you can&#10; *     instead specify a callback function here, which will be called to&#10; *     determine the entity label. See also the entity_label() function, which&#10; *     implements this logic.&#10; *   - fieldable: Set to TRUE if you want your entity type to accept fields&#10; *     being attached to it.&#10; *   - translation: An associative array of modules registered as field&#10; *     translation handlers. Array keys are the module names, array values&#10; *     can be any data structure the module uses to provide field translation.&#10; *     Any empty value disallows the module to appear as a translation handler.&#10; *   - entity keys: An array describing how the Field API can extract the&#10; *     information it needs from the objects of the type. Elements:&#10; *     - id: The name of the property that contains the primary id of the&#10; *       entity. Every entity object passed to the Field API must have this&#10; *       property and its value must be numeric.&#10; *     - revision: The name of the property that contains the revision id of&#10; *       the entity. The Field API assumes that all revision ids are unique&#10; *       across all entities of a type. This entry can be omitted if the&#10; *       entities of this type are not versionable.&#10; *     - bundle: The name of the property that contains the bundle name for the&#10; *       entity. The bundle name defines which set of fields are attached to&#10; *       the entity (e.g. what nodes call &quot;content type&quot;). This entry can be&#10; *       omitted if this entity type exposes a single bundle (all entities have&#10; *       the same collection of fields). The name of this single bundle will be&#10; *       the same as the entity type.&#10; *     - label: The name of the property that contains the entity label. For&#10; *       example, if the entity's label is located in $entity-&gt;subject, then&#10; *       'subject' should be specified here. If complex logic is required to&#10; *       build the label, a 'label callback' should be defined instead (see&#10; *       the 'label callback' section above for details).&#10; *   - bundle keys: An array describing how the Field API can extract the&#10; *     information it needs from the bundle objects for this type. This entry&#10; *     is required if the 'path' provided in the 'bundles'/'admin' section&#10; *     identifies the bundle using a named menu placeholder whose loader&#10; *     callback returns an object (e.g., $vocabulary for taxonomy terms, or&#10; *     $node_type for nodes). If the path does not include the bundle, or the&#10; *     bundle is just a string rather than an automatically loaded object, then&#10; *     this can be omitted. Elements:&#10; *     - bundle: The name of the property of the bundle object that contains&#10; *       the name of the bundle object.&#10; *   - bundles: An array describing all bundles for this object type. Keys are&#10; *     bundles machine names, as found in the objects' 'bundle' property&#10; *     (defined in the 'entity keys' entry above). Elements:&#10; *     - label: The human-readable name of the bundle.&#10; *     - uri callback: Same as the 'uri callback' key documented above for the&#10; *       entity type, but for the bundle only. When determining the URI of an&#10; *       entity, if a 'uri callback' is defined for both the entity type and&#10; *       the bundle, the one for the bundle is used.&#10; *     - admin: An array of information that allows Field UI pages to attach&#10; *       themselves to the existing administration pages for the bundle.&#10; *       Elements:&#10; *       - path: the path of the bundle's main administration page, as defined&#10; *         in hook_menu(). If the path includes a placeholder for the bundle,&#10; *         the 'bundle argument' and 'real path' keys below are required.&#10; *       - bundle argument: The position of the bundle placeholder in 'path', if&#10; *         any.&#10; *       - real path: The actual path (no placeholder) of the bundle's main&#10; *         administration page. This will be used to generate links.&#10; *       - access callback: As in hook_menu(). 'user_access' will be assumed if&#10; *         no value is provided.&#10; *       - access arguments: As in hook_menu().&#10; *   - view modes: An array describing the view modes for the entity type. View&#10; *     modes let entities be displayed differently depending on the context.&#10; *     For instance, a node can be displayed differently on its own page&#10; *     ('full' mode), on the home page or taxonomy listings ('teaser' mode), or&#10; *     in an RSS feed ('rss' mode). Modules taking part in the display of the&#10; *     entity (notably the Field API) can adjust their behavior depending on&#10; *     the requested view mode. An additional 'default' view mode is available&#10; *     for all entity types. This view mode is not intended for actual entity&#10; *     display, but holds default display settings. For each available view&#10; *     mode, administrators can configure whether it should use its own set of&#10; *     field display settings, or just replicate the settings of the 'default'&#10; *     view mode, thus reducing the amount of display configurations to keep&#10; *     track of. Keys of the array are view mode names. Each view mode is&#10; *     described by an array with the following key/value pairs:&#10; *     - label: The human-readable name of the view mode&#10; *     - custom settings: A boolean specifying whether the view mode should by&#10; *       default use its own custom field display settings. If FALSE, entities&#10; *       displayed in this view mode will reuse the 'default' display settings&#10; *       by default (e.g. right after the module exposing the view mode is&#10; *       enabled), but administrators can later use the Field UI to apply custom&#10; *       display settings specific to the view mode.&#10; *&#10; * @see entity_load()&#10; * @see hook_entity_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_info() {&#10;  $return = array(&#10;    'node' =&gt; array(&#10;      'label' =&gt; t('Node'),&#10;      'controller class' =&gt; 'NodeController',&#10;      'base table' =&gt; 'node',&#10;      'revision table' =&gt; 'node_revision',&#10;      'uri callback' =&gt; 'node_uri',&#10;      'fieldable' =&gt; TRUE,&#10;      'translation' =&gt; array(&#10;        'locale' =&gt; TRUE,&#10;      ),&#10;      'entity keys' =&gt; array(&#10;        'id' =&gt; 'nid',&#10;        'revision' =&gt; 'vid',&#10;        'bundle' =&gt; 'type',&#10;      ),&#10;      'bundle keys' =&gt; array(&#10;        'bundle' =&gt; 'type',&#10;      ),&#10;      'bundles' =&gt; array(),&#10;      'view modes' =&gt; array(&#10;        'full' =&gt; array(&#10;          'label' =&gt; t('Full content'),&#10;          'custom settings' =&gt; FALSE,&#10;        ),&#10;        'teaser' =&gt; array(&#10;          'label' =&gt; t('Teaser'),&#10;          'custom settings' =&gt; TRUE,&#10;        ),&#10;        'rss' =&gt; array(&#10;          'label' =&gt; t('RSS'),&#10;          'custom settings' =&gt; FALSE,&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;&#10;  // Search integration is provided by node.module, so search-related&#10;  // view modes for nodes are defined here and not in search.module.&#10;  if (module_exists('search')) {&#10;    $return['node']['view modes'] += array(&#10;      'search_index' =&gt; array(&#10;        'label' =&gt; t('Search index'),&#10;        'custom settings' =&gt; FALSE,&#10;      ),&#10;      'search_result' =&gt; array(&#10;        'label' =&gt; t('Search result'),&#10;        'custom settings' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;&#10;  // Bundles must provide a human readable name so we can create help and error&#10;  // messages, and the path to attach Field admin pages to.&#10;  foreach (node_type_get_names() as $type =&gt; $name) {&#10;    $return['node']['bundles'][$type] = array(&#10;      'label' =&gt; $name,&#10;      'admin' =&gt; array(&#10;        'path' =&gt; 'admin/structure/types/manage/%node_type',&#10;        'real path' =&gt; 'admin/structure/types/manage/' . str_replace('_', '-', $type),&#10;        'bundle argument' =&gt; 4,&#10;        'access arguments' =&gt; array('administer content types'),&#10;      ),&#10;    );&#10;  }&#10;&#10;  return $return;&#10;  $END$&#10;}" description="hook_entity_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_info" value="/**&#10; * Implements hook_entity_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_info() {&#10;  $return = array(&#10;    'node' =&gt; array(&#10;      'label' =&gt; t('Node'),&#10;      'controller class' =&gt; 'NodeController',&#10;      'base table' =&gt; 'node',&#10;      'revision table' =&gt; 'node_revision',&#10;      'uri callback' =&gt; 'node_uri',&#10;      'fieldable' =&gt; TRUE,&#10;      'translation' =&gt; array(&#10;        'locale' =&gt; TRUE,&#10;      ),&#10;      'entity keys' =&gt; array(&#10;        'id' =&gt; 'nid',&#10;        'revision' =&gt; 'vid',&#10;        'bundle' =&gt; 'type',&#10;      ),&#10;      'bundle keys' =&gt; array(&#10;        'bundle' =&gt; 'type',&#10;      ),&#10;      'bundles' =&gt; array(),&#10;      'view modes' =&gt; array(&#10;        'full' =&gt; array(&#10;          'label' =&gt; t('Full content'),&#10;          'custom settings' =&gt; FALSE,&#10;        ),&#10;        'teaser' =&gt; array(&#10;          'label' =&gt; t('Teaser'),&#10;          'custom settings' =&gt; TRUE,&#10;        ),&#10;        'rss' =&gt; array(&#10;          'label' =&gt; t('RSS'),&#10;          'custom settings' =&gt; FALSE,&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;&#10;  // Search integration is provided by node.module, so search-related&#10;  // view modes for nodes are defined here and not in search.module.&#10;  if (module_exists('search')) {&#10;    $return['node']['view modes'] += array(&#10;      'search_index' =&gt; array(&#10;        'label' =&gt; t('Search index'),&#10;        'custom settings' =&gt; FALSE,&#10;      ),&#10;      'search_result' =&gt; array(&#10;        'label' =&gt; t('Search result'),&#10;        'custom settings' =&gt; FALSE,&#10;      ),&#10;    );&#10;  }&#10;&#10;  // Bundles must provide a human readable name so we can create help and error&#10;  // messages, and the path to attach Field admin pages to.&#10;  foreach (node_type_get_names() as $type =&gt; $name) {&#10;    $return['node']['bundles'][$type] = array(&#10;      'label' =&gt; $name,&#10;      'admin' =&gt; array(&#10;        'path' =&gt; 'admin/structure/types/manage/%node_type',&#10;        'real path' =&gt; 'admin/structure/types/manage/' . str_replace('_', '-', $type),&#10;        'bundle argument' =&gt; 4,&#10;        'access arguments' =&gt; array('administer content types'),&#10;      ),&#10;    );&#10;  }&#10;&#10;  return $return;&#10;  $END$&#10;}" description="hook_entity_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_info_alter" value="/**&#10; * Implements hook_entity_info_alter().&#10; *&#10; * Alter the entity info.&#10; *&#10; * Modules may implement this hook to alter the information that defines an&#10; * entity. All properties that are available in hook_entity_info() can be&#10; * altered here.&#10; *&#10; * @param $entity_info&#10; *   The entity info array, keyed by entity name.&#10; *&#10; * @see hook_entity_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_info_alter(&amp;$entity_info) {&#10;  // Set the controller class for nodes to an alternate implementation of the&#10;  // DrupalEntityController interface.&#10;  $entity_info['node']['controller class'] = 'MyCustomNodeController';&#10;  $END$&#10;}" description="hook_entity_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_info_alter" value="/**&#10; * Implements hook_entity_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_info_alter(&amp;$entity_info) {&#10;  // Set the controller class for nodes to an alternate implementation of the&#10;  // DrupalEntityController interface.&#10;  $entity_info['node']['controller class'] = 'MyCustomNodeController';&#10;  $END$&#10;}" description="hook_entity_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_load" value="/**&#10; * Implements hook_entity_load().&#10; *&#10; * Act on entities when loaded.&#10; *&#10; * This is a generic load hook called for all entity types loaded via the&#10; * entity API.&#10; *&#10; * @param $entities&#10; *   The entities keyed by entity ID.&#10; * @param $type&#10; *   The type of entities being loaded (i.e. node, user, comment).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_load($entities, $type) {&#10;  foreach ($entities as $entity) {&#10;    $entity-&gt;foo = mymodule_add_something($entity, $type);&#10;  }&#10;  $END$&#10;}" description="hook_entity_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_load" value="/**&#10; * Implements hook_entity_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_load($entities, $type) {&#10;  foreach ($entities as $entity) {&#10;    $entity-&gt;foo = mymodule_add_something($entity, $type);&#10;  }&#10;  $END$&#10;}" description="hook_entity_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_presave" value="/**&#10; * Implements hook_entity_presave().&#10; *&#10; * Act on an entity before it is about to be created or updated.&#10; *&#10; * @param $entity&#10; *   The entity object.&#10; * @param $type&#10; *   The type of entity being saved (i.e. node, user, comment).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_presave($entity, $type) {&#10;  $entity-&gt;changed = REQUEST_TIME;&#10;  $END$&#10;}" description="hook_entity_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_presave" value="/**&#10; * Implements hook_entity_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_presave($entity, $type) {&#10;  $entity-&gt;changed = REQUEST_TIME;&#10;  $END$&#10;}" description="hook_entity_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_insert" value="/**&#10; * Implements hook_entity_insert().&#10; *&#10; * Act on entities when inserted.&#10; *&#10; * @param $entity&#10; *   The entity object.&#10; * @param $type&#10; *   The type of entity being inserted (i.e. node, user, comment).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_insert($entity, $type) {&#10;  // Insert the new entity into a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_insert('example_entity')&#10;    -&gt;fields(array(&#10;      'type' =&gt; $type,&#10;      'id' =&gt; $id,&#10;      'created' =&gt; REQUEST_TIME,&#10;      'updated' =&gt; REQUEST_TIME,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_insert" value="/**&#10; * Implements hook_entity_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_insert($entity, $type) {&#10;  // Insert the new entity into a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_insert('example_entity')&#10;    -&gt;fields(array(&#10;      'type' =&gt; $type,&#10;      'id' =&gt; $id,&#10;      'created' =&gt; REQUEST_TIME,&#10;      'updated' =&gt; REQUEST_TIME,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_update" value="/**&#10; * Implements hook_entity_update().&#10; *&#10; * Act on entities when updated.&#10; *&#10; * @param $entity&#10; *   The entity object.&#10; * @param $type&#10; *   The type of entity being updated (i.e. node, user, comment).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_update($entity, $type) {&#10;  // Update the entity's entry in a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_update('example_entity')&#10;    -&gt;fields(array(&#10;      'updated' =&gt; REQUEST_TIME,&#10;    ))&#10;    -&gt;condition('type', $type)&#10;    -&gt;condition('id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_update" value="/**&#10; * Implements hook_entity_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_update($entity, $type) {&#10;  // Update the entity's entry in a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_update('example_entity')&#10;    -&gt;fields(array(&#10;      'updated' =&gt; REQUEST_TIME,&#10;    ))&#10;    -&gt;condition('type', $type)&#10;    -&gt;condition('id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_delete" value="/**&#10; * Implements hook_entity_delete().&#10; *&#10; * Act on entities when deleted.&#10; *&#10; * @param $entity&#10; *   The entity object.&#10; * @param $type&#10; *   The type of entity being deleted (i.e. node, user, comment).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_delete($entity, $type) {&#10;  // Delete the entity's entry from a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_delete('example_entity')&#10;    -&gt;condition('type', $type)&#10;    -&gt;condition('id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_delete" value="/**&#10; * Implements hook_entity_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_delete($entity, $type) {&#10;  // Delete the entity's entry from a fictional table of all entities.&#10;  $info = entity_get_info($type);&#10;  list($id) = entity_extract_ids($type, $entity);&#10;  db_delete('example_entity')&#10;    -&gt;condition('type', $type)&#10;    -&gt;condition('id', $id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_entity_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_query_alter" value="/**&#10; * Implements hook_entity_query_alter().&#10; *&#10; * Alter or execute an EntityFieldQuery.&#10; *&#10; * @param EntityFieldQuery $query&#10; *   An EntityFieldQuery. One of the most important properties to be changed is&#10; *   EntityFieldQuery::executeCallback. If this is set to an existing function,&#10; *   this function will get the query as its single argument and its result&#10; *   will be the returned as the result of EntityFieldQuery::execute(). This can&#10; *   be used to change the behavior of EntityFieldQuery entirely. For example,&#10; *   the default implementation can only deal with one field storage engine, but&#10; *   it is possible to write a module that can query across field storage&#10; *   engines. Also, the default implementation presumes entities are stored in&#10; *   SQL, but the execute callback could instead query any other entity storage,&#10; *   local or remote.&#10; *&#10; *   Note the $query-&gt;altered attribute which is TRUE in case the query has&#10; *   already been altered once. This happens with cloned queries.&#10; *   If there is a pager, then such a cloned query will be executed to count&#10; *   all elements. This query can be detected by checking for&#10; *   ($query-&gt;pager &amp;&amp; $query-&gt;count), allowing the driver to return 0 from&#10; *   the count query and disable the pager.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_query_alter($query) {&#10;  $query-&gt;executeCallback = 'my_module_query_callback';&#10;  $END$&#10;}" description="hook_entity_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_query_alter" value="/**&#10; * Implements hook_entity_query_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_query_alter($query) {&#10;  $query-&gt;executeCallback = 'my_module_query_callback';&#10;  $END$&#10;}" description="hook_entity_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_view" value="/**&#10; * Implements hook_entity_view().&#10; *&#10; * Act on entities being assembled before rendering.&#10; *&#10; * @param $entity&#10; *   The entity object.&#10; * @param $type&#10; *   The type of entity being rendered (i.e. node, user, comment).&#10; * @param $view_mode&#10; *   The view mode the entity is rendered in.&#10; * @param $langcode&#10; *   The language code used for rendering.&#10; *&#10; * The module may add elements to $entity-&gt;content prior to rendering. The&#10; * structure of $entity-&gt;content is a renderable array as expected by&#10; * drupal_render().&#10; *&#10; * @see hook_entity_view_alter()&#10; * @see hook_comment_view()&#10; * @see hook_node_view()&#10; * @see hook_user_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_view($entity, $type, $view_mode, $langcode) {&#10;  $entity-&gt;content['my_additional_field'] = array(&#10;    '#markup' =&gt; $additional_field,&#10;    '#weight' =&gt; 10,&#10;    '#theme' =&gt; 'mymodule_my_additional_field',&#10;  );&#10;  $END$&#10;}" description="hook_entity_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_view" value="/**&#10; * Implements hook_entity_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_view($entity, $type, $view_mode, $langcode) {&#10;  $entity-&gt;content['my_additional_field'] = array(&#10;    '#markup' =&gt; $additional_field,&#10;    '#weight' =&gt; 10,&#10;    '#theme' =&gt; 'mymodule_my_additional_field',&#10;  );&#10;  $END$&#10;}" description="hook_entity_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_view_alter" value="/**&#10; * Implements hook_entity_view_alter().&#10; *&#10; * Alter the results of ENTITY_view().&#10; *&#10; * This hook is called after the content has been assembled in a structured&#10; * array and may be used for doing processing which requires that the complete&#10; * entity content structure has been built.&#10; *&#10; * If a module wishes to act on the rendered HTML of the entity rather than the&#10; * structured content array, it may use this hook to add a #post_render&#10; * callback. Alternatively, it could also implement hook_preprocess_ENTITY().&#10; * See drupal_render() and theme() for details.&#10; *&#10; * @param $build&#10; *   A renderable array representing the entity content.&#10; * @param $type&#10; *   The type of entity being rendered (i.e. node, user, comment).&#10; *&#10; * @see hook_entity_view()&#10; * @see hook_comment_view_alter()&#10; * @see hook_node_view_alter()&#10; * @see hook_taxonomy_term_view_alter()&#10; * @see hook_user_view_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_view_alter(&amp;$build, $type) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;&#10;    // Add a #post_render callback to act on the rendered HTML of the entity.&#10;    $build['#post_render'][] = 'my_module_node_post_render';&#10;  }&#10;  $END$&#10;}" description="hook_entity_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_view_alter" value="/**&#10; * Implements hook_entity_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_view_alter(&amp;$build, $type) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;&#10;    // Add a #post_render callback to act on the rendered HTML of the entity.&#10;    $build['#post_render'][] = 'my_module_node_post_render';&#10;  }&#10;  $END$&#10;}" description="hook_entity_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_admin_paths" value="/**&#10; * Implements hook_admin_paths().&#10; *&#10; * Define administrative paths.&#10; *&#10; * Modules may specify whether or not the paths they define in hook_menu() are&#10; * to be considered administrative. Other modules may use this information to&#10; * display those pages differently (e.g. in a modal overlay, or in a different&#10; * theme).&#10; *&#10; * To change the administrative status of menu items defined in another module's&#10; * hook_menu(), modules should implement hook_admin_paths_alter().&#10; *&#10; * @return&#10; *   An associative array. For each item, the key is the path in question, in&#10; *   a format acceptable to drupal_match_path(). The value for each item should&#10; *   be TRUE (for paths considered administrative) or FALSE (for non-&#10; *   administrative paths).&#10; *&#10; * @see hook_menu()&#10; * @see drupal_match_path()&#10; * @see hook_admin_paths_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_paths() {&#10;  $paths = array(&#10;    'mymodule/*/add' =&gt; TRUE,&#10;    'mymodule/*/edit' =&gt; TRUE,&#10;  );&#10;  return $paths;&#10;  $END$&#10;}" description="hook_admin_paths" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_admin_paths" value="/**&#10; * Implements hook_admin_paths().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_paths() {&#10;  $paths = array(&#10;    'mymodule/*/add' =&gt; TRUE,&#10;    'mymodule/*/edit' =&gt; TRUE,&#10;  );&#10;  return $paths;&#10;  $END$&#10;}" description="hook_admin_paths" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_admin_paths_alter" value="/**&#10; * Implements hook_admin_paths_alter().&#10; *&#10; * Redefine administrative paths defined by other modules.&#10; *&#10; * @param $paths&#10; *   An associative array of administrative paths, as defined by implementations&#10; *   of hook_admin_paths().&#10; *&#10; * @see hook_admin_paths()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_paths_alter(&amp;$paths) {&#10;  // Treat all user pages as administrative.&#10;  $paths['user'] = TRUE;&#10;  $paths['user/*'] = TRUE;&#10;  // Treat the forum topic node form as a non-administrative page.&#10;  $paths['node/add/forum'] = FALSE;&#10;  $END$&#10;}" description="hook_admin_paths_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_admin_paths_alter" value="/**&#10; * Implements hook_admin_paths_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_paths_alter(&amp;$paths) {&#10;  // Treat all user pages as administrative.&#10;  $paths['user'] = TRUE;&#10;  $paths['user/*'] = TRUE;&#10;  // Treat the forum topic node form as a non-administrative page.&#10;  $paths['node/add/forum'] = FALSE;&#10;  $END$&#10;}" description="hook_admin_paths_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_prepare_view" value="/**&#10; * Implements hook_entity_prepare_view().&#10; *&#10; * Act on entities as they are being prepared for view.&#10; *&#10; * Allows you to operate on multiple entities as they are being prepared for&#10; * view. Only use this if attaching the data during the entity_load() phase&#10; * is not appropriate, for example when attaching other 'entity' style objects.&#10; *&#10; * @param $entities&#10; *   The entities keyed by entity ID.&#10; * @param $type&#10; *   The type of entities being loaded (i.e. node, user, comment).&#10; * @param $langcode&#10; *   The language to display the entity in.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_prepare_view($entities, $type, $langcode) {&#10;  // Load a specific node into the user object for later theming.&#10;  if ($type == 'user') {&#10;    $nodes = mymodule_get_user_nodes(array_keys($entities));&#10;    foreach ($entities as $uid =&gt; $entity) {&#10;      $entity-&gt;user_node = $nodes[$uid];&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_entity_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_prepare_view" value="/**&#10; * Implements hook_entity_prepare_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_prepare_view($entities, $type, $langcode) {&#10;  // Load a specific node into the user object for later theming.&#10;  if ($type == 'user') {&#10;    $nodes = mymodule_get_user_nodes(array_keys($entities));&#10;    foreach ($entities as $uid =&gt; $entity) {&#10;      $entity-&gt;user_node = $nodes[$uid];&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_entity_prepare_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_cron" value="/**&#10; * Implements hook_cron().&#10; *&#10; * Perform periodic actions.&#10; *&#10; * Modules that require some commands to be executed periodically can&#10; * implement hook_cron(). The engine will then call the hook whenever a cron&#10; * run happens, as defined by the administrator. Typical tasks managed by&#10; * hook_cron() are database maintenance, backups, recalculation of settings&#10; * or parameters, automated mailing, and retrieving remote data.&#10; *&#10; * Short-running or non-resource-intensive tasks can be executed directly in&#10; * the hook_cron() implementation.&#10; *&#10; * Long-running tasks and tasks that could time out, such as retrieving remote&#10; * data, sending email, and intensive file tasks, should use the queue API&#10; * instead of executing the tasks directly. To do this, first define one or&#10; * more queues via hook_cron_queue_info(). Then, add items that need to be&#10; * processed to the defined queues.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron() {&#10;  // Short-running operation example, not using a queue:&#10;  // Delete all expired records since the last cron run.&#10;  $expires = variable_get('mymodule_cron_last_run', REQUEST_TIME);&#10;  db_delete('mymodule_table')&#10;    -&gt;condition('expires', $expires, '&gt;=')&#10;    -&gt;execute();&#10;  variable_set('mymodule_cron_last_run', REQUEST_TIME);&#10;&#10;  // Long-running operation example, leveraging a queue:&#10;  // Fetch feeds from other sites.&#10;  $result = db_query('SELECT * FROM {aggregator_feed} WHERE checked + refresh &lt; :time AND refresh &lt;&gt; :never', array(&#10;    ':time' =&gt; REQUEST_TIME,&#10;    ':never' =&gt; AGGREGATOR_CLEAR_NEVER,&#10;  ));&#10;  $queue = DrupalQueue::get('aggregator_feeds');&#10;  foreach ($result as $feed) {&#10;    $queue-&gt;createItem($feed);&#10;  }&#10;  $END$&#10;}" description="hook_cron" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_cron" value="/**&#10; * Implements hook_cron().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron() {&#10;  // Short-running operation example, not using a queue:&#10;  // Delete all expired records since the last cron run.&#10;  $expires = variable_get('mymodule_cron_last_run', REQUEST_TIME);&#10;  db_delete('mymodule_table')&#10;    -&gt;condition('expires', $expires, '&gt;=')&#10;    -&gt;execute();&#10;  variable_set('mymodule_cron_last_run', REQUEST_TIME);&#10;&#10;  // Long-running operation example, leveraging a queue:&#10;  // Fetch feeds from other sites.&#10;  $result = db_query('SELECT * FROM {aggregator_feed} WHERE checked + refresh &lt; :time AND refresh &lt;&gt; :never', array(&#10;    ':time' =&gt; REQUEST_TIME,&#10;    ':never' =&gt; AGGREGATOR_CLEAR_NEVER,&#10;  ));&#10;  $queue = DrupalQueue::get('aggregator_feeds');&#10;  foreach ($result as $feed) {&#10;    $queue-&gt;createItem($feed);&#10;  }&#10;  $END$&#10;}" description="hook_cron" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_cron_queue_info" value="/**&#10; * Implements hook_cron_queue_info().&#10; *&#10; * Declare queues holding items that need to be run periodically.&#10; *&#10; * While there can be only one hook_cron() process running at the same time,&#10; * there can be any number of processes defined here running. Because of&#10; * this, long running tasks are much better suited for this API. Items queued&#10; * in hook_cron() might be processed in the same cron run if there are not many&#10; * items in the queue, otherwise it might take several requests, which can be&#10; * run in parallel.&#10; *&#10; * @return&#10; *   An associative array where the key is the queue name and the value is&#10; *   again an associative array. Possible keys are:&#10; *   - 'worker callback': The name of the function to call. It will be called&#10; *     with one argument, the item created via DrupalQueue::createItem() in&#10; *     hook_cron().&#10; *   - 'time': (optional) How much time Drupal should spend on calling this&#10; *     worker in seconds. Defaults to 15.&#10; *&#10; * @see hook_cron()&#10; * @see hook_cron_queue_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron_queue_info() {&#10;  $queues['aggregator_feeds'] = array(&#10;    'worker callback' =&gt; 'aggregator_refresh',&#10;    'time' =&gt; 60,&#10;  );&#10;  return $queues;&#10;  $END$&#10;}" description="hook_cron_queue_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_cron_queue_info" value="/**&#10; * Implements hook_cron_queue_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron_queue_info() {&#10;  $queues['aggregator_feeds'] = array(&#10;    'worker callback' =&gt; 'aggregator_refresh',&#10;    'time' =&gt; 60,&#10;  );&#10;  return $queues;&#10;  $END$&#10;}" description="hook_cron_queue_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_cron_queue_info_alter" value="/**&#10; * Implements hook_cron_queue_info_alter().&#10; *&#10; * Alter cron queue information before cron runs.&#10; *&#10; * Called by drupal_cron_run() to allow modules to alter cron queue settings&#10; * before any jobs are processesed.&#10; *&#10; * @param array $queues&#10; *   An array of cron queue information.&#10; *&#10; * @see hook_cron_queue_info()&#10; * @see drupal_cron_run()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron_queue_info_alter(&amp;$queues) {&#10;  // This site has many feeds so let's spend 90 seconds on each cron run&#10;  // updating feeds instead of the default 60.&#10;  $queues['aggregator_feeds']['time'] = 90;&#10;  $END$&#10;}" description="hook_cron_queue_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_cron_queue_info_alter" value="/**&#10; * Implements hook_cron_queue_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_cron_queue_info_alter(&amp;$queues) {&#10;  // This site has many feeds so let's spend 90 seconds on each cron run&#10;  // updating feeds instead of the default 60.&#10;  $queues['aggregator_feeds']['time'] = 90;&#10;  $END$&#10;}" description="hook_cron_queue_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_element_info" value="/**&#10; * Implements hook_element_info().&#10; *&#10; * Allows modules to declare their own Forms API element types and specify their&#10; * default values.&#10; *&#10; * This hook allows modules to declare their own form element types and to&#10; * specify their default values. The values returned by this hook will be&#10; * merged with the elements returned by hook_form() implementations and so&#10; * can return defaults for any Form APIs keys in addition to those explicitly&#10; * mentioned below.&#10; *&#10; * Each of the form element types defined by this hook is assumed to have&#10; * a matching theme function, e.g. theme_elementtype(), which should be&#10; * registered with hook_theme() as normal.&#10; *&#10; * For more information about custom element types see the explanation at&#10; * http://drupal.org/node/169815.&#10; *&#10; * @return&#10; *  An associative array describing the element types being defined. The array&#10; *  contains a sub-array for each element type, with the machine-readable type&#10; *  name as the key. Each sub-array has a number of possible attributes:&#10; *  - &quot;#input&quot;: boolean indicating whether or not this element carries a value&#10; *    (even if it's hidden).&#10; *  - &quot;#process&quot;: array of callback functions taking $element, $form_state,&#10; *    and $complete_form.&#10; *  - &quot;#after_build&quot;: array of callback functions taking $element and $form_state.&#10; *  - &quot;#validate&quot;: array of callback functions taking $form and $form_state.&#10; *  - &quot;#element_validate&quot;: array of callback functions taking $element and&#10; *    $form_state.&#10; *  - &quot;#pre_render&quot;: array of callback functions taking $element and $form_state.&#10; *  - &quot;#post_render&quot;: array of callback functions taking $element and $form_state.&#10; *  - &quot;#submit&quot;: array of callback functions taking $form and $form_state.&#10; *  - &quot;#title_display&quot;: optional string indicating if and how #title should be&#10; *    displayed, see theme_form_element() and theme_form_element_label().&#10; *&#10; * @see hook_element_info_alter()&#10; * @see system_element_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_element_info() {&#10;  $types['filter_format'] = array(&#10;    '#input' =&gt; TRUE,&#10;  );&#10;  return $types;&#10;  $END$&#10;}" description="hook_element_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_element_info" value="/**&#10; * Implements hook_element_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_element_info() {&#10;  $types['filter_format'] = array(&#10;    '#input' =&gt; TRUE,&#10;  );&#10;  return $types;&#10;  $END$&#10;}" description="hook_element_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_element_info_alter" value="/**&#10; * Implements hook_element_info_alter().&#10; *&#10; * Alter the element type information returned from modules.&#10; *&#10; * A module may implement this hook in order to alter the element type defaults&#10; * defined by a module.&#10; *&#10; * @param $type&#10; *   All element type defaults as collected by hook_element_info().&#10; *&#10; * @see hook_element_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_element_info_alter(&amp;$type) {&#10;  // Decrease the default size of textfields.&#10;  if (isset($type['textfield']['#size'])) {&#10;    $type['textfield']['#size'] = 40;&#10;  }&#10;  $END$&#10;}" description="hook_element_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_element_info_alter" value="/**&#10; * Implements hook_element_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_element_info_alter(&amp;$type) {&#10;  // Decrease the default size of textfields.&#10;  if (isset($type['textfield']['#size'])) {&#10;    $type['textfield']['#size'] = 40;&#10;  }&#10;  $END$&#10;}" description="hook_element_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_exit" value="/**&#10; * Implements hook_exit().&#10; *&#10; * Perform cleanup tasks.&#10; *&#10; * This hook is run at the end of each page request. It is often used for&#10; * page logging and specialized cleanup. This hook MUST NOT print anything.&#10; *&#10; * Only use this hook if your code must run even for cached page views.&#10; * If you have code which must run once on all non-cached pages, use&#10; * hook_init() instead. That is the usual case. If you implement this hook&#10; * and see an error like 'Call to undefined function', it is likely that&#10; * you are depending on the presence of a module which has not been loaded yet.&#10; * It is not loaded because Drupal is still in bootstrap mode.&#10; *&#10; * @param $destination&#10; *   If this hook is invoked as part of a drupal_goto() call, then this argument&#10; *   will be a fully-qualified URL that is the destination of the redirect.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_exit($destination = NULL) {&#10;  db_update('counter')&#10;    -&gt;expression('hits', 'hits + 1')&#10;    -&gt;condition('type', 1)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_exit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_exit" value="/**&#10; * Implements hook_exit().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_exit($destination = NULL) {&#10;  db_update('counter')&#10;    -&gt;expression('hits', 'hits + 1')&#10;    -&gt;condition('type', 1)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_exit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_js_alter" value="/**&#10; * Implements hook_js_alter().&#10; *&#10; * Perform necessary alterations to the JavaScript before it is presented on&#10; * the page.&#10; *&#10; * @param $javascript&#10; *   An array of all JavaScript being presented on the page.&#10; *&#10; * @see drupal_add_js()&#10; * @see drupal_get_js()&#10; * @see drupal_js_defaults()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_js_alter(&amp;$javascript) {&#10;  // Swap out jQuery to use an updated version of the library.&#10;  $javascript['misc/jquery.js']['data'] = drupal_get_path('module', 'jquery_update') . '/jquery.js';&#10;  $END$&#10;}" description="hook_js_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_js_alter" value="/**&#10; * Implements hook_js_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_js_alter(&amp;$javascript) {&#10;  // Swap out jQuery to use an updated version of the library.&#10;  $javascript['misc/jquery.js']['data'] = drupal_get_path('module', 'jquery_update') . '/jquery.js';&#10;  $END$&#10;}" description="hook_js_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_library" value="/**&#10; * Implements hook_library().&#10; *&#10; * Registers JavaScript/CSS libraries associated with a module.&#10; *&#10; * Modules implementing this return an array of arrays. The key to each&#10; * sub-array is the machine readable name of the library. Each library may&#10; * contain the following items:&#10; *&#10; * - 'title': The human readable name of the library.&#10; * - 'website': The URL of the library's web site.&#10; * - 'version': A string specifying the version of the library; intentionally&#10; *   not a float because a version like &quot;1.2.3&quot; is not a valid float. Use PHP's&#10; *   version_compare() to compare different versions.&#10; * - 'js': An array of JavaScript elements; each element's key is used as $data&#10; *   argument, each element's value is used as $options array for&#10; *   drupal_add_js(). To add library-specific (not module-specific) JavaScript&#10; *   settings, the key may be skipped, the value must specify&#10; *   'type' =&gt; 'setting', and the actual settings must be contained in a 'data'&#10; *   element of the value.&#10; * - 'css': Like 'js', an array of CSS elements passed to drupal_add_css().&#10; * - 'dependencies': An array of libraries that are required for a library. Each&#10; *   element is an array listing the module and name of another library. Note&#10; *   that all dependencies for each dependent library will also be added when&#10; *   this library is added.&#10; *&#10; * Registered information for a library should contain re-usable data only.&#10; * Module- or implementation-specific data and integration logic should be added&#10; * separately.&#10; *&#10; * @return&#10; *   An array defining libraries associated with a module.&#10; *&#10; * @see system_library()&#10; * @see drupal_add_library()&#10; * @see drupal_get_library()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_library() {&#10;  // Library One.&#10;  $libraries['library-1'] = array(&#10;    'title' =&gt; 'Library One',&#10;    'website' =&gt; 'http://example.com/library-1',&#10;    'version' =&gt; '1.2',&#10;    'js' =&gt; array(&#10;      drupal_get_path('module', 'my_module') . '/library-1.js' =&gt; array(),&#10;    ),&#10;    'css' =&gt; array(&#10;      drupal_get_path('module', 'my_module') . '/library-2.css' =&gt; array(&#10;        'type' =&gt; 'file',&#10;        'media' =&gt; 'screen',&#10;      ),&#10;    ),&#10;  );&#10;  // Library Two.&#10;  $libraries['library-2'] = array(&#10;    'title' =&gt; 'Library Two',&#10;    'website' =&gt; 'http://example.com/library-2',&#10;    'version' =&gt; '3.1-beta1',&#10;    'js' =&gt; array(&#10;      // JavaScript settings may use the 'data' key.&#10;      array(&#10;        'type' =&gt; 'setting',&#10;        'data' =&gt; array('library2' =&gt; TRUE),&#10;      ),&#10;    ),&#10;    'dependencies' =&gt; array(&#10;      // Require jQuery UI core by System module.&#10;      array('system', 'ui'),&#10;      // Require our other library.&#10;      array('my_module', 'library-1'),&#10;      // Require another library.&#10;      array('other_module', 'library-3'),&#10;    ),&#10;  );&#10;  return $libraries;&#10;  $END$&#10;}" description="hook_library" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_library" value="/**&#10; * Implements hook_library().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_library() {&#10;  // Library One.&#10;  $libraries['library-1'] = array(&#10;    'title' =&gt; 'Library One',&#10;    'website' =&gt; 'http://example.com/library-1',&#10;    'version' =&gt; '1.2',&#10;    'js' =&gt; array(&#10;      drupal_get_path('module', 'my_module') . '/library-1.js' =&gt; array(),&#10;    ),&#10;    'css' =&gt; array(&#10;      drupal_get_path('module', 'my_module') . '/library-2.css' =&gt; array(&#10;        'type' =&gt; 'file',&#10;        'media' =&gt; 'screen',&#10;      ),&#10;    ),&#10;  );&#10;  // Library Two.&#10;  $libraries['library-2'] = array(&#10;    'title' =&gt; 'Library Two',&#10;    'website' =&gt; 'http://example.com/library-2',&#10;    'version' =&gt; '3.1-beta1',&#10;    'js' =&gt; array(&#10;      // JavaScript settings may use the 'data' key.&#10;      array(&#10;        'type' =&gt; 'setting',&#10;        'data' =&gt; array('library2' =&gt; TRUE),&#10;      ),&#10;    ),&#10;    'dependencies' =&gt; array(&#10;      // Require jQuery UI core by System module.&#10;      array('system', 'ui'),&#10;      // Require our other library.&#10;      array('my_module', 'library-1'),&#10;      // Require another library.&#10;      array('other_module', 'library-3'),&#10;    ),&#10;  );&#10;  return $libraries;&#10;  $END$&#10;}" description="hook_library" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_library_alter" value="/**&#10; * Implements hook_library_alter().&#10; *&#10; * Alters the JavaScript/CSS library registry.&#10; *&#10; * Allows certain, contributed modules to update libraries to newer versions&#10; * while ensuring backwards compatibility. In general, such manipulations should&#10; * only be done by designated modules, since most modules that integrate with a&#10; * certain library also depend on the API of a certain library version.&#10; *&#10; * @param $libraries&#10; *   The JavaScript/CSS libraries provided by $module. Keyed by internal library&#10; *   name and passed by reference.&#10; * @param $module&#10; *   The name of the module that registered the libraries.&#10; *&#10; * @see hook_library()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_library_alter(&amp;$libraries, $module) {&#10;  // Update Farbtastic to version 2.0.&#10;  if ($module == 'system' &amp;&amp; isset($libraries['farbtastic'])) {&#10;    // Verify existing version is older than the one we are updating to.&#10;    if (version_compare($libraries['farbtastic']['version'], '2.0', '&lt;')) {&#10;      // Update the existing Farbtastic to version 2.0.&#10;      $libraries['farbtastic']['version'] = '2.0';&#10;      $libraries['farbtastic']['js'] = array(&#10;        drupal_get_path('module', 'farbtastic_update') . '/farbtastic-2.0.js' =&gt; array(),&#10;      );&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_library_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_library_alter" value="/**&#10; * Implements hook_library_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_library_alter(&amp;$libraries, $module) {&#10;  // Update Farbtastic to version 2.0.&#10;  if ($module == 'system' &amp;&amp; isset($libraries['farbtastic'])) {&#10;    // Verify existing version is older than the one we are updating to.&#10;    if (version_compare($libraries['farbtastic']['version'], '2.0', '&lt;')) {&#10;      // Update the existing Farbtastic to version 2.0.&#10;      $libraries['farbtastic']['version'] = '2.0';&#10;      $libraries['farbtastic']['js'] = array(&#10;        drupal_get_path('module', 'farbtastic_update') . '/farbtastic-2.0.js' =&gt; array(),&#10;      );&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_library_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_css_alter" value="/**&#10; * Implements hook_css_alter().&#10; *&#10; * Alter CSS files before they are output on the page.&#10; *&#10; * @param $css&#10; *   An array of all CSS items (files and inline CSS) being requested on the page.&#10; *&#10; * @see drupal_add_css()&#10; * @see drupal_get_css()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_css_alter(&amp;$css) {&#10;  // Remove defaults.css file.&#10;  unset($css[drupal_get_path('module', 'system') . '/defaults.css']);&#10;  $END$&#10;}" description="hook_css_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_css_alter" value="/**&#10; * Implements hook_css_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_css_alter(&amp;$css) {&#10;  // Remove defaults.css file.&#10;  unset($css[drupal_get_path('module', 'system') . '/defaults.css']);&#10;  $END$&#10;}" description="hook_css_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ajax_render_alter" value="/**&#10; * Implements hook_ajax_render_alter().&#10; *&#10; * Alter the commands that are sent to the user through the Ajax framework.&#10; *&#10; * @param $commands&#10; *   An array of all commands that will be sent to the user.&#10; *&#10; * @see ajax_render()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ajax_render_alter($commands) {&#10;  // Inject any new status messages into the content area.&#10;  $commands[] = ajax_command_prepend('#block-system-main .content', theme('status_messages'));&#10;  $END$&#10;}" description="hook_ajax_render_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ajax_render_alter" value="/**&#10; * Implements hook_ajax_render_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ajax_render_alter($commands) {&#10;  // Inject any new status messages into the content area.&#10;  $commands[] = ajax_command_prepend('#block-system-main .content', theme('status_messages'));&#10;  $END$&#10;}" description="hook_ajax_render_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_page_build" value="/**&#10; * Implements hook_page_build().&#10; *&#10; * Add elements to a page before it is rendered.&#10; *&#10; * Use this hook when you want to add elements at the page level. For your&#10; * additions to be printed, they have to be placed below a top level array key&#10; * of the $page array that has the name of a region of the active theme.&#10; *&#10; * By default, valid region keys are 'page_top', 'header', 'sidebar_first',&#10; * 'content', 'sidebar_second' and 'page_bottom'. To get a list of all regions&#10; * of the active theme, use system_region_list($theme). Note that $theme is a&#10; * global variable.&#10; *&#10; * If you want to alter the elements added by other modules or if your module&#10; * depends on the elements of other modules, use hook_page_alter() instead which&#10; * runs after this hook.&#10; *&#10; * @param $page&#10; *   Nested array of renderable elements that make up the page.&#10; *&#10; * @see hook_page_alter()&#10; * @see drupal_render_page()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_build(&amp;$page) {&#10;  if (menu_get_object('node', 1)) {&#10;    // We are on a node detail page. Append a standard disclaimer to the&#10;    // content region.&#10;    $page['content']['disclaimer'] = array(&#10;      '#markup' =&gt; t('Acme, Inc. is not responsible for the contents of this sample code.'),&#10;      '#weight' =&gt; 25,&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_page_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_page_build" value="/**&#10; * Implements hook_page_build().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_build(&amp;$page) {&#10;  if (menu_get_object('node', 1)) {&#10;    // We are on a node detail page. Append a standard disclaimer to the&#10;    // content region.&#10;    $page['content']['disclaimer'] = array(&#10;      '#markup' =&gt; t('Acme, Inc. is not responsible for the contents of this sample code.'),&#10;      '#weight' =&gt; 25,&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_page_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_get_item_alter" value="/**&#10; * Implements hook_menu_get_item_alter().&#10; *&#10; * Alter a menu router item right after it has been retrieved from the database or cache.&#10; *&#10; * This hook is invoked by menu_get_item() and allows for run-time alteration of router&#10; * information (page_callback, title, and so on) before it is translated and checked for&#10; * access. The passed-in $router_item is statically cached for the current request, so this&#10; * hook is only invoked once for any router item that is retrieved via menu_get_item().&#10; *&#10; * Usually, modules will only want to inspect the router item and conditionally&#10; * perform other actions (such as preparing a state for the current request).&#10; * Note that this hook is invoked for any router item that is retrieved by&#10; * menu_get_item(), which may or may not be called on the path itself, so implementations&#10; * should check the $path parameter if the alteration should fire for the current request&#10; * only.&#10; *&#10; * @param $router_item&#10; *   The menu router item for $path.&#10; * @param $path&#10; *   The originally passed path, for which $router_item is responsible.&#10; * @param $original_map&#10; *   The path argument map, as contained in $path.&#10; *&#10; * @see menu_get_item()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_get_item_alter(&amp;$router_item, $path, $original_map) {&#10;  // When retrieving the router item for the current path...&#10;  if ($path == $_GET['q']) {&#10;    // ...call a function that prepares something for this request.&#10;    mymodule_prepare_something();&#10;  }&#10;  $END$&#10;}" description="hook_menu_get_item_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_get_item_alter" value="/**&#10; * Implements hook_menu_get_item_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_get_item_alter(&amp;$router_item, $path, $original_map) {&#10;  // When retrieving the router item for the current path...&#10;  if ($path == $_GET['q']) {&#10;    // ...call a function that prepares something for this request.&#10;    mymodule_prepare_something();&#10;  }&#10;  $END$&#10;}" description="hook_menu_get_item_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu" value="/**&#10; * Implements hook_menu().&#10; *&#10; * Define menu items and page callbacks.&#10; *&#10; * This hook enables modules to register paths in order to define how URL&#10; * requests are handled. Paths may be registered for URL handling only, or they&#10; * can register a link to be placed in a menu (usually the Navigation menu). A&#10; * path and its associated information is commonly called a &quot;menu router item&quot;.&#10; * This hook is rarely called (for example, when modules are enabled), and&#10; * its results are cached in the database.&#10; *&#10; * hook_menu() implementations return an associative array whose keys define&#10; * paths and whose values are an associative array of properties for each&#10; * path. (The complete list of properties is in the return value section below.)&#10; *&#10; * The definition for each path may include a page callback function, which is&#10; * invoked when the registered path is requested. If there is no other&#10; * registered path that fits the requested path better, any further path&#10; * components are passed to the callback function. For example, your module&#10; * could register path 'abc/def':&#10; * @code&#10; *   function mymodule_menu() {&#10; *     $items['abc/def'] = array(&#10; *       'page callback' =&gt; 'mymodule_abc_view',&#10; *     );&#10; *     return $items;&#10; *   }&#10; *&#10; *   function mymodule_abc_view($ghi = 0, $jkl = '') {&#10; *     // ...&#10; *   }&#10; * @endcode&#10; * When path 'abc/def' is requested, no further path components are in the&#10; * request, and no additional arguments are passed to the callback function (so&#10; * $ghi and $jkl would take the default values as defined in the function&#10; * signature). When 'abc/def/123/foo' is requested, $ghi will be '123' and&#10; * $jkl will be 'foo'. Note that this automatic passing of optional path&#10; * arguments applies only to page and theme callback functions.&#10; *&#10; * In addition to optional path arguments, the page callback and other callback&#10; * functions may specify argument lists as arrays. These argument lists may&#10; * contain both fixed/hard-coded argument values and integers that correspond&#10; * to path components. When integers are used and the callback function is&#10; * called, the corresponding path components will be substituted for the&#10; * integers. That is, the integer 0 in an argument list will be replaced with&#10; * the first path component, integer 1 with the second, and so on (path&#10; * components are numbered starting from zero). To pass an integer without it&#10; * being replaced with its respective path component, use the string value of&#10; * the integer (e.g., '1') as the argument value. This substitution feature&#10; * allows you to re-use a callback function for several different paths. For&#10; * example:&#10; * @code&#10; *   function mymodule_menu() {&#10; *     $items['abc/def'] = array(&#10; *       'page callback' =&gt; 'mymodule_abc_view',&#10; *       'page arguments' =&gt; array(1, 'foo'),&#10; *     );&#10; *     return $items;&#10; *   }&#10; * @endcode&#10; * When path 'abc/def' is requested, the page callback function will get 'def'&#10; * as the first argument and (always) 'foo' as the second argument.&#10; *&#10; * If a page callback function uses an argument list array, and its path is&#10; * requested with optional path arguments, then the list array's arguments are&#10; * passed to the callback function first, followed by the optional path&#10; * arguments. Using the above example, when path 'abc/def/bar/baz' is requested,&#10; * mymodule_abc_view() will be called with 'def', 'foo', 'bar' and 'baz' as&#10; * arguments, in that order.&#10; *&#10; * Special care should be taken for the page callback drupal_get_form(), because&#10; * your specific form callback function will always receive $form and&#10; * &amp;$form_state as the first function arguments:&#10; * @code&#10; *   function mymodule_abc_form($form, &amp;$form_state) {&#10; *     // ...&#10; *     return $form;&#10; *   }&#10; * @endcode&#10; * See @link form_api Form API documentation @endlink for details.&#10; *&#10; * Wildcards within paths also work with integer substitution. For example,&#10; * your module could register path 'my-module/%/edit':&#10; * @code&#10; *   $items['my-module/%/edit'] = array(&#10; *     'page callback' =&gt; 'mymodule_abc_edit',&#10; *     'page arguments' =&gt; array(1),&#10; *   );&#10; * @endcode&#10; * When path 'my-module/foo/edit' is requested, integer 1 will be replaced&#10; * with 'foo' and passed to the callback function.&#10; *&#10; * Registered paths may also contain special &quot;auto-loader&quot; wildcard components&#10; * in the form of '%mymodule_abc', where the '%' part means that this path&#10; * component is a wildcard, and the 'mymodule_abc' part defines the prefix for a&#10; * load function, which here would be named mymodule_abc_load(). When a matching&#10; * path is requested, your load function will receive as its first argument the&#10; * path component in the position of the wildcard; load functions may also be&#10; * passed additional arguments (see &quot;load arguments&quot; in the return value&#10; * section below). For example, your module could register path&#10; * 'my-module/%mymodule_abc/edit':&#10; * @code&#10; *   $items['my-module/%mymodule_abc/edit'] = array(&#10; *     'page callback' =&gt; 'mymodule_abc_edit',&#10; *     'page arguments' =&gt; array(1),&#10; *   );&#10; * @endcode&#10; * When path 'my-module/123/edit' is requested, your load function&#10; * mymodule_abc_load() will be invoked with the argument '123', and should&#10; * load and return an &quot;abc&quot; object with internal id 123:&#10; * @code&#10; *   function mymodule_abc_load($abc_id) {&#10; *     return db_query(&quot;SELECT * FROM {mymodule_abc} WHERE abc_id = :abc_id&quot;, array(':abc_id' =&gt; $abc_id))-&gt;fetchObject();&#10; *   }&#10; * @endcode&#10; * This 'abc' object will then be passed into the callback functions defined&#10; * for the menu item, such as the page callback function mymodule_abc_edit()&#10; * to replace the integer 1 in the argument array.&#10; *&#10; * You can also define a %wildcard_to_arg() function (for the example menu&#10; * entry above this would be 'mymodule_abc_to_arg()'). The _to_arg() function&#10; * is invoked to retrieve a value that is used in the path in place of the&#10; * wildcard. A good example is user.module, which defines&#10; * user_uid_optional_to_arg() (corresponding to the menu entry&#10; * 'user/%user_uid_optional'). This function returns the user ID of the&#10; * current user.&#10; *&#10; * The _to_arg() function will get called with three arguments:&#10; * - $arg: A string representing whatever argument may have been supplied by&#10; *   the caller (this is particularly useful if you want the _to_arg()&#10; *   function only supply a (default) value if no other value is specified,&#10; *   as in the case of user_uid_optional_to_arg().&#10; * - $map: An array of all path fragments (e.g. array('node','123','edit') for&#10; *   'node/123/edit').&#10; * - $index: An integer indicating which element of $map corresponds to $arg.&#10; *&#10; * _load() and _to_arg() functions may seem similar at first glance, but they&#10; * have different purposes and are called at different times. _load()&#10; * functions are called when the menu system is collecting arguments to pass&#10; * to the callback functions defined for the menu item. _to_arg() functions&#10; * are called when the menu system is generating links to related paths, such&#10; * as the tabs for a set of MENU_LOCAL_TASK items.&#10; *&#10; * You can also make groups of menu items to be rendered (by default) as tabs&#10; * on a page. To do that, first create one menu item of type MENU_NORMAL_ITEM,&#10; * with your chosen path, such as 'foo'. Then duplicate that menu item, using a&#10; * subdirectory path, such as 'foo/tab1', and changing the type to&#10; * MENU_DEFAULT_LOCAL_TASK to make it the default tab for the group. Then add&#10; * the additional tab items, with paths such as &quot;foo/tab2&quot; etc., with type&#10; * MENU_LOCAL_TASK. Example:&#10; * @code&#10; * // Make &quot;Foo settings&quot; appear on the admin Config page&#10; * $items['admin/config/system/foo'] = array(&#10; *   'title' =&gt; 'Foo settings',&#10; *   'type' =&gt; MENU_NORMAL_ITEM,&#10; *   // Page callback, etc. need to be added here.&#10; * );&#10; * // Make &quot;Tab 1&quot; the main tab on the &quot;Foo settings&quot; page&#10; * $items['admin/config/system/foo/tab1'] = array(&#10; *   'title' =&gt; 'Tab 1',&#10; *   'type' =&gt; MENU_DEFAULT_LOCAL_TASK,&#10; *   // Access callback, page callback, and theme callback will be inherited&#10; *   // from 'admin/config/system/foo', if not specified here to override.&#10; * );&#10; * // Make an additional tab called &quot;Tab 2&quot; on &quot;Foo settings&quot;&#10; * $items['admin/config/system/foo/tab2'] = array(&#10; *   'title' =&gt; 'Tab 2',&#10; *   'type' =&gt; MENU_LOCAL_TASK,&#10; *   // Page callback and theme callback will be inherited from&#10; *   // 'admin/config/system/foo', if not specified here to override.&#10; *   // Need to add access callback or access arguments.&#10; * );&#10; * @endcode&#10; *&#10; * @return&#10; *   An array of menu items. Each menu item has a key corresponding to the&#10; *   Drupal path being registered. The corresponding array value is an&#10; *   associative array that may contain the following key-value pairs:&#10; *   - &quot;title&quot;: Required. The untranslated title of the menu item.&#10; *   - &quot;title callback&quot;: Function to generate the title; defaults to t().&#10; *     If you require only the raw string to be output, set this to FALSE.&#10; *   - &quot;title arguments&quot;: Arguments to send to t() or your custom callback,&#10; *     with path component substitution as described above.&#10; *   - &quot;description&quot;: The untranslated description of the menu item.&#10; *   - &quot;page callback&quot;: The function to call to display a web page when the user&#10; *     visits the path. If omitted, the parent menu item's callback will be used&#10; *     instead.&#10; *   - &quot;page arguments&quot;: An array of arguments to pass to the page callback&#10; *     function, with path component substitution as described above.&#10; *   - &quot;delivery callback&quot;: The function to call to package the result of the&#10; *     page callback function and send it to the browser. Defaults to&#10; *     drupal_deliver_html_page() unless a value is inherited from a parent menu&#10; *     item. Note that this function is called even if the access checks fail,&#10; *     so any custom delivery callback function should take that into account.&#10; *     See drupal_deliver_html_page() for an example.&#10; *   - &quot;access callback&quot;: A function returning TRUE if the user has access&#10; *     rights to this menu item, and FALSE if not. It can also be a boolean&#10; *     constant instead of a function, and you can also use numeric values&#10; *     (will be cast to boolean). Defaults to user_access() unless a value is&#10; *     inherited from the parent menu item; only MENU_DEFAULT_LOCAL_TASK items&#10; *     can inherit access callbacks. To use the user_access() default callback,&#10; *     you must specify the permission to check as 'access arguments' (see&#10; *     below).&#10; *   - &quot;access arguments&quot;: An array of arguments to pass to the access callback&#10; *     function, with path component substitution as described above. If the&#10; *     access callback is inherited (see above), the access arguments will be&#10; *     inherited with it, unless overridden in the child menu item.&#10; *   - &quot;theme callback&quot;: (optional) A function returning the machine-readable&#10; *     name of the theme that will be used to render the page. If not provided,&#10; *     the value will be inherited from a parent menu item. If there is no&#10; *     theme callback, or if the function does not return the name of a current&#10; *     active theme on the site, the theme for this page will be determined by&#10; *     either hook_custom_theme() or the default theme instead. As a general&#10; *     rule, the use of theme callback functions should be limited to pages&#10; *     whose functionality is very closely tied to a particular theme, since&#10; *     they can only be overridden by modules which specifically target those&#10; *     pages in hook_menu_alter(). Modules implementing more generic theme&#10; *     switching functionality (for example, a module which allows the theme to&#10; *     be set dynamically based on the current user's role) should use&#10; *     hook_custom_theme() instead.&#10; *   - &quot;theme arguments&quot;: An array of arguments to pass to the theme callback&#10; *     function, with path component substitution as described above.&#10; *   - &quot;file&quot;: A file that will be included before the page callback is called;&#10; *     this allows page callback functions to be in separate files. The file&#10; *     should be relative to the implementing module's directory unless&#10; *     otherwise specified by the &quot;file path&quot; option. Does not apply to other&#10; *     callbacks (only page callback).&#10; *   - &quot;file path&quot;: The path to the directory containing the file specified in&#10; *     &quot;file&quot;. This defaults to the path to the module implementing the hook.&#10; *   - &quot;load arguments&quot;: An array of arguments to be passed to each of the&#10; *     wildcard object loaders in the path, after the path argument itself.&#10; *     For example, if a module registers path node/%node/revisions/%/view&#10; *     with load arguments set to array(3), the '%node' in the path indicates&#10; *     that the loader function node_load() will be called with the second&#10; *     path component as the first argument. The 3 in the load arguments&#10; *     indicates that the fourth path component will also be passed to&#10; *     node_load() (numbering of path components starts at zero). So, if path&#10; *     node/12/revisions/29/view is requested, node_load(12, 29) will be called.&#10; *     There are also two &quot;magic&quot; values that can be used in load arguments.&#10; *     &quot;%index&quot; indicates the index of the wildcard path component. &quot;%map&quot;&#10; *     indicates the path components as an array. For example, if a module&#10; *     registers for several paths of the form 'user/%user_category/edit/*', all&#10; *     of them can use the same load function user_category_load(), by setting&#10; *     the load arguments to array('%map', '%index'). For instance, if the user&#10; *     is editing category 'foo' by requesting path 'user/32/edit/foo', the load&#10; *     function user_category_load() will be called with 32 as its first&#10; *     argument, the array ('user', 32, 'edit', 'foo') as the map argument,&#10; *     and 1 as the index argument (because %user_category is the second path&#10; *     component and numbering starts at zero). user_category_load() can then&#10; *     use these values to extract the information that 'foo' is the category&#10; *     being requested.&#10; *   - &quot;weight&quot;: An integer that determines the relative position of items in&#10; *     the menu; higher-weighted items sink. Defaults to 0. Menu items with the&#10; *     same weight are ordered alphabetically.&#10; *   - &quot;menu_name&quot;: Optional. Set this to a custom menu if you don't want your&#10; *     item to be placed in Navigation.&#10; *   - &quot;context&quot;: (optional) Defines the context a tab may appear in. By&#10; *     default, all tabs are only displayed as local tasks when being rendered&#10; *     in a page context. All tabs that should be accessible as contextual links&#10; *     in page region containers outside of the parent menu item's primary page&#10; *     context should be registered using one of the following contexts:&#10; *     - MENU_CONTEXT_PAGE: (default) The tab is displayed as local task for the&#10; *       page context only.&#10; *     - MENU_CONTEXT_INLINE: The tab is displayed as contextual link outside of&#10; *       the primary page context only.&#10; *     Contexts can be combined. For example, to display a tab both on a page&#10; *     and inline, a menu router item may specify:&#10; *     @code&#10; *       'context' =&gt; MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,&#10; *     @endcode&#10; *   - &quot;tab_parent&quot;: For local task menu items, the path of the task's parent&#10; *     item; defaults to the same path without the last component (e.g., the&#10; *     default parent for 'admin/people/create' is 'admin/people').&#10; *   - &quot;tab_root&quot;: For local task menu items, the path of the closest non-tab&#10; *     item; same default as &quot;tab_parent&quot;.&#10; *   - &quot;position&quot;: Position of the block ('left' or 'right') on the system&#10; *     administration page for this item.&#10; *   - &quot;type&quot;: A bitmask of flags describing properties of the menu item.&#10; *     Many shortcut bitmasks are provided as constants in menu.inc:&#10; *     - MENU_NORMAL_ITEM: Normal menu items show up in the menu tree and can be&#10; *       moved/hidden by the administrator.&#10; *     - MENU_CALLBACK: Callbacks simply register a path so that the correct&#10; *       information is generated when the path is accessed.&#10; *     - MENU_SUGGESTED_ITEM: Modules may &quot;suggest&quot; menu items that the&#10; *       administrator may enable.&#10; *     - MENU_LOCAL_ACTION: Local actions are menu items that describe actions&#10; *       on the parent item such as adding a new user or block, and are&#10; *       rendered in the action-links list in your theme.&#10; *     - MENU_LOCAL_TASK: Local tasks are menu items that describe different&#10; *       displays of data, and are generally rendered as tabs.&#10; *     - MENU_DEFAULT_LOCAL_TASK: Every set of local tasks should provide one&#10; *       &quot;default&quot; task, which should display the same page as the parent item.&#10; *     If the &quot;type&quot; element is omitted, MENU_NORMAL_ITEM is assumed.&#10; *   - &quot;options&quot;: An array of options to be passed to l() when generating a link&#10; *     from this menu item.&#10; *&#10; * For a detailed usage example, see page_example.module.&#10; * For comprehensive documentation on the menu system, see&#10; * http://drupal.org/node/102338.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu() {&#10;  $items['blog'] = array(&#10;    'title' =&gt; 'blogs',&#10;    'page callback' =&gt; 'blog_page',&#10;    'access arguments' =&gt; array('access content'),&#10;    'type' =&gt; MENU_SUGGESTED_ITEM,&#10;  );&#10;  $items['blog/feed'] = array(&#10;    'title' =&gt; 'RSS feed',&#10;    'page callback' =&gt; 'blog_feed',&#10;    'access arguments' =&gt; array('access content'),&#10;    'type' =&gt; MENU_CALLBACK,&#10;  );&#10;&#10;  return $items;&#10;  $END$&#10;}" description="hook_menu" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu" value="/**&#10; * Implements hook_menu().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu() {&#10;  $items['blog'] = array(&#10;    'title' =&gt; 'blogs',&#10;    'page callback' =&gt; 'blog_page',&#10;    'access arguments' =&gt; array('access content'),&#10;    'type' =&gt; MENU_SUGGESTED_ITEM,&#10;  );&#10;  $items['blog/feed'] = array(&#10;    'title' =&gt; 'RSS feed',&#10;    'page callback' =&gt; 'blog_feed',&#10;    'access arguments' =&gt; array('access content'),&#10;    'type' =&gt; MENU_CALLBACK,&#10;  );&#10;&#10;  return $items;&#10;  $END$&#10;}" description="hook_menu" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_alter" value="/**&#10; * Implements hook_menu_alter().&#10; *&#10; * Alter the data being saved to the {menu_router} table after hook_menu is invoked.&#10; *&#10; * This hook is invoked by menu_router_build(). The menu definitions are passed&#10; * in by reference. Each element of the $items array is one item returned&#10; * by a module from hook_menu. Additional items may be added, or existing items&#10; * altered.&#10; *&#10; * @param $items&#10; *   Associative array of menu router definitions returned from hook_menu().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_alter(&amp;$items) {&#10;  // Example - disable the page at node/add&#10;  $items['node/add']['access callback'] = FALSE;&#10;  $END$&#10;}" description="hook_menu_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_alter" value="/**&#10; * Implements hook_menu_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_alter(&amp;$items) {&#10;  // Example - disable the page at node/add&#10;  $items['node/add']['access callback'] = FALSE;&#10;  $END$&#10;}" description="hook_menu_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_link_alter" value="/**&#10; * Implements hook_menu_link_alter().&#10; *&#10; * Alter the data being saved to the {menu_links} table by menu_link_save().&#10; *&#10; * @param $item&#10; *   Associative array defining a menu link as passed into menu_link_save().&#10; *&#10; * @see hook_translated_menu_link_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_alter(&amp;$item) {&#10;  // Make all new admin links hidden (a.k.a disabled).&#10;  if (strpos($item['link_path'], 'admin') === 0 &amp;&amp; empty($item['mlid'])) {&#10;    $item['hidden'] = 1;&#10;  }&#10;  // Flag a link to be altered by hook_translated_menu_link_alter().&#10;  if ($item['link_path'] == 'devel/cache/clear') {&#10;    $item['options']['alter'] = TRUE;&#10;  }&#10;  // Flag a link to be altered by hook_translated_menu_link_alter(), but only&#10;  // if it is derived from a menu router item; i.e., do not alter a custom&#10;  // menu link pointing to the same path that has been created by a user.&#10;  if ($item['link_path'] == 'user' &amp;&amp; $item['module'] == 'system') {&#10;    $item['options']['alter'] = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_menu_link_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_link_alter" value="/**&#10; * Implements hook_menu_link_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_alter(&amp;$item) {&#10;  // Make all new admin links hidden (a.k.a disabled).&#10;  if (strpos($item['link_path'], 'admin') === 0 &amp;&amp; empty($item['mlid'])) {&#10;    $item['hidden'] = 1;&#10;  }&#10;  // Flag a link to be altered by hook_translated_menu_link_alter().&#10;  if ($item['link_path'] == 'devel/cache/clear') {&#10;    $item['options']['alter'] = TRUE;&#10;  }&#10;  // Flag a link to be altered by hook_translated_menu_link_alter(), but only&#10;  // if it is derived from a menu router item; i.e., do not alter a custom&#10;  // menu link pointing to the same path that has been created by a user.&#10;  if ($item['link_path'] == 'user' &amp;&amp; $item['module'] == 'system') {&#10;    $item['options']['alter'] = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_menu_link_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_translated_menu_link_alter" value="/**&#10; * Implements hook_translated_menu_link_alter().&#10; *&#10; * Alter a menu link after it has been translated and before it is rendered.&#10; *&#10; * This hook is invoked from _menu_link_translate() after a menu link has been&#10; * translated; i.e., after dynamic path argument placeholders (%) have been&#10; * replaced with actual values, the user access to the link's target page has&#10; * been checked, and the link has been localized. It is only invoked if&#10; * $item['options']['alter'] has been set to a non-empty value (e.g., TRUE).&#10; * This flag should be set using hook_menu_link_alter().&#10; *&#10; * Implementations of this hook are able to alter any property of the menu link.&#10; * For example, this hook may be used to add a page-specific query string to all&#10; * menu links, or hide a certain link by setting:&#10; * @code&#10; *   'hidden' =&gt; 1,&#10; * @endcode&#10; *&#10; * @param $item&#10; *   Associative array defining a menu link after _menu_link_translate()&#10; * @param $map&#10; *   Associative array containing the menu $map (path parts and/or objects).&#10; *&#10; * @see hook_menu_link_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_translated_menu_link_alter(&amp;$item, $map) {&#10;  if ($item['href'] == 'devel/cache/clear') {&#10;    $item['localized_options']['query'] = drupal_get_destination();&#10;  }&#10;  $END$&#10;}" description="hook_translated_menu_link_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_translated_menu_link_alter" value="/**&#10; * Implements hook_translated_menu_link_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_translated_menu_link_alter(&amp;$item, $map) {&#10;  if ($item['href'] == 'devel/cache/clear') {&#10;    $item['localized_options']['query'] = drupal_get_destination();&#10;  }&#10;  $END$&#10;}" description="hook_translated_menu_link_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_link_insert" value="/**&#10; * Implements hook_menu_link_insert().&#10; *&#10; * Inform modules that a menu link has been created.&#10; *&#10; * This hook is used to notify modules that menu items have been&#10; * created. Contributed modules may use the information to perform&#10; * actions based on the information entered into the menu system.&#10; *&#10; * @param $link&#10; *   Associative array defining a menu link as passed into menu_link_save().&#10; *&#10; * @see hook_menu_link_update()&#10; * @see hook_menu_link_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_insert($link) {&#10;  // In our sample case, we track menu items as editing sections&#10;  // of the site. These are stored in our table as 'disabled' items.&#10;  $record['mlid'] = $link['mlid'];&#10;  $record['menu_name'] = $link['menu_name'];&#10;  $record['status'] = 0;&#10;  drupal_write_record('menu_example', $record);&#10;  $END$&#10;}" description="hook_menu_link_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_link_insert" value="/**&#10; * Implements hook_menu_link_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_insert($link) {&#10;  // In our sample case, we track menu items as editing sections&#10;  // of the site. These are stored in our table as 'disabled' items.&#10;  $record['mlid'] = $link['mlid'];&#10;  $record['menu_name'] = $link['menu_name'];&#10;  $record['status'] = 0;&#10;  drupal_write_record('menu_example', $record);&#10;  $END$&#10;}" description="hook_menu_link_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_link_update" value="/**&#10; * Implements hook_menu_link_update().&#10; *&#10; * Inform modules that a menu link has been updated.&#10; *&#10; * This hook is used to notify modules that menu items have been&#10; * updated. Contributed modules may use the information to perform&#10; * actions based on the information entered into the menu system.&#10; *&#10; * @param $link&#10; *   Associative array defining a menu link as passed into menu_link_save().&#10; *&#10; * @see hook_menu_link_insert()&#10; * @see hook_menu_link_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_update($link) {&#10;  // If the parent menu has changed, update our record.&#10;  $menu_name = db_query(&quot;SELECT menu_name FROM {menu_example} WHERE mlid = :mlid&quot;, array(':mlid' =&gt; $link['mlid']))-&gt;fetchField();&#10;  if ($menu_name != $link['menu_name']) {&#10;    db_update('menu_example')&#10;      -&gt;fields(array('menu_name' =&gt; $link['menu_name']))&#10;      -&gt;condition('mlid', $link['mlid'])&#10;      -&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_menu_link_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_link_update" value="/**&#10; * Implements hook_menu_link_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_update($link) {&#10;  // If the parent menu has changed, update our record.&#10;  $menu_name = db_query(&quot;SELECT menu_name FROM {menu_example} WHERE mlid = :mlid&quot;, array(':mlid' =&gt; $link['mlid']))-&gt;fetchField();&#10;  if ($menu_name != $link['menu_name']) {&#10;    db_update('menu_example')&#10;      -&gt;fields(array('menu_name' =&gt; $link['menu_name']))&#10;      -&gt;condition('mlid', $link['mlid'])&#10;      -&gt;execute();&#10;  }&#10;  $END$&#10;}" description="hook_menu_link_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_link_delete" value="/**&#10; * Implements hook_menu_link_delete().&#10; *&#10; * Inform modules that a menu link has been deleted.&#10; *&#10; * This hook is used to notify modules that menu items have been&#10; * deleted. Contributed modules may use the information to perform&#10; * actions based on the information entered into the menu system.&#10; *&#10; * @param $link&#10; *   Associative array defining a menu link as passed into menu_link_save().&#10; *&#10; * @see hook_menu_link_insert()&#10; * @see hook_menu_link_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_delete($link) {&#10;  // Delete the record from our table.&#10;  db_delete('menu_example')&#10;    -&gt;condition('mlid', $link['mlid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_menu_link_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_link_delete" value="/**&#10; * Implements hook_menu_link_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_link_delete($link) {&#10;  // Delete the record from our table.&#10;  db_delete('menu_example')&#10;    -&gt;condition('mlid', $link['mlid'])&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_menu_link_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_local_tasks_alter" value="/**&#10; * Implements hook_menu_local_tasks_alter().&#10; *&#10; * Alter tabs and actions displayed on the page before they are rendered.&#10; *&#10; * This hook is invoked by menu_local_tasks(). The system-determined tabs and&#10; * actions are passed in by reference. Additional tabs or actions may be added,&#10; * or existing items altered.&#10; *&#10; * Each tab or action is an associative array containing:&#10; * - #theme: The theme function to use to render.&#10; * - #link: An associative array containing:&#10; *   - title: The localized title of the link.&#10; *   - href: The system path to link to.&#10; *   - localized_options: An array of options to pass to url().&#10; * - #active: Whether the link should be marked as 'active'.&#10; *&#10; * @param $data&#10; *   An associative array containing:&#10; *   - actions: An associative array containing:&#10; *     - count: The amount of actions determined by the menu system, which can&#10; *       be ignored.&#10; *     - output: A list of of actions, each one being an associative array&#10; *       as described above.&#10; *   - tabs: An indexed array (list) of tab levels (up to 2 levels), each&#10; *     containing an associative array:&#10; *     - count: The amount of tabs determined by the menu system. This value&#10; *       does not need to be altered if there is more than one tab.&#10; *     - output: A list of of tabs, each one being an associative array as&#10; *       described above.&#10; * @param $router_item&#10; *   The menu system router item of the page.&#10; * @param $root_path&#10; *   The path to the root item for this set of tabs.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_local_tasks_alter(&amp;$data, $router_item, $root_path) {&#10;  // Add an action linking to node/add to all pages.&#10;  $data['actions']['output'][] = array(&#10;    '#theme' =&gt; 'menu_local_task',&#10;    '#link' =&gt; array(&#10;      'title' =&gt; t('Add new content'),&#10;      'href' =&gt; 'node/add',&#10;      'localized_options' =&gt; array(&#10;        'attributes' =&gt; array(&#10;          'title' =&gt; t('Add new content'),&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;&#10;  // Add a tab linking to node/add to all pages.&#10;  $data['tabs'][0]['output'][] = array(&#10;    '#theme' =&gt; 'menu_local_task',&#10;    '#link' =&gt; array(&#10;      'title' =&gt; t('Example tab'),&#10;      'href' =&gt; 'node/add',&#10;      'localized_options' =&gt; array(&#10;        'attributes' =&gt; array(&#10;          'title' =&gt; t('Add new content'),&#10;        ),&#10;      ),&#10;    ),&#10;    // Define whether this link is active. This can be omitted for&#10;    // implementations that add links to pages outside of the current page&#10;    // context.&#10;    '#active' =&gt; ($router_item['path'] == $root_path),&#10;  );&#10;  $END$&#10;}" description="hook_menu_local_tasks_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_local_tasks_alter" value="/**&#10; * Implements hook_menu_local_tasks_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_local_tasks_alter(&amp;$data, $router_item, $root_path) {&#10;  // Add an action linking to node/add to all pages.&#10;  $data['actions']['output'][] = array(&#10;    '#theme' =&gt; 'menu_local_task',&#10;    '#link' =&gt; array(&#10;      'title' =&gt; t('Add new content'),&#10;      'href' =&gt; 'node/add',&#10;      'localized_options' =&gt; array(&#10;        'attributes' =&gt; array(&#10;          'title' =&gt; t('Add new content'),&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;&#10;  // Add a tab linking to node/add to all pages.&#10;  $data['tabs'][0]['output'][] = array(&#10;    '#theme' =&gt; 'menu_local_task',&#10;    '#link' =&gt; array(&#10;      'title' =&gt; t('Example tab'),&#10;      'href' =&gt; 'node/add',&#10;      'localized_options' =&gt; array(&#10;        'attributes' =&gt; array(&#10;          'title' =&gt; t('Add new content'),&#10;        ),&#10;      ),&#10;    ),&#10;    // Define whether this link is active. This can be omitted for&#10;    // implementations that add links to pages outside of the current page&#10;    // context.&#10;    '#active' =&gt; ($router_item['path'] == $root_path),&#10;  );&#10;  $END$&#10;}" description="hook_menu_local_tasks_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_breadcrumb_alter" value="/**&#10; * Implements hook_menu_breadcrumb_alter().&#10; *&#10; * Alter links in the active trail before it is rendered as the breadcrumb.&#10; *&#10; * This hook is invoked by menu_get_active_breadcrumb() and allows alteration&#10; * of the breadcrumb links for the current page, which may be preferred instead&#10; * of setting a custom breadcrumb via drupal_set_breadcrumb().&#10; *&#10; * Implementations should take into account that menu_get_active_breadcrumb()&#10; * subsequently performs the following adjustments to the active trail *after*&#10; * this hook has been invoked:&#10; * - The last link in $active_trail is removed, if its 'href' is identical to&#10; *   the 'href' of $item. This happens, because the breadcrumb normally does&#10; *   not contain a link to the current page.&#10; * - The (second to) last link in $active_trail is removed, if the current $item&#10; *   is a MENU_DEFAULT_LOCAL_TASK. This happens in order to do not show a link&#10; *   to the current page, when being on the path for the default local task;&#10; *   e.g. when being on the path node/%/view, the breadcrumb should not contain&#10; *   a link to node/%.&#10; *&#10; * Each link in the active trail must contain:&#10; * - title: The localized title of the link.&#10; * - href: The system path to link to.&#10; * - localized_options: An array of options to pass to url().&#10; *&#10; * @param $active_trail&#10; *   An array containing breadcrumb links for the current page.&#10; * @param $item&#10; *   The menu router item of the current page.&#10; *&#10; * @see drupal_set_breadcrumb()&#10; * @see menu_get_active_breadcrumb()&#10; * @see menu_get_active_trail()&#10; * @see menu_set_active_trail()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_breadcrumb_alter(&amp;$active_trail, $item) {&#10;  // Always display a link to the current page by duplicating the last link in&#10;  // the active trail. This means that menu_get_active_breadcrumb() will remove&#10;  // the last link (for the current page), but since it is added once more here,&#10;  // it will appear.&#10;  if (!drupal_is_front_page()) {&#10;    $end = end($active_trail);&#10;    if ($item['href'] == $end['href']) {&#10;      $active_trail[] = $end;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_menu_breadcrumb_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_breadcrumb_alter" value="/**&#10; * Implements hook_menu_breadcrumb_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_breadcrumb_alter(&amp;$active_trail, $item) {&#10;  // Always display a link to the current page by duplicating the last link in&#10;  // the active trail. This means that menu_get_active_breadcrumb() will remove&#10;  // the last link (for the current page), but since it is added once more here,&#10;  // it will appear.&#10;  if (!drupal_is_front_page()) {&#10;    $end = end($active_trail);&#10;    if ($item['href'] == $end['href']) {&#10;      $active_trail[] = $end;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_menu_breadcrumb_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_contextual_links_alter" value="/**&#10; * Implements hook_menu_contextual_links_alter().&#10; *&#10; * Alter contextual links before they are rendered.&#10; *&#10; * This hook is invoked by menu_contextual_links(). The system-determined&#10; * contextual links are passed in by reference. Additional links may be added&#10; * or existing links can be altered.&#10; *&#10; * Each contextual link must at least contain:&#10; * - title: The localized title of the link.&#10; * - href: The system path to link to.&#10; * - localized_options: An array of options to pass to url().&#10; *&#10; * @param $links&#10; *   An associative array containing contextual links for the given $root_path,&#10; *   as described above. The array keys are used to build CSS class names for&#10; *   contextual links and must therefore be unique for each set of contextual&#10; *   links.&#10; * @param $router_item&#10; *   The menu router item belonging to the $root_path being requested.&#10; * @param $root_path&#10; *   The (parent) path that has been requested to build contextual links for.&#10; *   This is a normalized path, which means that an originally passed path of&#10; *   'node/123' became 'node/%'.&#10; *&#10; * @see hook_contextual_links_view_alter()&#10; * @see menu_contextual_links()&#10; * @see hook_menu()&#10; * @see contextual_preprocess()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_contextual_links_alter(&amp;$links, $router_item, $root_path) {&#10;  // Add a link to all contextual links for nodes.&#10;  if ($root_path == 'node/%') {&#10;    $links['foo'] = array(&#10;      'title' =&gt; t('Do fu'),&#10;      'href' =&gt; 'foo/do',&#10;      'localized_options' =&gt; array(&#10;        'query' =&gt; array(&#10;          'foo' =&gt; 'bar',&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_menu_contextual_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_contextual_links_alter" value="/**&#10; * Implements hook_menu_contextual_links_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_contextual_links_alter(&amp;$links, $router_item, $root_path) {&#10;  // Add a link to all contextual links for nodes.&#10;  if ($root_path == 'node/%') {&#10;    $links['foo'] = array(&#10;      'title' =&gt; t('Do fu'),&#10;      'href' =&gt; 'foo/do',&#10;      'localized_options' =&gt; array(&#10;        'query' =&gt; array(&#10;          'foo' =&gt; 'bar',&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_menu_contextual_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_page_alter" value="/**&#10; * Implements hook_page_alter().&#10; *&#10; * Perform alterations before a page is rendered.&#10; *&#10; * Use this hook when you want to remove or alter elements at the page&#10; * level, or add elements at the page level that depend on an other module's&#10; * elements (this hook runs after hook_page_build().&#10; *&#10; * If you are making changes to entities such as forms, menus, or user&#10; * profiles, use those objects' native alter hooks instead (hook_form_alter(),&#10; * for example).&#10; *&#10; * The $page array contains top level elements for each block region:&#10; * @code&#10; *   $page['page_top']&#10; *   $page['header']&#10; *   $page['sidebar_first']&#10; *   $page['content']&#10; *   $page['sidebar_second']&#10; *   $page['page_bottom']&#10; * @endcode&#10; *&#10; * The 'content' element contains the main content of the current page, and its&#10; * structure will vary depending on what module is responsible for building the&#10; * page. Some legacy modules may not return structured content at all: their&#10; * pre-rendered markup will be located in $page['content']['main']['#markup'].&#10; *&#10; * Pages built by Drupal's core Node and Blog modules use a standard structure:&#10; *&#10; * @code&#10; *   // Node body.&#10; *   $page['content']['system_main']['nodes'][$nid]['body']&#10; *   // Array of links attached to the node (add comments, read more).&#10; *   $page['content']['system_main']['nodes'][$nid]['links']&#10; *   // The node object itself.&#10; *   $page['content']['system_main']['nodes'][$nid]['#node']&#10; *   // The results pager.&#10; *   $page['content']['system_main']['pager']&#10; * @endcode&#10; *&#10; * Blocks may be referenced by their module/delta pair within a region:&#10; * @code&#10; *   // The login block in the first sidebar region.&#10; *   $page['sidebar_first']['user_login']['#block'];&#10; * @endcode&#10; *&#10; * @param $page&#10; *   Nested array of renderable elements that make up the page.&#10; *&#10; * @see hook_page_build()&#10; * @see drupal_render_page()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_alter(&amp;$page) {&#10;  // Add help text to the user login block.&#10;  $page['sidebar_first']['user_login']['help'] = array(&#10;    '#weight' =&gt; -10,&#10;    '#markup' =&gt; t('To post comments or add new content, you first have to log in.'),&#10;  );&#10;  $END$&#10;}" description="hook_page_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_page_alter" value="/**&#10; * Implements hook_page_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_alter(&amp;$page) {&#10;  // Add help text to the user login block.&#10;  $page['sidebar_first']['user_login']['help'] = array(&#10;    '#weight' =&gt; -10,&#10;    '#markup' =&gt; t('To post comments or add new content, you first have to log in.'),&#10;  );&#10;  $END$&#10;}" description="hook_page_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_form_alter" value="/**&#10; * Implements hook_form_alter().&#10; *&#10; * Perform alterations before a form is rendered.&#10; *&#10; * One popular use of this hook is to add form elements to the node form. When&#10; * altering a node form, the node object can be accessed at $form['#node'].&#10; *&#10; * Note that instead of hook_form_alter(), which is called for all forms, you&#10; * can also use hook_form_FORM_ID_alter() to alter a specific form. For each&#10; * module (in system weight order) the general form alter hook implementation&#10; * is invoked first, then the form ID specific alter implementation is called.&#10; * After all module hook implementations are invoked, the hook_form_alter()&#10; * implementations from themes are invoked in the same manner.&#10; *&#10; * @param $form&#10; *   Nested array of form elements that comprise the form.&#10; * @param $form_state&#10; *   A keyed array containing the current state of the form. The arguments&#10; *   that drupal_get_form() was originally called with are available in the&#10; *   array $form_state['build_info']['args'].&#10; * @param $form_id&#10; *   String representing the name of the form itself. Typically this is the&#10; *   name of the function that generated the form.&#10; *&#10; * @see hook_form_FORM_ID_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  if (isset($form['type']) &amp;&amp; $form['type']['#value'] . '_node_settings' == $form_id) {&#10;    $form['workflow']['upload_' . $form['type']['#value']] = array(&#10;      '#type' =&gt; 'radios',&#10;      '#title' =&gt; t('Attachments'),&#10;      '#default_value' =&gt; variable_get('upload_' . $form['type']['#value'], 1),&#10;      '#options' =&gt; array(t('Disabled'), t('Enabled')),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_form_alter" value="/**&#10; * Implements hook_form_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  if (isset($form['type']) &amp;&amp; $form['type']['#value'] . '_node_settings' == $form_id) {&#10;    $form['workflow']['upload_' . $form['type']['#value']] = array(&#10;      '#type' =&gt; 'radios',&#10;      '#title' =&gt; t('Attachments'),&#10;      '#default_value' =&gt; variable_get('upload_' . $form['type']['#value'], 1),&#10;      '#options' =&gt; array(t('Disabled'), t('Enabled')),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_form_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_form_FORM_ID_alter" value="/**&#10; * Implements hook_form_FORM_ID_alter().&#10; *&#10; * Provide a form-specific alteration instead of the global hook_form_alter().&#10; *&#10; * Modules can implement hook_form_FORM_ID_alter() to modify a specific form,&#10; * rather than implementing hook_form_alter() and checking the form ID, or&#10; * using long switch statements to alter multiple forms.&#10; *&#10; * @param $form&#10; *   Nested array of form elements that comprise the form.&#10; * @param $form_state&#10; *   A keyed array containing the current state of the form. The arguments&#10; *   that drupal_get_form() was originally called with are available in the&#10; *   array $form_state['build_info']['args'].&#10; * @param $form_id&#10; *   String representing the name of the form itself. Typically this is the&#10; *   name of the function that generated the form.&#10; *&#10; * @see hook_form_alter()&#10; * @see drupal_prepare_form()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_FORM_ID_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  // Modification for the form with the given form ID goes here. For example, if&#10;  // FORM_ID is &quot;user_register_form&quot; this code would run only on the user&#10;  // registration form.&#10;&#10;  // Add a checkbox to registration form about agreeing to terms of use.&#10;  $form['terms_of_use'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;I agree with the website's terms and conditions.&quot;),&#10;    '#required' =&gt; TRUE,&#10;  );&#10;  $END$&#10;}" description="hook_form_FORM_ID_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_form_FORM_ID_alter" value="/**&#10; * Implements hook_form_FORM_ID_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_FORM_ID_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  // Modification for the form with the given form ID goes here. For example, if&#10;  // FORM_ID is &quot;user_register_form&quot; this code would run only on the user&#10;  // registration form.&#10;&#10;  // Add a checkbox to registration form about agreeing to terms of use.&#10;  $form['terms_of_use'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;I agree with the website's terms and conditions.&quot;),&#10;    '#required' =&gt; TRUE,&#10;  );&#10;  $END$&#10;}" description="hook_form_FORM_ID_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_form_BASE_FORM_ID_alter" value="/**&#10; * Implements hook_form_BASE_FORM_ID_alter().&#10; *&#10; * Provide a form-specific alteration for shared forms.&#10; *&#10; * Modules can implement hook_form_BASE_FORM_ID_alter() to modify a specific&#10; * form belonging to multiple form_ids, rather than implementing&#10; * hook_form_alter() and checking for conditions that would identify the&#10; * shared form constructor.&#10; *&#10; * Examples for such forms are node_form() or comment_form().&#10; *&#10; * Note that this hook fires after hook_form_FORM_ID_alter() and before&#10; * hook_form_alter().&#10; *&#10; * @param $form&#10; *   Nested array of form elements that comprise the form.&#10; * @param $form_state&#10; *   A keyed array containing the current state of the form.&#10; * @param $form_id&#10; *   String representing the name of the form itself. Typically this is the&#10; *   name of the function that generated the form.&#10; *&#10; * @see hook_form_FORM_ID_alter()&#10; * @see drupal_prepare_form()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_BASE_FORM_ID_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  // Modification for the form with the given BASE_FORM_ID goes here. For&#10;  // example, if BASE_FORM_ID is &quot;node_form&quot;, this code would run on every&#10;  // node form, regardless of node type.&#10;&#10;  // Add a checkbox to the node form about agreeing to terms of use.&#10;  $form['terms_of_use'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;I agree with the website's terms and conditions.&quot;),&#10;    '#required' =&gt; TRUE,&#10;  );&#10;  $END$&#10;}" description="hook_form_BASE_FORM_ID_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_form_BASE_FORM_ID_alter" value="/**&#10; * Implements hook_form_BASE_FORM_ID_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_BASE_FORM_ID_alter(&amp;$form, &amp;$form_state, $form_id) {&#10;  // Modification for the form with the given BASE_FORM_ID goes here. For&#10;  // example, if BASE_FORM_ID is &quot;node_form&quot;, this code would run on every&#10;  // node form, regardless of node type.&#10;&#10;  // Add a checkbox to the node form about agreeing to terms of use.&#10;  $form['terms_of_use'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t(&quot;I agree with the website's terms and conditions.&quot;),&#10;    '#required' =&gt; TRUE,&#10;  );&#10;  $END$&#10;}" description="hook_form_BASE_FORM_ID_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_forms" value="/**&#10; * Implements hook_forms().&#10; *&#10; * Map form_ids to form builder functions.&#10; *&#10; * By default, when drupal_get_form() is called, the system will look for a&#10; * function with the same name as the form ID, and use that function to build&#10; * the form. This hook allows you to override that behavior in two ways.&#10; *&#10; * First, you can use this hook to tell the form system to use a different&#10; * function to build certain forms in your module; this is often used to define&#10; * a form &quot;factory&quot; function that is used to build several similar forms. In&#10; * this case, your hook implementation will likely ignore all of the input&#10; * arguments. See node_forms() for an example of this.&#10; *&#10; * Second, you could use this hook to define how to build a form with a&#10; * dynamically-generated form ID. In this case, you would need to verify that&#10; * the $form_id input matched your module's format for dynamically-generated&#10; * form IDs, and if so, act appropriately.&#10; *&#10; * @param $form_id&#10; *   The unique string identifying the desired form.&#10; * @param $args&#10; *   An array containing the original arguments provided to drupal_get_form()&#10; *   or drupal_form_submit(). These are always passed to the form builder and&#10; *   do not have to be specified manually in 'callback arguments'.&#10; *&#10; * @return&#10; *   An associative array whose keys define form_ids and whose values are an&#10; *   associative array defining the following keys:&#10; *   - callback: The name of the form builder function to invoke.&#10; *   - callback arguments: (optional) Additional arguments to pass to the&#10; *     function defined in 'callback', which are prepended to $args.&#10; *   - wrapper_callback: (optional) The name of a form builder function to&#10; *     invoke before the form builder defined in 'callback' is invoked. This&#10; *     wrapper callback may prepopulate the $form array with form elements,&#10; *     which will then be already contained in the $form that is passed on to&#10; *     the form builder defined in 'callback'. For example, a wrapper callback&#10; *     could setup wizard-alike form buttons that are the same for a variety of&#10; *     forms that belong to the wizard, which all share the same wrapper&#10; *     callback.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_forms($form_id, $args) {&#10;  // Simply reroute the (non-existing) $form_id 'mymodule_first_form' to&#10;  // 'mymodule_main_form'.&#10;  $forms['mymodule_first_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;  );&#10;&#10;  // Reroute the $form_id and prepend an additional argument that gets passed to&#10;  // the 'mymodule_main_form' form builder function.&#10;  $forms['mymodule_second_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;    'callback arguments' =&gt; array('some parameter'),&#10;  );&#10;&#10;  // Reroute the $form_id, but invoke the form builder function&#10;  // 'mymodule_main_form_wrapper' first, so we can prepopulate the $form array&#10;  // that is passed to the actual form builder 'mymodule_main_form'.&#10;  $forms['mymodule_wrapped_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;    'wrapper_callback' =&gt; 'mymodule_main_form_wrapper',&#10;  );&#10;&#10;  return $forms;&#10;  $END$&#10;}" description="hook_forms" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_forms" value="/**&#10; * Implements hook_forms().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_forms($form_id, $args) {&#10;  // Simply reroute the (non-existing) $form_id 'mymodule_first_form' to&#10;  // 'mymodule_main_form'.&#10;  $forms['mymodule_first_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;  );&#10;&#10;  // Reroute the $form_id and prepend an additional argument that gets passed to&#10;  // the 'mymodule_main_form' form builder function.&#10;  $forms['mymodule_second_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;    'callback arguments' =&gt; array('some parameter'),&#10;  );&#10;&#10;  // Reroute the $form_id, but invoke the form builder function&#10;  // 'mymodule_main_form_wrapper' first, so we can prepopulate the $form array&#10;  // that is passed to the actual form builder 'mymodule_main_form'.&#10;  $forms['mymodule_wrapped_form'] = array(&#10;    'callback' =&gt; 'mymodule_main_form',&#10;    'wrapper_callback' =&gt; 'mymodule_main_form_wrapper',&#10;  );&#10;&#10;  return $forms;&#10;  $END$&#10;}" description="hook_forms" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_boot" value="/**&#10; * Implements hook_boot().&#10; *&#10; * Perform setup tasks for all page requests.&#10; *&#10; * This hook is run at the beginning of the page request. It is typically&#10; * used to set up global parameters that are needed later in the request.&#10; *&#10; * Only use this hook if your code must run even for cached page views. This&#10; * hook is called before modules or most include files are loaded into memory.&#10; * It happens while Drupal is still in bootstrap mode.&#10; *&#10; * @see hook_init()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_boot() {&#10;  // We need user_access() in the shutdown function. Make sure it gets loaded.&#10;  drupal_load('module', 'user');&#10;  drupal_register_shutdown_function('devel_shutdown');&#10;  $END$&#10;}" description="hook_boot" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_boot" value="/**&#10; * Implements hook_boot().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_boot() {&#10;  // We need user_access() in the shutdown function. Make sure it gets loaded.&#10;  drupal_load('module', 'user');&#10;  drupal_register_shutdown_function('devel_shutdown');&#10;  $END$&#10;}" description="hook_boot" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_init" value="/**&#10; * Implements hook_init().&#10; *&#10; * Perform setup tasks for non-cached page requests.&#10; *&#10; * This hook is run at the beginning of the page request. It is typically&#10; * used to set up global parameters that are needed later in the request.&#10; * When this hook is called, all modules are already loaded in memory.&#10; *&#10; * This hook is not run on cached pages.&#10; *&#10; * To add CSS or JS that should be present on all pages, modules should not&#10; * implement this hook, but declare these files in their .info file.&#10; *&#10; * @see hook_boot()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_init() {&#10;  // Since this file should only be loaded on the front page, it cannot be&#10;  // declared in the info file.&#10;  if (drupal_is_front_page()) {&#10;    drupal_add_css(drupal_get_path('module', 'foo') . '/foo.css');&#10;  }&#10;  $END$&#10;}" description="hook_init" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_init" value="/**&#10; * Implements hook_init().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_init() {&#10;  // Since this file should only be loaded on the front page, it cannot be&#10;  // declared in the info file.&#10;  if (drupal_is_front_page()) {&#10;    drupal_add_css(drupal_get_path('module', 'foo') . '/foo.css');&#10;  }&#10;  $END$&#10;}" description="hook_init" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_image_toolkits" value="/**&#10; * Implements hook_image_toolkits().&#10; *&#10; * Define image toolkits provided by this module.&#10; *&#10; * The file which includes each toolkit's functions must be declared as part of&#10; * the files array in the module .info file so that the registry will find and&#10; * parse it.&#10; *&#10; * The toolkit's functions must be named image_toolkitname_operation().&#10; * where the operation may be:&#10; *   - 'load': Required. See image_gd_load() for usage.&#10; *   - 'save': Required. See image_gd_save() for usage.&#10; *   - 'settings': Optional. See image_gd_settings() for usage.&#10; *   - 'resize': Optional. See image_gd_resize() for usage.&#10; *   - 'rotate': Optional. See image_gd_rotate() for usage.&#10; *   - 'crop': Optional. See image_gd_crop() for usage.&#10; *   - 'desaturate': Optional. See image_gd_desaturate() for usage.&#10; *&#10; * @return&#10; *   An array with the toolkit name as keys and sub-arrays with these keys:&#10; *     - 'title': A string with the toolkit's title.&#10; *     - 'available': A Boolean value to indicate that the toolkit is operating&#10; *       properly, e.g. all required libraries exist.&#10; *&#10; * @see system_image_toolkits()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_toolkits() {&#10;  return array(&#10;    'working' =&gt; array(&#10;      'title' =&gt; t('A toolkit that works.'),&#10;      'available' =&gt; TRUE,&#10;    ),&#10;    'broken' =&gt; array(&#10;      'title' =&gt; t('A toolkit that is &quot;broken&quot; and will not be listed.'),&#10;      'available' =&gt; FALSE,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_image_toolkits" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_image_toolkits" value="/**&#10; * Implements hook_image_toolkits().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_image_toolkits() {&#10;  return array(&#10;    'working' =&gt; array(&#10;      'title' =&gt; t('A toolkit that works.'),&#10;      'available' =&gt; TRUE,&#10;    ),&#10;    'broken' =&gt; array(&#10;      'title' =&gt; t('A toolkit that is &quot;broken&quot; and will not be listed.'),&#10;      'available' =&gt; FALSE,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_image_toolkits" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_mail_alter" value="/**&#10; * Implements hook_mail_alter().&#10; *&#10; * Alter an email message created with the drupal_mail() function.&#10; *&#10; * hook_mail_alter() allows modification of email messages created and sent&#10; * with drupal_mail(). Usage examples include adding and/or changing message&#10; * text, message fields, and message headers.&#10; *&#10; * Email messages sent using functions other than drupal_mail() will not&#10; * invoke hook_mail_alter(). For example, a contributed module directly&#10; * calling the drupal_mail_system()-&gt;mail() or PHP mail() function&#10; * will not invoke this hook. All core modules use drupal_mail() for&#10; * messaging, it is best practice but not mandatory in contributed modules.&#10; *&#10; * @param $message&#10; *   An array containing the message data. Keys in this array include:&#10; *  - 'id':&#10; *     The drupal_mail() id of the message. Look at module source code or&#10; *     drupal_mail() for possible id values.&#10; *  - 'to':&#10; *     The address or addresses the message will be sent to. The&#10; *     formatting of this string must comply with RFC 2822.&#10; *  - 'from':&#10; *     The address the message will be marked as being from, which is&#10; *     either a custom address or the site-wide default email address.&#10; *  - 'subject':&#10; *     Subject of the email to be sent. This must not contain any newline&#10; *     characters, or the email may not be sent properly.&#10; *  - 'body':&#10; *     An array of strings containing the message text. The message body is&#10; *     created by concatenating the individual array strings into a single text&#10; *     string using &quot;\n\n&quot; as a separator.&#10; *  - 'headers':&#10; *     Associative array containing mail headers, such as From, Sender,&#10; *     MIME-Version, Content-Type, etc.&#10; *  - 'params':&#10; *     An array of optional parameters supplied by the caller of drupal_mail()&#10; *     that is used to build the message before hook_mail_alter() is invoked.&#10; *  - 'language':&#10; *     The language object used to build the message before hook_mail_alter()&#10; *     is invoked.&#10; *&#10; * @see drupal_mail()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_mail_alter(&amp;$message) {&#10;  if ($message['id'] == 'modulename_messagekey') {&#10;    $message['body'][] = &quot;--\nMail sent out from &quot; . variable_get('sitename', t('Drupal'));&#10;  }&#10;  $END$&#10;}" description="hook_mail_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_mail_alter" value="/**&#10; * Implements hook_mail_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_mail_alter(&amp;$message) {&#10;  if ($message['id'] == 'modulename_messagekey') {&#10;    $message['body'][] = &quot;--\nMail sent out from &quot; . variable_get('sitename', t('Drupal'));&#10;  }&#10;  $END$&#10;}" description="hook_mail_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_module_implements_alter" value="/**&#10; * Implements hook_module_implements_alter().&#10; *&#10; * Alter the registry of modules implementing a hook.&#10; *&#10; * This hook is invoked during module_implements(). A module may implement this&#10; * hook in order to reorder the implementing modules, which are otherwise&#10; * ordered by the module's system weight.&#10; *&#10; * @param $implementations&#10; *   An array keyed by the module's name. The value of each item corresponds&#10; *   to a $group, which is usually FALSE, unless the implementation is in a&#10; *   file named $module.$group.inc.&#10; * @param $hook&#10; *   The name of the module hook being implemented.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_module_implements_alter(&amp;$implementations, $hook) {&#10;  if ($hook == 'rdf_mapping') {&#10;    // Move my_module_rdf_mapping() to the end of the list. module_implements()&#10;    // iterates through $implementations with a foreach loop which PHP iterates&#10;    // in the order that the items were added, so to move an item to the end of&#10;    // the array, we remove it and then add it.&#10;    $group = $implementations['my_module'];&#10;    unset($implementations['my_module']);&#10;    $implementations['my_module'] = $group;&#10;  }&#10;  $END$&#10;}" description="hook_module_implements_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_module_implements_alter" value="/**&#10; * Implements hook_module_implements_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_module_implements_alter(&amp;$implementations, $hook) {&#10;  if ($hook == 'rdf_mapping') {&#10;    // Move my_module_rdf_mapping() to the end of the list. module_implements()&#10;    // iterates through $implementations with a foreach loop which PHP iterates&#10;    // in the order that the items were added, so to move an item to the end of&#10;    // the array, we remove it and then add it.&#10;    $group = $implementations['my_module'];&#10;    unset($implementations['my_module']);&#10;    $implementations['my_module'] = $group;&#10;  }&#10;  $END$&#10;}" description="hook_module_implements_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_system_info_alter" value="/**&#10; * Implements hook_system_info_alter().&#10; *&#10; * Alter the information parsed from module and theme .info files&#10; *&#10; * This hook is invoked in _system_rebuild_module_data() and in&#10; * _system_rebuild_theme_data(). A module may implement this hook in order to&#10; * add to or alter the data generated by reading the .info file with&#10; * drupal_parse_info_file().&#10; *&#10; * @param $info&#10; *   The .info file contents, passed by reference so that it can be altered.&#10; * @param $file&#10; *   Full information about the module or theme, including $file-&gt;name, and&#10; *   $file-&gt;filename&#10; * @param $type&#10; *   Either 'module' or 'theme', depending on the type of .info file that was&#10; *   passed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_system_info_alter(&amp;$info, $file, $type) {&#10;  // Only fill this in if the .info file does not define a 'datestamp'.&#10;  if (empty($info['datestamp'])) {&#10;    $info['datestamp'] = filemtime($file-&gt;filename);&#10;  }&#10;  $END$&#10;}" description="hook_system_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_system_info_alter" value="/**&#10; * Implements hook_system_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_system_info_alter(&amp;$info, $file, $type) {&#10;  // Only fill this in if the .info file does not define a 'datestamp'.&#10;  if (empty($info['datestamp'])) {&#10;    $info['datestamp'] = filemtime($file-&gt;filename);&#10;  }&#10;  $END$&#10;}" description="hook_system_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_permission" value="/**&#10; * Implements hook_permission().&#10; *&#10; * Define user permissions.&#10; *&#10; * This hook can supply permissions that the module defines, so that they&#10; * can be selected on the user permissions page and used to grant or restrict&#10; * access to actions the module performs.&#10; *&#10; * Permissions are checked using user_access().&#10; *&#10; * For a detailed usage example, see page_example.module.&#10; *&#10; * @return&#10; *   An array whose keys are permission names and whose corresponding values&#10; *   are arrays containing the following key-value pairs:&#10; *   - title: The human-readable name of the permission, to be shown on the&#10; *     permission administration page. This should be wrapped in the t()&#10; *     function so it can be translated.&#10; *   - description: (optional) A description of what the permission does. This&#10; *     should be wrapped in the t() function so it can be translated.&#10; *   - restrict access: (optional) A boolean which can be set to TRUE to&#10; *     indicate that site administrators should restrict access to this&#10; *     permission to trusted users. This should be used for permissions that&#10; *     have inherent security risks across a variety of potential use cases&#10; *     (for example, the &quot;administer filters&quot; and &quot;bypass node access&quot;&#10; *     permissions provided by Drupal core). When set to TRUE, a standard&#10; *     warning message defined in user_admin_permissions() and output via&#10; *     theme_user_permission_description() will be associated with the&#10; *     permission and displayed with it on the permission administration page.&#10; *     Defaults to FALSE.&#10; *   - warning: (optional) A translated warning message to display for this&#10; *     permission on the permission administration page. This warning overrides&#10; *     the automatic warning generated by 'restrict access' being set to TRUE.&#10; *     This should rarely be used, since it is important for all permissions to&#10; *     have a clear, consistent security warning that is the same across the&#10; *     site. Use the 'description' key instead to provide any information that&#10; *     is specific to the permission you are defining.&#10; *&#10; * @see theme_user_permission_description()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_permission() {&#10;  return array(&#10;    'administer my module' =&gt;  array(&#10;      'title' =&gt; t('Administer my module'),&#10;      'description' =&gt; t('Perform administration tasks for my module.'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_permission" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_permission" value="/**&#10; * Implements hook_permission().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_permission() {&#10;  return array(&#10;    'administer my module' =&gt;  array(&#10;      'title' =&gt; t('Administer my module'),&#10;      'description' =&gt; t('Perform administration tasks for my module.'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_permission" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_theme" value="/**&#10; * Implements hook_theme().&#10; *&#10; * Register a module (or theme's) theme implementations.&#10; *&#10; * The implementations declared by this hook have two purposes: either they&#10; * specify how a particular render array is to be rendered as HTML (this is&#10; * usually the case if the theme function is assigned to the render array's&#10; * #theme property), or they return the HTML that should be returned by an&#10; * invocation of theme().&#10; *&#10; * The following parameters are all optional.&#10; *&#10; * @param array $existing&#10; *   An array of existing implementations that may be used for override&#10; *   purposes. This is primarily useful for themes that may wish to examine&#10; *   existing implementations to extract data (such as arguments) so that&#10; *   it may properly register its own, higher priority implementations.&#10; * @param $type&#10; *   Whether a theme, module, etc. is being processed. This is primarily useful&#10; *   so that themes tell if they are the actual theme being called or a parent&#10; *   theme. May be one of:&#10; *   - 'module': A module is being checked for theme implementations.&#10; *   - 'base_theme_engine': A theme engine is being checked for a theme that is&#10; *     a parent of the actual theme being used.&#10; *   - 'theme_engine': A theme engine is being checked for the actual theme&#10; *     being used.&#10; *   - 'base_theme': A base theme is being checked for theme implementations.&#10; *   - 'theme': The actual theme in use is being checked.&#10; * @param $theme&#10; *   The actual name of theme, module, etc. that is being being processed.&#10; * @param $path&#10; *   The directory path of the theme or module, so that it doesn't need to be&#10; *   looked up.&#10; *&#10; * @return array&#10; *   An associative array of theme hook information. The keys on the outer&#10; *   array are the internal names of the hooks, and the values are arrays&#10; *   containing information about the hook. Each information array must contain&#10; *   either a 'variables' element or a 'render element' element, but not both.&#10; *   Use 'render element' if you are theming a single element or element tree&#10; *   composed of elements, such as a form array, a page array, or a single&#10; *   checkbox element. Use 'variables' if your theme implementation is&#10; *   intended to be called directly through theme() and has multiple arguments&#10; *   for the data and style; in this case, the variables not supplied by the&#10; *   calling function will be given default values and passed to the template&#10; *   or theme function. The returned theme information array can contain the&#10; *   following key/value pairs:&#10; *   - variables: (see above) Each array key is the name of the variable, and&#10; *     the value given is used as the default value if the function calling&#10; *     theme() does not supply it. Template implementations receive each array&#10; *     key as a variable in the template file (so they must be legal PHP&#10; *     variable names). Function implementations are passed the variables in a&#10; *     single $variables function argument.&#10; *   - render element: (see above) The name of the renderable element or element&#10; *     tree to pass to the theme function. This name is used as the name of the&#10; *     variable that holds the renderable element or tree in preprocess and&#10; *     process functions.&#10; *   - file: The file the implementation resides in. This file will be included&#10; *     prior to the theme being rendered, to make sure that the function or&#10; *     preprocess function (as needed) is actually loaded; this makes it&#10; *     possible to split theme functions out into separate files quite easily.&#10; *   - path: Override the path of the file to be used. Ordinarily the module or&#10; *     theme path will be used, but if the file will not be in the default&#10; *     path, include it here. This path should be relative to the Drupal root&#10; *     directory.&#10; *   - template: If specified, this theme implementation is a template, and&#10; *     this is the template file without an extension. Do not put .tpl.php on&#10; *     this file; that extension will be added automatically by the default&#10; *     rendering engine (which is PHPTemplate). If 'path', above, is specified,&#10; *     the template should also be in this path.&#10; *   - function: If specified, this will be the function name to invoke for&#10; *     this implementation. If neither 'template' nor 'function' is specified,&#10; *     a default function name will be assumed. For example, if a module&#10; *     registers the 'node' theme hook, 'theme_node' will be assigned to its&#10; *     function. If the chameleon theme registers the node hook, it will be&#10; *     assigned 'chameleon_node' as its function.&#10; *   - pattern: A regular expression pattern to be used to allow this theme&#10; *     implementation to have a dynamic name. The convention is to use __ to&#10; *     differentiate the dynamic portion of the theme. For example, to allow&#10; *     forums to be themed individually, the pattern might be: 'forum__'. Then,&#10; *     when the forum is themed, call:&#10; *     @code&#10; *     theme(array('forum__' . $tid, 'forum'), $forum)&#10; *     @endcode&#10; *   - preprocess functions: A list of functions used to preprocess this data.&#10; *     Ordinarily this won't be used; it's automatically filled in. By default,&#10; *     for a module this will be filled in as template_preprocess_HOOK. For&#10; *     a theme this will be filled in as phptemplate_preprocess and&#10; *     phptemplate_preprocess_HOOK as well as themename_preprocess and&#10; *     themename_preprocess_HOOK.&#10; *   - override preprocess functions: Set to TRUE when a theme does NOT want&#10; *     the standard preprocess functions to run. This can be used to give a&#10; *     theme FULL control over how variables are set. For example, if a theme&#10; *     wants total control over how certain variables in the page.tpl.php are&#10; *     set, this can be set to true. Please keep in mind that when this is used&#10; *     by a theme, that theme becomes responsible for making sure necessary&#10; *     variables are set.&#10; *   - type: (automatically derived) Where the theme hook is defined:&#10; *     'module', 'theme_engine', or 'theme'.&#10; *   - theme path: (automatically derived) The directory path of the theme or&#10; *     module, so that it doesn't need to be looked up.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_theme($existing, $type, $theme, $path) {&#10;  return array(&#10;    'forum_display' =&gt; array(&#10;      'variables' =&gt; array('forums' =&gt; NULL, 'topics' =&gt; NULL, 'parents' =&gt; NULL, 'tid' =&gt; NULL, 'sortby' =&gt; NULL, 'forum_per_page' =&gt; NULL),&#10;    ),&#10;    'forum_list' =&gt; array(&#10;      'variables' =&gt; array('forums' =&gt; NULL, 'parents' =&gt; NULL, 'tid' =&gt; NULL),&#10;    ),&#10;    'forum_topic_list' =&gt; array(&#10;      'variables' =&gt; array('tid' =&gt; NULL, 'topics' =&gt; NULL, 'sortby' =&gt; NULL, 'forum_per_page' =&gt; NULL),&#10;    ),&#10;    'forum_icon' =&gt; array(&#10;      'variables' =&gt; array('new_posts' =&gt; NULL, 'num_posts' =&gt; 0, 'comment_mode' =&gt; 0, 'sticky' =&gt; 0),&#10;    ),&#10;    'status_report' =&gt; array(&#10;      'render element' =&gt; 'requirements',&#10;      'file' =&gt; 'system.admin.inc',&#10;    ),&#10;    'system_date_time_settings' =&gt; array(&#10;      'render element' =&gt; 'form',&#10;      'file' =&gt; 'system.admin.inc',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_theme" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_theme" value="/**&#10; * Implements hook_theme().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_theme($existing, $type, $theme, $path) {&#10;  return array(&#10;    'forum_display' =&gt; array(&#10;      'variables' =&gt; array('forums' =&gt; NULL, 'topics' =&gt; NULL, 'parents' =&gt; NULL, 'tid' =&gt; NULL, 'sortby' =&gt; NULL, 'forum_per_page' =&gt; NULL),&#10;    ),&#10;    'forum_list' =&gt; array(&#10;      'variables' =&gt; array('forums' =&gt; NULL, 'parents' =&gt; NULL, 'tid' =&gt; NULL),&#10;    ),&#10;    'forum_topic_list' =&gt; array(&#10;      'variables' =&gt; array('tid' =&gt; NULL, 'topics' =&gt; NULL, 'sortby' =&gt; NULL, 'forum_per_page' =&gt; NULL),&#10;    ),&#10;    'forum_icon' =&gt; array(&#10;      'variables' =&gt; array('new_posts' =&gt; NULL, 'num_posts' =&gt; 0, 'comment_mode' =&gt; 0, 'sticky' =&gt; 0),&#10;    ),&#10;    'status_report' =&gt; array(&#10;      'render element' =&gt; 'requirements',&#10;      'file' =&gt; 'system.admin.inc',&#10;    ),&#10;    'system_date_time_settings' =&gt; array(&#10;      'render element' =&gt; 'form',&#10;      'file' =&gt; 'system.admin.inc',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_theme" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_theme_registry_alter" value="/**&#10; * Implements hook_theme_registry_alter().&#10; *&#10; * Alter the theme registry information returned from hook_theme().&#10; *&#10; * The theme registry stores information about all available theme hooks,&#10; * including which callback functions those hooks will call when triggered,&#10; * what template files are exposed by these hooks, and so on.&#10; *&#10; * Note that this hook is only executed as the theme cache is re-built.&#10; * Changes here will not be visible until the next cache clear.&#10; *&#10; * The $theme_registry array is keyed by theme hook name, and contains the&#10; * information returned from hook_theme(), as well as additional properties&#10; * added by _theme_process_registry().&#10; *&#10; * For example:&#10; * @code&#10; * $theme_registry['user_profile'] = array(&#10; *   'variables' =&gt; array(&#10; *     'account' =&gt; NULL,&#10; *   ),&#10; *   'template' =&gt; 'modules/user/user-profile',&#10; *   'file' =&gt; 'modules/user/user.pages.inc',&#10; *   'type' =&gt; 'module',&#10; *   'theme path' =&gt; 'modules/user',&#10; *   'preprocess functions' =&gt; array(&#10; *     0 =&gt; 'template_preprocess',&#10; *     1 =&gt; 'template_preprocess_user_profile',&#10; *   ),&#10; * );&#10; * @endcode&#10; *&#10; * @param $theme_registry&#10; *   The entire cache of theme registry information, post-processing.&#10; *&#10; * @see hook_theme()&#10; * @see _theme_process_registry()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_theme_registry_alter(&amp;$theme_registry) {&#10;  // Kill the next/previous forum topic navigation links.&#10;  foreach ($theme_registry['forum_topic_navigation']['preprocess functions'] as $key =&gt; $value) {&#10;    if ($value == 'template_preprocess_forum_topic_navigation') {&#10;      unset($theme_registry['forum_topic_navigation']['preprocess functions'][$key]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_theme_registry_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_theme_registry_alter" value="/**&#10; * Implements hook_theme_registry_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_theme_registry_alter(&amp;$theme_registry) {&#10;  // Kill the next/previous forum topic navigation links.&#10;  foreach ($theme_registry['forum_topic_navigation']['preprocess functions'] as $key =&gt; $value) {&#10;    if ($value == 'template_preprocess_forum_topic_navigation') {&#10;      unset($theme_registry['forum_topic_navigation']['preprocess functions'][$key]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_theme_registry_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_custom_theme" value="/**&#10; * Implements hook_custom_theme().&#10; *&#10; * Return the machine-readable name of the theme to use for the current page.&#10; *&#10; * This hook can be used to dynamically set the theme for the current page&#10; * request. It should be used by modules which need to override the theme&#10; * based on dynamic conditions (for example, a module which allows the theme to&#10; * be set based on the current user's role). The return value of this hook will&#10; * be used on all pages except those which have a valid per-page or per-section&#10; * theme set via a theme callback function in hook_menu(); the themes on those&#10; * pages can only be overridden using hook_menu_alter().&#10; *&#10; * Since only one theme can be used at a time, the last (i.e., highest&#10; * weighted) module which returns a valid theme name from this hook will&#10; * prevail.&#10; *&#10; * @return&#10; *   The machine-readable name of the theme that should be used for the current&#10; *   page request. The value returned from this function will only have an&#10; *   effect if it corresponds to a currently-active theme on the site.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_custom_theme() {&#10;  // Allow the user to request a particular theme via a query parameter.&#10;  if (isset($_GET['theme'])) {&#10;    return $_GET['theme'];&#10;  }&#10;  $END$&#10;}" description="hook_custom_theme" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_custom_theme" value="/**&#10; * Implements hook_custom_theme().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_custom_theme() {&#10;  // Allow the user to request a particular theme via a query parameter.&#10;  if (isset($_GET['theme'])) {&#10;    return $_GET['theme'];&#10;  }&#10;  $END$&#10;}" description="hook_custom_theme" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_xmlrpc" value="/**&#10; * Implements hook_xmlrpc().&#10; *&#10; * Register XML-RPC callbacks.&#10; *&#10; * This hook lets a module register callback functions to be called when&#10; * particular XML-RPC methods are invoked by a client.&#10; *&#10; * @return&#10; *   An array which maps XML-RPC methods to Drupal functions. Each array&#10; *   element is either a pair of method =&gt; function or an array with four&#10; *   entries:&#10; *   - The XML-RPC method name (for example, module.function).&#10; *   - The Drupal callback function (for example, module_function).&#10; *   - The method signature is an array of XML-RPC types. The first element&#10; *     of this array is the type of return value and then you should write a&#10; *     list of the types of the parameters. XML-RPC types are the following&#10; *     (See the types at http://www.xmlrpc.com/spec):&#10; *       - &quot;boolean&quot;: 0 (false) or 1 (true).&#10; *       - &quot;double&quot;: a floating point number (for example, -12.214).&#10; *       - &quot;int&quot;: a integer number (for example,  -12).&#10; *       - &quot;array&quot;: an array without keys (for example, array(1, 2, 3)).&#10; *       - &quot;struct&quot;: an associative array or an object (for example,&#10; *          array('one' =&gt; 1, 'two' =&gt; 2)).&#10; *       - &quot;date&quot;: when you return a date, then you may either return a&#10; *          timestamp (time(), mktime() etc.) or an ISO8601 timestamp. When&#10; *          date is specified as an input parameter, then you get an object,&#10; *          which is described in the function xmlrpc_date&#10; *       - &quot;base64&quot;: a string containing binary data, automatically&#10; *          encoded/decoded automatically.&#10; *       - &quot;string&quot;: anything else, typically a string.&#10; *   - A descriptive help string, enclosed in a t() function for translation&#10; *     purposes.&#10; *   Both forms are shown in the example.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_xmlrpc() {&#10;  return array(&#10;    'drupal.login' =&gt; 'drupal_login',&#10;    array(&#10;      'drupal.site.ping',&#10;      'drupal_directory_ping',&#10;      array('boolean', 'string', 'string', 'string', 'string', 'string'),&#10;      t('Handling ping request'))&#10;  );&#10;  $END$&#10;}" description="hook_xmlrpc" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_xmlrpc" value="/**&#10; * Implements hook_xmlrpc().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_xmlrpc() {&#10;  return array(&#10;    'drupal.login' =&gt; 'drupal_login',&#10;    array(&#10;      'drupal.site.ping',&#10;      'drupal_directory_ping',&#10;      array('boolean', 'string', 'string', 'string', 'string', 'string'),&#10;      t('Handling ping request'))&#10;  );&#10;  $END$&#10;}" description="hook_xmlrpc" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_xmlrpc_alter" value="/**&#10; * Implements hook_xmlrpc_alter().&#10; *&#10; * Alters the definition of XML-RPC methods before they are called.&#10; *&#10; * This hook allows modules to modify the callback definition of declared&#10; * XML-RPC methods, right before they are invoked by a client. Methods may be&#10; * added, or existing methods may be altered.&#10; *&#10; * Note that hook_xmlrpc() supports two distinct and incompatible formats to&#10; * define a callback, so care must be taken when altering other methods.&#10; *&#10; * @param $methods&#10; *   An asssociative array of method callback definitions, as returned from&#10; *   hook_xmlrpc() implementations.&#10; *&#10; * @see hook_xmlrpc()&#10; * @see xmlrpc_server()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_xmlrpc_alter(&amp;$methods) {&#10;  // Directly change a simple method.&#10;  $methods['drupal.login'] = 'mymodule_login';&#10;&#10;  // Alter complex definitions.&#10;  foreach ($methods as $key =&gt; &amp;$method) {&#10;    // Skip simple method definitions.&#10;    if (!is_int($key)) {&#10;      continue;&#10;    }&#10;    // Perform the wanted manipulation.&#10;    if ($method[0] == 'drupal.site.ping') {&#10;      $method[1] = 'mymodule_directory_ping';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_xmlrpc_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_xmlrpc_alter" value="/**&#10; * Implements hook_xmlrpc_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_xmlrpc_alter(&amp;$methods) {&#10;  // Directly change a simple method.&#10;  $methods['drupal.login'] = 'mymodule_login';&#10;&#10;  // Alter complex definitions.&#10;  foreach ($methods as $key =&gt; &amp;$method) {&#10;    // Skip simple method definitions.&#10;    if (!is_int($key)) {&#10;      continue;&#10;    }&#10;    // Perform the wanted manipulation.&#10;    if ($method[0] == 'drupal.site.ping') {&#10;      $method[1] = 'mymodule_directory_ping';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_xmlrpc_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_watchdog" value="/**&#10; * Implements hook_watchdog().&#10; *&#10; * Log an event message&#10; *&#10; * This hook allows modules to route log events to custom destinations, such as&#10; * SMS, Email, pager, syslog, ...etc.&#10; *&#10; * @param $log_entry&#10; *   An associative array containing the following keys:&#10; *   - type: The type of message for this entry. For contributed modules, this is&#10; *     normally the module name. Do not use 'debug', use severity WATCHDOG_DEBUG instead.&#10; *   - user: The user object for the user who was logged in when the event happened.&#10; *   - request_uri: The Request URI for the page the event happened in.&#10; *   - referer: The page that referred the use to the page where the event occurred.&#10; *   - ip: The IP address where the request for the page came from.&#10; *   - timestamp: The UNIX timestamp of the date/time the event occurred&#10; *   - severity: One of the following values as defined in RFC 3164 http://www.faqs.org/rfcs/rfc3164.html&#10; *     WATCHDOG_EMERGENCY Emergency: system is unusable&#10; *     WATCHDOG_ALERT     Alert: action must be taken immediately&#10; *     WATCHDOG_CRITICAL  Critical: critical conditions&#10; *     WATCHDOG_ERROR     Error: error conditions&#10; *     WATCHDOG_WARNING   Warning: warning conditions&#10; *     WATCHDOG_NOTICE    Notice: normal but significant condition&#10; *     WATCHDOG_INFO      Informational: informational messages&#10; *     WATCHDOG_DEBUG     Debug: debug-level messages&#10; *   - link: an optional link provided by the module that called the watchdog() function.&#10; *   - message: The text of the message to be logged.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_watchdog(array $log_entry) {&#10;  global $base_url, $language;&#10;&#10;  $severity_list = array(&#10;    WATCHDOG_EMERGENCY =&gt; t('Emergency'),&#10;    WATCHDOG_ALERT     =&gt; t('Alert'),&#10;    WATCHDOG_CRITICAL  =&gt; t('Critical'),&#10;    WATCHDOG_ERROR     =&gt; t('Error'),&#10;    WATCHDOG_WARNING   =&gt; t('Warning'),&#10;    WATCHDOG_NOTICE    =&gt; t('Notice'),&#10;    WATCHDOG_INFO      =&gt; t('Info'),&#10;    WATCHDOG_DEBUG     =&gt; t('Debug'),&#10;  );&#10;&#10;  $to = 'someone@example.com';&#10;  $params = array();&#10;  $params['subject'] = t('[@site_name] @severity_desc: Alert from your web site', array(&#10;    '@site_name' =&gt; variable_get('site_name', 'Drupal'),&#10;    '@severity_desc' =&gt; $severity_list[$log_entry['severity']],&#10;  ));&#10;&#10;  $params['message']  = &quot;\nSite:         @base_url&quot;;&#10;  $params['message'] .= &quot;\nSeverity:     (@severity) @severity_desc&quot;;&#10;  $params['message'] .= &quot;\nTimestamp:    @timestamp&quot;;&#10;  $params['message'] .= &quot;\nType:         @type&quot;;&#10;  $params['message'] .= &quot;\nIP Address:   @ip&quot;;&#10;  $params['message'] .= &quot;\nRequest URI:  @request_uri&quot;;&#10;  $params['message'] .= &quot;\nReferrer URI: @referer_uri&quot;;&#10;  $params['message'] .= &quot;\nUser:         (@uid) @name&quot;;&#10;  $params['message'] .= &quot;\nLink:         @link&quot;;&#10;  $params['message'] .= &quot;\nMessage:      \n\n@message&quot;;&#10;&#10;  $params['message'] = t($params['message'], array(&#10;    '@base_url'      =&gt; $base_url,&#10;    '@severity'      =&gt; $log_entry['severity'],&#10;    '@severity_desc' =&gt; $severity_list[$log_entry['severity']],&#10;    '@timestamp'     =&gt; format_date($log_entry['timestamp']),&#10;    '@type'          =&gt; $log_entry['type'],&#10;    '@ip'            =&gt; $log_entry['ip'],&#10;    '@request_uri'   =&gt; $log_entry['request_uri'],&#10;    '@referer_uri'   =&gt; $log_entry['referer'],&#10;    '@uid'           =&gt; $log_entry['user']-&gt;uid,&#10;    '@name'          =&gt; $log_entry['user']-&gt;name,&#10;    '@link'          =&gt; strip_tags($log_entry['link']),&#10;    '@message'       =&gt; strip_tags($log_entry['message']),&#10;  ));&#10;&#10;  drupal_mail('emaillog', 'entry', $to, $language, $params);&#10;  $END$&#10;}" description="hook_watchdog" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_watchdog" value="/**&#10; * Implements hook_watchdog().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_watchdog(array $log_entry) {&#10;  global $base_url, $language;&#10;&#10;  $severity_list = array(&#10;    WATCHDOG_EMERGENCY =&gt; t('Emergency'),&#10;    WATCHDOG_ALERT     =&gt; t('Alert'),&#10;    WATCHDOG_CRITICAL  =&gt; t('Critical'),&#10;    WATCHDOG_ERROR     =&gt; t('Error'),&#10;    WATCHDOG_WARNING   =&gt; t('Warning'),&#10;    WATCHDOG_NOTICE    =&gt; t('Notice'),&#10;    WATCHDOG_INFO      =&gt; t('Info'),&#10;    WATCHDOG_DEBUG     =&gt; t('Debug'),&#10;  );&#10;&#10;  $to = 'someone@example.com';&#10;  $params = array();&#10;  $params['subject'] = t('[@site_name] @severity_desc: Alert from your web site', array(&#10;    '@site_name' =&gt; variable_get('site_name', 'Drupal'),&#10;    '@severity_desc' =&gt; $severity_list[$log_entry['severity']],&#10;  ));&#10;&#10;  $params['message']  = &quot;\nSite:         @base_url&quot;;&#10;  $params['message'] .= &quot;\nSeverity:     (@severity) @severity_desc&quot;;&#10;  $params['message'] .= &quot;\nTimestamp:    @timestamp&quot;;&#10;  $params['message'] .= &quot;\nType:         @type&quot;;&#10;  $params['message'] .= &quot;\nIP Address:   @ip&quot;;&#10;  $params['message'] .= &quot;\nRequest URI:  @request_uri&quot;;&#10;  $params['message'] .= &quot;\nReferrer URI: @referer_uri&quot;;&#10;  $params['message'] .= &quot;\nUser:         (@uid) @name&quot;;&#10;  $params['message'] .= &quot;\nLink:         @link&quot;;&#10;  $params['message'] .= &quot;\nMessage:      \n\n@message&quot;;&#10;&#10;  $params['message'] = t($params['message'], array(&#10;    '@base_url'      =&gt; $base_url,&#10;    '@severity'      =&gt; $log_entry['severity'],&#10;    '@severity_desc' =&gt; $severity_list[$log_entry['severity']],&#10;    '@timestamp'     =&gt; format_date($log_entry['timestamp']),&#10;    '@type'          =&gt; $log_entry['type'],&#10;    '@ip'            =&gt; $log_entry['ip'],&#10;    '@request_uri'   =&gt; $log_entry['request_uri'],&#10;    '@referer_uri'   =&gt; $log_entry['referer'],&#10;    '@uid'           =&gt; $log_entry['user']-&gt;uid,&#10;    '@name'          =&gt; $log_entry['user']-&gt;name,&#10;    '@link'          =&gt; strip_tags($log_entry['link']),&#10;    '@message'       =&gt; strip_tags($log_entry['message']),&#10;  ));&#10;&#10;  drupal_mail('emaillog', 'entry', $to, $language, $params);&#10;  $END$&#10;}" description="hook_watchdog" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_mail" value="/**&#10; * Implements hook_mail().&#10; *&#10; * Prepare a message based on parameters; called from drupal_mail().&#10; *&#10; * Note that hook_mail(), unlike hook_mail_alter(), is only called on the&#10; * $module argument to drupal_mail(), not all modules.&#10; *&#10; * @param $key&#10; *   An identifier of the mail.&#10; * @param $message&#10; *   An array to be filled in. Elements in this array include:&#10; *   - id: An ID to identify the mail sent. Look at module source code&#10; *     or drupal_mail() for possible id values.&#10; *   - to: The address or addresses the message will be sent to. The&#10; *     formatting of this string must comply with RFC 2822.&#10; *   - subject: Subject of the e-mail to be sent. This must not contain any&#10; *     newline characters, or the mail may not be sent properly. drupal_mail()&#10; *     sets this to an empty string when the hook is invoked.&#10; *   - body: An array of lines containing the message to be sent. Drupal will&#10; *     format the correct line endings for you. drupal_mail() sets this to an&#10; *     empty array when the hook is invoked.&#10; *   - from: The address the message will be marked as being from, which is&#10; *     set by drupal_mail() to either a custom address or the site-wide&#10; *     default email address when the hook is invoked.&#10; *   - headers: Associative array containing mail headers, such as From,&#10; *     Sender, MIME-Version, Content-Type, etc. drupal_mail() pre-fills&#10; *     several headers in this array.&#10; * @param $params&#10; *   An array of parameters supplied by the caller of drupal_mail().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_mail($key, &amp;$message, $params) {&#10;  $account = $params['account'];&#10;  $context = $params['context'];&#10;  $variables = array(&#10;    '%site_name' =&gt; variable_get('site_name', 'Drupal'),&#10;    '%username' =&gt; format_username($account),&#10;  );&#10;  if ($context['hook'] == 'taxonomy') {&#10;    $entity = $params['entity'];&#10;    $vocabulary = taxonomy_vocabulary_load($entity-&gt;vid);&#10;    $variables += array(&#10;      '%term_name' =&gt; $entity-&gt;name,&#10;      '%term_description' =&gt; $entity-&gt;description,&#10;      '%term_id' =&gt; $entity-&gt;tid,&#10;      '%vocabulary_name' =&gt; $vocabulary-&gt;name,&#10;      '%vocabulary_description' =&gt; $vocabulary-&gt;description,&#10;      '%vocabulary_id' =&gt; $vocabulary-&gt;vid,&#10;    );&#10;  }&#10;&#10;  // Node-based variable translation is only available if we have a node.&#10;  if (isset($params['node'])) {&#10;    $node = $params['node'];&#10;    $variables += array(&#10;      '%uid' =&gt; $node-&gt;uid,&#10;      '%node_url' =&gt; url('node/' . $node-&gt;nid, array('absolute' =&gt; TRUE)),&#10;      '%node_type' =&gt; node_type_get_name($node),&#10;      '%title' =&gt; $node-&gt;title,&#10;      '%teaser' =&gt; $node-&gt;teaser,&#10;      '%body' =&gt; $node-&gt;body,&#10;    );&#10;  }&#10;  $subject = strtr($context['subject'], $variables);&#10;  $body = strtr($context['message'], $variables);&#10;  $message['subject'] .= str_replace(array(&quot;\r&quot;, &quot;\n&quot;), '', $subject);&#10;  $message['body'][] = drupal_html_to_text($body);&#10;  $END$&#10;}" description="hook_mail" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_mail" value="/**&#10; * Implements hook_mail().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_mail($key, &amp;$message, $params) {&#10;  $account = $params['account'];&#10;  $context = $params['context'];&#10;  $variables = array(&#10;    '%site_name' =&gt; variable_get('site_name', 'Drupal'),&#10;    '%username' =&gt; format_username($account),&#10;  );&#10;  if ($context['hook'] == 'taxonomy') {&#10;    $entity = $params['entity'];&#10;    $vocabulary = taxonomy_vocabulary_load($entity-&gt;vid);&#10;    $variables += array(&#10;      '%term_name' =&gt; $entity-&gt;name,&#10;      '%term_description' =&gt; $entity-&gt;description,&#10;      '%term_id' =&gt; $entity-&gt;tid,&#10;      '%vocabulary_name' =&gt; $vocabulary-&gt;name,&#10;      '%vocabulary_description' =&gt; $vocabulary-&gt;description,&#10;      '%vocabulary_id' =&gt; $vocabulary-&gt;vid,&#10;    );&#10;  }&#10;&#10;  // Node-based variable translation is only available if we have a node.&#10;  if (isset($params['node'])) {&#10;    $node = $params['node'];&#10;    $variables += array(&#10;      '%uid' =&gt; $node-&gt;uid,&#10;      '%node_url' =&gt; url('node/' . $node-&gt;nid, array('absolute' =&gt; TRUE)),&#10;      '%node_type' =&gt; node_type_get_name($node),&#10;      '%title' =&gt; $node-&gt;title,&#10;      '%teaser' =&gt; $node-&gt;teaser,&#10;      '%body' =&gt; $node-&gt;body,&#10;    );&#10;  }&#10;  $subject = strtr($context['subject'], $variables);&#10;  $body = strtr($context['message'], $variables);&#10;  $message['subject'] .= str_replace(array(&quot;\r&quot;, &quot;\n&quot;), '', $subject);&#10;  $message['body'][] = drupal_html_to_text($body);&#10;  $END$&#10;}" description="hook_mail" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_flush_caches" value="/**&#10; * Implements hook_flush_caches().&#10; *&#10; * Add a list of cache tables to be cleared.&#10; *&#10; * This hook allows your module to add cache table names to the list of cache&#10; * tables that will be cleared by the Clear button on the Performance page or&#10; * whenever drupal_flush_all_caches is invoked.&#10; *&#10; * @return&#10; *   An array of cache table names.&#10; *&#10; * @see drupal_flush_all_caches()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_flush_caches() {&#10;  return array('cache_example');&#10;  $END$&#10;}" description="hook_flush_caches" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_flush_caches" value="/**&#10; * Implements hook_flush_caches().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_flush_caches() {&#10;  return array('cache_example');&#10;  $END$&#10;}" description="hook_flush_caches" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_modules_installed" value="/**&#10; * Implements hook_modules_installed().&#10; *&#10; * Perform necessary actions after modules are installed.&#10; *&#10; * This function differs from hook_install() in that it gives all other modules&#10; * a chance to perform actions when a module is installed, whereas&#10; * hook_install() is only called on the module actually being installed. See&#10; * module_enable() for a detailed description of the order in which install and&#10; * enable hooks are invoked.&#10; *&#10; * @param $modules&#10; *   An array of the modules that were installed.&#10; *&#10; * @see module_enable()&#10; * @see hook_modules_enabled()&#10; * @see hook_install()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_installed($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    variable_set('lousy_module_conflicting_variable', FALSE);&#10;  }&#10;  $END$&#10;}" description="hook_modules_installed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_modules_installed" value="/**&#10; * Implements hook_modules_installed().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_installed($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    variable_set('lousy_module_conflicting_variable', FALSE);&#10;  }&#10;  $END$&#10;}" description="hook_modules_installed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_modules_enabled" value="/**&#10; * Implements hook_modules_enabled().&#10; *&#10; * Perform necessary actions after modules are enabled.&#10; *&#10; * This function differs from hook_enable() in that it gives all other modules a&#10; * chance to perform actions when modules are enabled, whereas hook_enable() is&#10; * only called on the module actually being enabled. See module_enable() for a&#10; * detailed description of the order in which install and enable hooks are&#10; * invoked.&#10; *&#10; * @param $modules&#10; *   An array of the modules that were enabled.&#10; *&#10; * @see hook_enable()&#10; * @see hook_modules_installed()&#10; * @see module_enable()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_enabled($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    drupal_set_message(t('mymodule is not compatible with lousy_module'), 'error');&#10;    mymodule_disable_functionality();&#10;  }&#10;  $END$&#10;}" description="hook_modules_enabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_modules_enabled" value="/**&#10; * Implements hook_modules_enabled().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_enabled($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    drupal_set_message(t('mymodule is not compatible with lousy_module'), 'error');&#10;    mymodule_disable_functionality();&#10;  }&#10;  $END$&#10;}" description="hook_modules_enabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_modules_disabled" value="/**&#10; * Implements hook_modules_disabled().&#10; *&#10; * Perform necessary actions after modules are disabled.&#10; *&#10; * This function differs from hook_disable() in that it gives all other modules&#10; * a chance to perform actions when modules are disabled, whereas hook_disable()&#10; * is only called on the module actually being disabled.&#10; *&#10; * @param $modules&#10; *   An array of the modules that were disabled.&#10; *&#10; * @see hook_disable()&#10; * @see hook_modules_uninstalled()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_disabled($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    mymodule_enable_functionality();&#10;  }&#10;  $END$&#10;}" description="hook_modules_disabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_modules_disabled" value="/**&#10; * Implements hook_modules_disabled().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_disabled($modules) {&#10;  if (in_array('lousy_module', $modules)) {&#10;    mymodule_enable_functionality();&#10;  }&#10;  $END$&#10;}" description="hook_modules_disabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_modules_uninstalled" value="/**&#10; * Implements hook_modules_uninstalled().&#10; *&#10; * Perform necessary actions after modules are uninstalled.&#10; *&#10; * This function differs from hook_uninstall() in that it gives all other&#10; * modules a chance to perform actions when a module is uninstalled, whereas&#10; * hook_uninstall() is only called on the module actually being uninstalled.&#10; *&#10; * It is recommended that you implement this hook if your module stores&#10; * data that may have been set by other modules.&#10; *&#10; * @param $modules&#10; *   An array of the modules that were uninstalled.&#10; *&#10; * @see hook_uninstall()&#10; * @see hook_modules_disabled()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_uninstalled($modules) {&#10;  foreach ($modules as $module) {&#10;    db_delete('mymodule_table')&#10;      -&gt;condition('module', $module)&#10;      -&gt;execute();&#10;  }&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_modules_uninstalled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_modules_uninstalled" value="/**&#10; * Implements hook_modules_uninstalled().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_modules_uninstalled($modules) {&#10;  foreach ($modules as $module) {&#10;    db_delete('mymodule_table')&#10;      -&gt;condition('module', $module)&#10;      -&gt;execute();&#10;  }&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_modules_uninstalled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_stream_wrappers" value="/**&#10; * Implements hook_stream_wrappers().&#10; *&#10; * Registers PHP stream wrapper implementations associated with a module.&#10; *&#10; * Provide a facility for managing and querying user-defined stream wrappers&#10; * in PHP. PHP's internal stream_get_wrappers() doesn't return the class&#10; * registered to handle a stream, which we need to be able to find the handler&#10; * for class instantiation.&#10; *&#10; * If a module registers a scheme that is already registered with PHP, it will&#10; * be unregistered and replaced with the specified class.&#10; *&#10; * @return&#10; *   A nested array, keyed first by scheme name (&quot;public&quot; for &quot;public://&quot;),&#10; *   then keyed by the following values:&#10; *   - 'name' A short string to name the wrapper.&#10; *   - 'class' A string specifying the PHP class that implements the&#10; *     DrupalStreamWrapperInterface interface.&#10; *   - 'description' A string with a short description of what the wrapper does.&#10; *   - 'type' (Optional) A bitmask of flags indicating what type of streams this&#10; *     wrapper will access - local or remote, readable and/or writeable, etc.&#10; *     Many shortcut constants are defined in stream_wrappers.inc. Defaults to&#10; *     STREAM_WRAPPERS_NORMAL which includes all of these bit flags:&#10; *     - STREAM_WRAPPERS_READ&#10; *     - STREAM_WRAPPERS_WRITE&#10; *     - STREAM_WRAPPERS_VISIBLE&#10; *&#10; * @see file_get_stream_wrappers()&#10; * @see hook_stream_wrappers_alter()&#10; * @see system_stream_wrappers()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_stream_wrappers() {&#10;  return array(&#10;    'public' =&gt; array(&#10;      'name' =&gt; t('Public files'),&#10;      'class' =&gt; 'DrupalPublicStreamWrapper',&#10;      'description' =&gt; t('Public local files served by the webserver.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_NORMAL,&#10;    ),&#10;    'private' =&gt; array(&#10;      'name' =&gt; t('Private files'),&#10;      'class' =&gt; 'DrupalPrivateStreamWrapper',&#10;      'description' =&gt; t('Private local files served by Drupal.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_NORMAL,&#10;    ),&#10;    'temp' =&gt; array(&#10;      'name' =&gt; t('Temporary files'),&#10;      'class' =&gt; 'DrupalTempStreamWrapper',&#10;      'description' =&gt; t('Temporary local files for upload and previews.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_HIDDEN,&#10;    ),&#10;    'cdn' =&gt; array(&#10;      'name' =&gt; t('Content delivery network files'),&#10;      'class' =&gt; 'MyModuleCDNStreamWrapper',&#10;      'description' =&gt; t('Files served by a content delivery network.'),&#10;      // 'type' can be omitted to use the default of STREAM_WRAPPERS_NORMAL&#10;    ),&#10;    'youtube' =&gt; array(&#10;      'name' =&gt; t('YouTube video'),&#10;      'class' =&gt; 'MyModuleYouTubeStreamWrapper',&#10;      'description' =&gt; t('Video streamed from YouTube.'),&#10;      // A module implementing YouTube integration may decide to support using&#10;      // the YouTube API for uploading video, but here, we assume that this&#10;      // particular module only supports playing YouTube video.&#10;      'type' =&gt; STREAM_WRAPPERS_READ_VISIBLE,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_stream_wrappers" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_stream_wrappers" value="/**&#10; * Implements hook_stream_wrappers().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_stream_wrappers() {&#10;  return array(&#10;    'public' =&gt; array(&#10;      'name' =&gt; t('Public files'),&#10;      'class' =&gt; 'DrupalPublicStreamWrapper',&#10;      'description' =&gt; t('Public local files served by the webserver.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_NORMAL,&#10;    ),&#10;    'private' =&gt; array(&#10;      'name' =&gt; t('Private files'),&#10;      'class' =&gt; 'DrupalPrivateStreamWrapper',&#10;      'description' =&gt; t('Private local files served by Drupal.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_NORMAL,&#10;    ),&#10;    'temp' =&gt; array(&#10;      'name' =&gt; t('Temporary files'),&#10;      'class' =&gt; 'DrupalTempStreamWrapper',&#10;      'description' =&gt; t('Temporary local files for upload and previews.'),&#10;      'type' =&gt; STREAM_WRAPPERS_LOCAL_HIDDEN,&#10;    ),&#10;    'cdn' =&gt; array(&#10;      'name' =&gt; t('Content delivery network files'),&#10;      'class' =&gt; 'MyModuleCDNStreamWrapper',&#10;      'description' =&gt; t('Files served by a content delivery network.'),&#10;      // 'type' can be omitted to use the default of STREAM_WRAPPERS_NORMAL&#10;    ),&#10;    'youtube' =&gt; array(&#10;      'name' =&gt; t('YouTube video'),&#10;      'class' =&gt; 'MyModuleYouTubeStreamWrapper',&#10;      'description' =&gt; t('Video streamed from YouTube.'),&#10;      // A module implementing YouTube integration may decide to support using&#10;      // the YouTube API for uploading video, but here, we assume that this&#10;      // particular module only supports playing YouTube video.&#10;      'type' =&gt; STREAM_WRAPPERS_READ_VISIBLE,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_stream_wrappers" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_stream_wrappers_alter" value="/**&#10; * Implements hook_stream_wrappers_alter().&#10; *&#10; * Alters the list of PHP stream wrapper implementations.&#10; *&#10; * @see file_get_stream_wrappers()&#10; * @see hook_stream_wrappers()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_stream_wrappers_alter(&amp;$wrappers) {&#10;  // Change the name of private files to reflect the performance.&#10;  $wrappers['private']['name'] = t('Slow files');&#10;  $END$&#10;}" description="hook_stream_wrappers_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_stream_wrappers_alter" value="/**&#10; * Implements hook_stream_wrappers_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_stream_wrappers_alter(&amp;$wrappers) {&#10;  // Change the name of private files to reflect the performance.&#10;  $wrappers['private']['name'] = t('Slow files');&#10;  $END$&#10;}" description="hook_stream_wrappers_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_load" value="/**&#10; * Implements hook_file_load().&#10; *&#10; * Load additional information into file objects.&#10; *&#10; * file_load_multiple() calls this hook to allow modules to load&#10; * additional information into each file.&#10; *&#10; * @param $files&#10; *   An array of file objects, indexed by fid.&#10; *&#10; * @see file_load_multiple()&#10; * @see upload_file_load()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_load($files) {&#10;  // Add the upload specific data into the file object.&#10;  $result = db_query('SELECT * FROM {upload} u WHERE u.fid IN (:fids)', array(':fids' =&gt; array_keys($files)))-&gt;fetchAll(PDO::FETCH_ASSOC);&#10;  foreach ($result as $record) {&#10;    foreach ($record as $key =&gt; $value) {&#10;      $files[$record['fid']]-&gt;$key = $value;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_load" value="/**&#10; * Implements hook_file_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_load($files) {&#10;  // Add the upload specific data into the file object.&#10;  $result = db_query('SELECT * FROM {upload} u WHERE u.fid IN (:fids)', array(':fids' =&gt; array_keys($files)))-&gt;fetchAll(PDO::FETCH_ASSOC);&#10;  foreach ($result as $record) {&#10;    foreach ($record as $key =&gt; $value) {&#10;      $files[$record['fid']]-&gt;$key = $value;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_validate" value="/**&#10; * Implements hook_file_validate().&#10; *&#10; * Check that files meet a given criteria.&#10; *&#10; * This hook lets modules perform additional validation on files. They're able&#10; * to report a failure by returning one or more error messages.&#10; *&#10; * @param $file&#10; *   The file object being validated.&#10; * @return&#10; *   An array of error messages. If there are no problems with the file return&#10; *   an empty array.&#10; *&#10; * @see file_validate()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_validate($file) {&#10;  $errors = array();&#10;&#10;  if (empty($file-&gt;filename)) {&#10;    $errors[] = t(&quot;The file's name is empty. Please give a name to the file.&quot;);&#10;  }&#10;  if (strlen($file-&gt;filename) &gt; 255) {&#10;    $errors[] = t(&quot;The file's name exceeds the 255 characters limit. Please rename the file and try again.&quot;);&#10;  }&#10;&#10;  return $errors;&#10;  $END$&#10;}" description="hook_file_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_validate" value="/**&#10; * Implements hook_file_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_validate($file) {&#10;  $errors = array();&#10;&#10;  if (empty($file-&gt;filename)) {&#10;    $errors[] = t(&quot;The file's name is empty. Please give a name to the file.&quot;);&#10;  }&#10;  if (strlen($file-&gt;filename) &gt; 255) {&#10;    $errors[] = t(&quot;The file's name exceeds the 255 characters limit. Please rename the file and try again.&quot;);&#10;  }&#10;&#10;  return $errors;&#10;  $END$&#10;}" description="hook_file_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_presave" value="/**&#10; * Implements hook_file_presave().&#10; *&#10; * Act on a file being inserted or updated.&#10; *&#10; * This hook is called when a file has been added to the database. The hook&#10; * doesn't distinguish between files created as a result of a copy or those&#10; * created by an upload.&#10; *&#10; * @param $file&#10; *   The file that has just been created.&#10; *&#10; * @see file_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_presave($file) {&#10;  // Change the file timestamp to an hour prior.&#10;  $file-&gt;timestamp -= 3600;&#10;  $END$&#10;}" description="hook_file_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_presave" value="/**&#10; * Implements hook_file_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_presave($file) {&#10;  // Change the file timestamp to an hour prior.&#10;  $file-&gt;timestamp -= 3600;&#10;  $END$&#10;}" description="hook_file_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_insert" value="/**&#10; * Implements hook_file_insert().&#10; *&#10; * Respond to a file being added.&#10; *&#10; * This hook is called after a file has been added to the database. The hook&#10; * doesn't distinguish between files created as a result of a copy or those&#10; * created by an upload.&#10; *&#10; * @param $file&#10; *   The file that has been added.&#10; *&#10; * @see file_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_insert($file) {&#10;  // Add a message to the log, if the file is a jpg&#10;  $validate = file_validate_extensions($file, 'jpg');&#10;  if (empty($validate)) {&#10;    watchdog('file', 'A jpg has been added.');&#10;  }&#10;  $END$&#10;}" description="hook_file_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_insert" value="/**&#10; * Implements hook_file_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_insert($file) {&#10;  // Add a message to the log, if the file is a jpg&#10;  $validate = file_validate_extensions($file, 'jpg');&#10;  if (empty($validate)) {&#10;    watchdog('file', 'A jpg has been added.');&#10;  }&#10;  $END$&#10;}" description="hook_file_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_update" value="/**&#10; * Implements hook_file_update().&#10; *&#10; * Respond to a file being updated.&#10; *&#10; * This hook is called when file_save() is called on an existing file.&#10; *&#10; * @param $file&#10; *   The file that has just been updated.&#10; *&#10; * @see file_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_update($file) {&#10;&#10;  $END$&#10;}" description="hook_file_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_update" value="/**&#10; * Implements hook_file_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_update($file) {&#10;&#10;  $END$&#10;}" description="hook_file_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_copy" value="/**&#10; * Implements hook_file_copy().&#10; *&#10; * Respond to a file that has been copied.&#10; *&#10; * @param $file&#10; *   The newly copied file object.&#10; * @param $source&#10; *   The original file before the copy.&#10; *&#10; * @see file_copy()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_copy($file, $source) {&#10;&#10;  $END$&#10;}" description="hook_file_copy" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_copy" value="/**&#10; * Implements hook_file_copy().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_copy($file, $source) {&#10;&#10;  $END$&#10;}" description="hook_file_copy" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_move" value="/**&#10; * Implements hook_file_move().&#10; *&#10; * Respond to a file that has been moved.&#10; *&#10; * @param $file&#10; *   The updated file object after the move.&#10; * @param $source&#10; *   The original file object before the move.&#10; *&#10; * @see file_move()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_move($file, $source) {&#10;&#10;  $END$&#10;}" description="hook_file_move" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_move" value="/**&#10; * Implements hook_file_move().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_move($file, $source) {&#10;&#10;  $END$&#10;}" description="hook_file_move" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_delete" value="/**&#10; * Implements hook_file_delete().&#10; *&#10; * Respond to a file being deleted.&#10; *&#10; * @param $file&#10; *   The file that has just been deleted.&#10; *&#10; * @see file_delete()&#10; * @see upload_file_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_delete($file) {&#10;  // Delete all information associated with the file.&#10;  db_delete('upload')-&gt;condition('fid', $file-&gt;fid)-&gt;execute();&#10;  $END$&#10;}" description="hook_file_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_delete" value="/**&#10; * Implements hook_file_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_delete($file) {&#10;  // Delete all information associated with the file.&#10;  db_delete('upload')-&gt;condition('fid', $file-&gt;fid)-&gt;execute();&#10;  $END$&#10;}" description="hook_file_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_download" value="/**&#10; * Implements hook_file_download().&#10; *&#10; * Control access to private file downloads and specify HTTP headers.&#10; *&#10; * This hook allows modules enforce permissions on file downloads when the&#10; * private file download method is selected. Modules can also provide headers&#10; * to specify information like the file's name or MIME type.&#10; *&#10; * @param $uri&#10; *   The URI of the file.&#10; * @return&#10; *   If the user does not have permission to access the file, return -1. If the&#10; *   user has permission, return an array with the appropriate headers. If the&#10; *   file is not controlled by the current module, the return value should be&#10; *   NULL.&#10; *&#10; * @see file_download()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download($uri) {&#10;  // Check if the file is controlled by the current module.&#10;  if (!file_prepare_directory($uri)) {&#10;    $uri = FALSE;&#10;  }&#10;  if (strpos(file_uri_target($uri), variable_get('user_picture_path', 'pictures') . '/picture-') === 0) {&#10;    if (!user_access('access user profiles')) {&#10;      // Access to the file is denied.&#10;      return -1;&#10;    }&#10;    else {&#10;      $info = image_get_info($uri);&#10;      return array('Content-Type' =&gt; $info['mime_type']);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_download" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_download" value="/**&#10; * Implements hook_file_download().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download($uri) {&#10;  // Check if the file is controlled by the current module.&#10;  if (!file_prepare_directory($uri)) {&#10;    $uri = FALSE;&#10;  }&#10;  if (strpos(file_uri_target($uri), variable_get('user_picture_path', 'pictures') . '/picture-') === 0) {&#10;    if (!user_access('access user profiles')) {&#10;      // Access to the file is denied.&#10;      return -1;&#10;    }&#10;    else {&#10;      $info = image_get_info($uri);&#10;      return array('Content-Type' =&gt; $info['mime_type']);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_download" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_url_alter" value="/**&#10; * Implements hook_file_url_alter().&#10; *&#10; * Alter the URL to a file.&#10; *&#10; * This hook is called from file_create_url(), and  is called fairly&#10; * frequently (10+ times per page), depending on how many files there are in a&#10; * given page.&#10; * If CSS and JS aggregation are disabled, this can become very frequently&#10; * (50+ times per page) so performance is critical.&#10; *&#10; * This function should alter the URI, if it wants to rewrite the file URL.&#10; *&#10; * @param $uri&#10; *   The URI to a file for which we need an external URL, or the path to a&#10; *   shipped file.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_url_alter(&amp;$uri) {&#10;  global $user;&#10;&#10;  // User 1 will always see the local file in this example.&#10;  if ($user-&gt;uid == 1) {&#10;    return;&#10;  }&#10;&#10;  $cdn1 = 'http://cdn1.example.com';&#10;  $cdn2 = 'http://cdn2.example.com';&#10;  $cdn_extensions = array('css', 'js', 'gif', 'jpg', 'jpeg', 'png');&#10;&#10;  // Most CDNs don't support private file transfers without a lot of hassle,&#10;  // so don't support this in the common case.&#10;  $schemes = array('public');&#10;&#10;  $scheme = file_uri_scheme($uri);&#10;&#10;  // Only serve shipped files and public created files from the CDN.&#10;  if (!$scheme || in_array($scheme, $schemes)) {&#10;    // Shipped files.&#10;    if (!$scheme) {&#10;      $path = $uri;&#10;    }&#10;    // Public created files.&#10;    else {&#10;      $wrapper = file_stream_wrapper_get_instance_by_scheme($scheme);&#10;      $path = $wrapper-&gt;getDirectoryPath() . '/' . file_uri_target($uri);&#10;    }&#10;&#10;    // Clean up Windows paths.&#10;    $path = str_replace('\\', '/', $path);&#10;&#10;    // Serve files with one of the CDN extensions from CDN 1, all others from&#10;    // CDN 2.&#10;    $pathinfo = pathinfo($path);&#10;    if (isset($pathinfo['extension']) &amp;&amp; in_array($pathinfo['extension'], $cdn_extensions)) {&#10;      $uri = $cdn1 . '/' . $path;&#10;    }&#10;    else {&#10;      $uri = $cdn2 . '/' . $path;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_url_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_url_alter" value="/**&#10; * Implements hook_file_url_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_url_alter(&amp;$uri) {&#10;  global $user;&#10;&#10;  // User 1 will always see the local file in this example.&#10;  if ($user-&gt;uid == 1) {&#10;    return;&#10;  }&#10;&#10;  $cdn1 = 'http://cdn1.example.com';&#10;  $cdn2 = 'http://cdn2.example.com';&#10;  $cdn_extensions = array('css', 'js', 'gif', 'jpg', 'jpeg', 'png');&#10;&#10;  // Most CDNs don't support private file transfers without a lot of hassle,&#10;  // so don't support this in the common case.&#10;  $schemes = array('public');&#10;&#10;  $scheme = file_uri_scheme($uri);&#10;&#10;  // Only serve shipped files and public created files from the CDN.&#10;  if (!$scheme || in_array($scheme, $schemes)) {&#10;    // Shipped files.&#10;    if (!$scheme) {&#10;      $path = $uri;&#10;    }&#10;    // Public created files.&#10;    else {&#10;      $wrapper = file_stream_wrapper_get_instance_by_scheme($scheme);&#10;      $path = $wrapper-&gt;getDirectoryPath() . '/' . file_uri_target($uri);&#10;    }&#10;&#10;    // Clean up Windows paths.&#10;    $path = str_replace('\\', '/', $path);&#10;&#10;    // Serve files with one of the CDN extensions from CDN 1, all others from&#10;    // CDN 2.&#10;    $pathinfo = pathinfo($path);&#10;    if (isset($pathinfo['extension']) &amp;&amp; in_array($pathinfo['extension'], $cdn_extensions)) {&#10;      $uri = $cdn1 . '/' . $path;&#10;    }&#10;    else {&#10;      $uri = $cdn2 . '/' . $path;&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_file_url_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_requirements" value="/**&#10; * Implements hook_requirements().&#10; *&#10; * Check installation requirements and do status reporting.&#10; *&#10; * This hook has three closely related uses, determined by the $phase argument:&#10; * - Checking installation requirements ($phase == 'install').&#10; * - Checking update requirements ($phase == 'update').&#10; * - Status reporting ($phase == 'runtime').&#10; *&#10; * Note that this hook, like all others dealing with installation and updates,&#10; * must reside in a module_name.install file, or it will not properly abort&#10; * the installation of the module if a critical requirement is missing.&#10; *&#10; * During the 'install' phase, modules can for example assert that&#10; * library or server versions are available or sufficient.&#10; * Note that the installation of a module can happen during installation of&#10; * Drupal itself (by install.php) with an installation profile or later by hand.&#10; * As a consequence, install-time requirements must be checked without access&#10; * to the full Drupal API, because it is not available during install.php.&#10; * For localization you should for example use $t = get_t() to&#10; * retrieve the appropriate localization function name (t() or st()).&#10; * If a requirement has a severity of REQUIREMENT_ERROR, install.php will abort&#10; * or at least the module will not install.&#10; * Other severity levels have no effect on the installation.&#10; * Module dependencies do not belong to these installation requirements,&#10; * but should be defined in the module's .info file.&#10; *&#10; * The 'runtime' phase is not limited to pure installation requirements&#10; * but can also be used for more general status information like maintenance&#10; * tasks and security issues.&#10; * The returned 'requirements' will be listed on the status report in the&#10; * administration section, with indication of the severity level.&#10; * Moreover, any requirement with a severity of REQUIREMENT_ERROR severity will&#10; * result in a notice on the the administration overview page.&#10; *&#10; * @param $phase&#10; *   The phase in which requirements are checked:&#10; *   - install: The module is being installed.&#10; *   - update: The module is enabled and update.php is run.&#10; *   - runtime: The runtime requirements are being checked and shown on the&#10; *     status report page.&#10; *&#10; * @return&#10; *   A keyed array of requirements. Each requirement is itself an array with&#10; *   the following items:&#10; *   - title: The name of the requirement.&#10; *   - value: The current value (e.g., version, time, level, etc). During&#10; *     install phase, this should only be used for version numbers, do not set&#10; *     it if not applicable.&#10; *   - description: The description of the requirement/status.&#10; *   - severity: The requirement's result/severity level, one of:&#10; *     - REQUIREMENT_INFO: For info only.&#10; *     - REQUIREMENT_OK: The requirement is satisfied.&#10; *     - REQUIREMENT_WARNING: The requirement failed with a warning.&#10; *     - REQUIREMENT_ERROR: The requirement failed with an error.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_requirements($phase) {&#10;  $requirements = array();&#10;  // Ensure translations don't break at install time&#10;  $t = get_t();&#10;&#10;  // Report Drupal version&#10;  if ($phase == 'runtime') {&#10;    $requirements['drupal'] = array(&#10;      'title' =&gt; $t('Drupal'),&#10;      'value' =&gt; VERSION,&#10;      'severity' =&gt; REQUIREMENT_INFO&#10;    );&#10;  }&#10;&#10;  // Test PHP version&#10;  $requirements['php'] = array(&#10;    'title' =&gt; $t('PHP'),&#10;    'value' =&gt; ($phase == 'runtime') ? l(phpversion(), 'admin/logs/status/php') : phpversion(),&#10;  );&#10;  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) &lt; 0) {&#10;    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' =&gt; DRUPAL_MINIMUM_PHP));&#10;    $requirements['php']['severity'] = REQUIREMENT_ERROR;&#10;  }&#10;&#10;  // Report cron status&#10;  if ($phase == 'runtime') {&#10;    $cron_last = variable_get('cron_last');&#10;&#10;    if (is_numeric($cron_last)) {&#10;      $requirements['cron']['value'] = $t('Last run !time ago', array('!time' =&gt; format_interval(REQUEST_TIME - $cron_last)));&#10;    }&#10;    else {&#10;      $requirements['cron'] = array(&#10;        'description' =&gt; $t('Cron has not run. It appears cron jobs have not been setup on your system. Check the help pages for &lt;a href=&quot;@url&quot;&gt;configuring cron jobs&lt;/a&gt;.', array('@url' =&gt; 'http://drupal.org/cron')),&#10;        'severity' =&gt; REQUIREMENT_ERROR,&#10;        'value' =&gt; $t('Never run'),&#10;      );&#10;    }&#10;&#10;    $requirements['cron']['description'] .= ' ' . $t('You can &lt;a href=&quot;@cron&quot;&gt;run cron manually&lt;/a&gt;.', array('@cron' =&gt; url('admin/logs/status/run-cron')));&#10;&#10;    $requirements['cron']['title'] = $t('Cron maintenance tasks');&#10;  }&#10;&#10;  return $requirements;&#10;  $END$&#10;}" description="hook_requirements" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_requirements" value="/**&#10; * Implements hook_requirements().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_requirements($phase) {&#10;  $requirements = array();&#10;  // Ensure translations don't break at install time&#10;  $t = get_t();&#10;&#10;  // Report Drupal version&#10;  if ($phase == 'runtime') {&#10;    $requirements['drupal'] = array(&#10;      'title' =&gt; $t('Drupal'),&#10;      'value' =&gt; VERSION,&#10;      'severity' =&gt; REQUIREMENT_INFO&#10;    );&#10;  }&#10;&#10;  // Test PHP version&#10;  $requirements['php'] = array(&#10;    'title' =&gt; $t('PHP'),&#10;    'value' =&gt; ($phase == 'runtime') ? l(phpversion(), 'admin/logs/status/php') : phpversion(),&#10;  );&#10;  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) &lt; 0) {&#10;    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' =&gt; DRUPAL_MINIMUM_PHP));&#10;    $requirements['php']['severity'] = REQUIREMENT_ERROR;&#10;  }&#10;&#10;  // Report cron status&#10;  if ($phase == 'runtime') {&#10;    $cron_last = variable_get('cron_last');&#10;&#10;    if (is_numeric($cron_last)) {&#10;      $requirements['cron']['value'] = $t('Last run !time ago', array('!time' =&gt; format_interval(REQUEST_TIME - $cron_last)));&#10;    }&#10;    else {&#10;      $requirements['cron'] = array(&#10;        'description' =&gt; $t('Cron has not run. It appears cron jobs have not been setup on your system. Check the help pages for &lt;a href=&quot;@url&quot;&gt;configuring cron jobs&lt;/a&gt;.', array('@url' =&gt; 'http://drupal.org/cron')),&#10;        'severity' =&gt; REQUIREMENT_ERROR,&#10;        'value' =&gt; $t('Never run'),&#10;      );&#10;    }&#10;&#10;    $requirements['cron']['description'] .= ' ' . $t('You can &lt;a href=&quot;@cron&quot;&gt;run cron manually&lt;/a&gt;.', array('@cron' =&gt; url('admin/logs/status/run-cron')));&#10;&#10;    $requirements['cron']['title'] = $t('Cron maintenance tasks');&#10;  }&#10;&#10;  return $requirements;&#10;  $END$&#10;}" description="hook_requirements" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_schema" value="/**&#10; * Implements hook_schema().&#10; *&#10; * Define the current version of the database schema.&#10; *&#10; * A Drupal schema definition is an array structure representing one or&#10; * more tables and their related keys and indexes. A schema is defined by&#10; * hook_schema() which must live in your module's .install file.&#10; *&#10; * This hook is called at both install and uninstall time, and in the latter&#10; * case, it cannot rely on the .module file being loaded or hooks being known.&#10; * If the .module file is needed, it may be loaded with drupal_load().&#10; *&#10; * The tables declared by this hook will be automatically created when&#10; * the module is first enabled, and removed when the module is uninstalled.&#10; * This happens before hook_install() is invoked, and after hook_uninstall()&#10; * is invoked, respectively.&#10; *&#10; * By declaring the tables used by your module via an implementation of&#10; * hook_schema(), these tables will be available on all supported database&#10; * engines. You don't have to deal with the different SQL dialects for table&#10; * creation and alteration of the supported database engines *&#10; * See the Schema API Handbook at http://drupal.org/node/146843 for&#10; * details on schema definition structures.&#10; *&#10; * @return&#10; *   A schema definition structure array. For each element of the&#10; *   array, the key is a table name and the value is a table structure&#10; *   definition.&#10; *&#10; * @ingroup schemaapi&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_schema() {&#10;  $schema['node'] = array(&#10;    // example (partial) specification for table &quot;node&quot;&#10;    'description' =&gt; 'The base table for nodes.',&#10;    'fields' =&gt; array(&#10;      'nid' =&gt; array(&#10;        'description' =&gt; 'The primary identifier for a node.',&#10;        'type' =&gt; 'serial',&#10;        'unsigned' =&gt; TRUE,&#10;        'not null' =&gt; TRUE),&#10;      'vid' =&gt; array(&#10;        'description' =&gt; 'The current {node_revision}.vid version identifier.',&#10;        'type' =&gt; 'int',&#10;        'unsigned' =&gt; TRUE,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; 0),&#10;      'type' =&gt; array(&#10;        'description' =&gt; 'The {node_type} of this node.',&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; 32,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; ''),&#10;      'title' =&gt; array(&#10;        'description' =&gt; 'The title of this node, always treated as non-markup plain text.',&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; 255,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; ''),&#10;      ),&#10;    'indexes' =&gt; array(&#10;      'node_changed'        =&gt; array('changed'),&#10;      'node_created'        =&gt; array('created'),&#10;      ),&#10;    'unique keys' =&gt; array(&#10;      'nid_vid' =&gt; array('nid', 'vid'),&#10;      'vid'     =&gt; array('vid')&#10;      ),&#10;    'foreign keys' =&gt; array(&#10;      'node_revision' =&gt; array(&#10;        'table' =&gt; 'node_revision',&#10;        'columns' =&gt; array('vid' =&gt; 'vid'),&#10;        ),&#10;      'node_author' =&gt; array(&#10;        'table' =&gt; 'users',&#10;        'columns' =&gt; array('uid' =&gt; 'uid')&#10;        ),&#10;       ),&#10;    'primary key' =&gt; array('nid'),&#10;  );&#10;  return $schema;&#10;  $END$&#10;}" description="hook_schema" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_schema" value="/**&#10; * Implements hook_schema().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_schema() {&#10;  $schema['node'] = array(&#10;    // example (partial) specification for table &quot;node&quot;&#10;    'description' =&gt; 'The base table for nodes.',&#10;    'fields' =&gt; array(&#10;      'nid' =&gt; array(&#10;        'description' =&gt; 'The primary identifier for a node.',&#10;        'type' =&gt; 'serial',&#10;        'unsigned' =&gt; TRUE,&#10;        'not null' =&gt; TRUE),&#10;      'vid' =&gt; array(&#10;        'description' =&gt; 'The current {node_revision}.vid version identifier.',&#10;        'type' =&gt; 'int',&#10;        'unsigned' =&gt; TRUE,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; 0),&#10;      'type' =&gt; array(&#10;        'description' =&gt; 'The {node_type} of this node.',&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; 32,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; ''),&#10;      'title' =&gt; array(&#10;        'description' =&gt; 'The title of this node, always treated as non-markup plain text.',&#10;        'type' =&gt; 'varchar',&#10;        'length' =&gt; 255,&#10;        'not null' =&gt; TRUE,&#10;        'default' =&gt; ''),&#10;      ),&#10;    'indexes' =&gt; array(&#10;      'node_changed'        =&gt; array('changed'),&#10;      'node_created'        =&gt; array('created'),&#10;      ),&#10;    'unique keys' =&gt; array(&#10;      'nid_vid' =&gt; array('nid', 'vid'),&#10;      'vid'     =&gt; array('vid')&#10;      ),&#10;    'foreign keys' =&gt; array(&#10;      'node_revision' =&gt; array(&#10;        'table' =&gt; 'node_revision',&#10;        'columns' =&gt; array('vid' =&gt; 'vid'),&#10;        ),&#10;      'node_author' =&gt; array(&#10;        'table' =&gt; 'users',&#10;        'columns' =&gt; array('uid' =&gt; 'uid')&#10;        ),&#10;       ),&#10;    'primary key' =&gt; array('nid'),&#10;  );&#10;  return $schema;&#10;  $END$&#10;}" description="hook_schema" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_schema_alter" value="/**&#10; * Implements hook_schema_alter().&#10; *&#10; * Perform alterations to existing database schemas.&#10; *&#10; * When a module modifies the database structure of another module (by&#10; * changing, adding or removing fields, keys or indexes), it should&#10; * implement hook_schema_alter() to update the default $schema to take its&#10; * changes into account.&#10; *&#10; * See hook_schema() for details on the schema definition structure.&#10; *&#10; * @param $schema&#10; *   Nested array describing the schemas for all modules.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_schema_alter(&amp;$schema) {&#10;  // Add field to existing schema.&#10;  $schema['users']['fields']['timezone_id'] = array(&#10;    'type' =&gt; 'int',&#10;    'not null' =&gt; TRUE,&#10;    'default' =&gt; 0,&#10;    'description' =&gt; 'Per-user timezone configuration.',&#10;  );&#10;  $END$&#10;}" description="hook_schema_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_schema_alter" value="/**&#10; * Implements hook_schema_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_schema_alter(&amp;$schema) {&#10;  // Add field to existing schema.&#10;  $schema['users']['fields']['timezone_id'] = array(&#10;    'type' =&gt; 'int',&#10;    'not null' =&gt; TRUE,&#10;    'default' =&gt; 0,&#10;    'description' =&gt; 'Per-user timezone configuration.',&#10;  );&#10;  $END$&#10;}" description="hook_schema_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_query_alter" value="/**&#10; * Implements hook_query_alter().&#10; *&#10; * Perform alterations to a structured query.&#10; *&#10; * Structured (aka dynamic) queries that have tags associated may be altered by any module&#10; * before the query is executed.&#10; *&#10; * @param $query&#10; *   A Query object describing the composite parts of a SQL query.&#10; *&#10; * @see hook_query_TAG_alter()&#10; * @see node_query_node_access_alter()&#10; * @see QueryAlterableInterface&#10; * @see SelectQueryInterface&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_query_alter(QueryAlterableInterface $query) {&#10;  if ($query-&gt;hasTag('micro_limit')) {&#10;    $query-&gt;range(0, 2);&#10;  }&#10;  $END$&#10;}" description="hook_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_query_alter" value="/**&#10; * Implements hook_query_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_query_alter(QueryAlterableInterface $query) {&#10;  if ($query-&gt;hasTag('micro_limit')) {&#10;    $query-&gt;range(0, 2);&#10;  }&#10;  $END$&#10;}" description="hook_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_query_TAG_alter" value="/**&#10; * Implements hook_query_TAG_alter().&#10; *&#10; * Perform alterations to a structured query for a given tag.&#10; *&#10; * @param $query&#10; *   An Query object describing the composite parts of a SQL query.&#10; *&#10; * @see hook_query_alter()&#10; * @see node_query_node_access_alter()&#10; * @see QueryAlterableInterface&#10; * @see SelectQueryInterface&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_query_TAG_alter(QueryAlterableInterface $query) {&#10;  // Skip the extra expensive alterations if site has no node access control modules.&#10;  if (!node_access_view_all_nodes()) {&#10;    // Prevent duplicates records.&#10;    $query-&gt;distinct();&#10;    // The recognized operations are 'view', 'update', 'delete'.&#10;    if (!$op = $query-&gt;getMetaData('op')) {&#10;      $op = 'view';&#10;    }&#10;    // Skip the extra joins and conditions for node admins.&#10;    if (!user_access('bypass node access')) {&#10;      // The node_access table has the access grants for any given node.&#10;      $access_alias = $query-&gt;join('node_access', 'na', '%alias.nid = n.nid');&#10;      $or = db_or();&#10;      // If any grant exists for the specified user, then user has access to the node for the specified operation.&#10;      foreach (node_access_grants($op, $query-&gt;getMetaData('account')) as $realm =&gt; $gids) {&#10;        foreach ($gids as $gid) {&#10;          $or-&gt;condition(db_and()&#10;            -&gt;condition($access_alias . '.gid', $gid)&#10;            -&gt;condition($access_alias . '.realm', $realm)&#10;          );&#10;        }&#10;      }&#10;&#10;      if (count($or-&gt;conditions())) {&#10;        $query-&gt;condition($or);&#10;      }&#10;&#10;      $query-&gt;condition($access_alias . 'grant_' . $op, 1, '&gt;=');&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_query_TAG_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_query_TAG_alter" value="/**&#10; * Implements hook_query_TAG_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_query_TAG_alter(QueryAlterableInterface $query) {&#10;  // Skip the extra expensive alterations if site has no node access control modules.&#10;  if (!node_access_view_all_nodes()) {&#10;    // Prevent duplicates records.&#10;    $query-&gt;distinct();&#10;    // The recognized operations are 'view', 'update', 'delete'.&#10;    if (!$op = $query-&gt;getMetaData('op')) {&#10;      $op = 'view';&#10;    }&#10;    // Skip the extra joins and conditions for node admins.&#10;    if (!user_access('bypass node access')) {&#10;      // The node_access table has the access grants for any given node.&#10;      $access_alias = $query-&gt;join('node_access', 'na', '%alias.nid = n.nid');&#10;      $or = db_or();&#10;      // If any grant exists for the specified user, then user has access to the node for the specified operation.&#10;      foreach (node_access_grants($op, $query-&gt;getMetaData('account')) as $realm =&gt; $gids) {&#10;        foreach ($gids as $gid) {&#10;          $or-&gt;condition(db_and()&#10;            -&gt;condition($access_alias . '.gid', $gid)&#10;            -&gt;condition($access_alias . '.realm', $realm)&#10;          );&#10;        }&#10;      }&#10;&#10;      if (count($or-&gt;conditions())) {&#10;        $query-&gt;condition($or);&#10;      }&#10;&#10;      $query-&gt;condition($access_alias . 'grant_' . $op, 1, '&gt;=');&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_query_TAG_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_install" value="/**&#10; * Implements hook_install().&#10; *&#10; * Perform setup tasks when the module is installed.&#10; *&#10; * If the module implements hook_schema(), the database tables will&#10; * be created before this hook is fired.&#10; *&#10; * Implementations of this hook are by convention declared in the module's&#10; * .install file. The implementation can rely on the .module file being loaded.&#10; * The hook will only be called the first time a module is enabled or after it&#10; * is re-enabled after being uninstalled. The module's schema version will be&#10; * set to the module's greatest numbered update hook. Because of this, any time&#10; * a hook_update_N() is added to the module, this function needs to be updated&#10; * to reflect the current version of the database schema.&#10; *&#10; * See the Schema API documentation at&#10; * @link http://drupal.org/node/146843 http://drupal.org/node/146843 @endlink&#10; * for details on hook_schema and how database tables are defined.&#10; *&#10; * Note that since this function is called from a full bootstrap, all functions&#10; * (including those in modules enabled by the current page request) are&#10; * available when this hook is called. Use cases could be displaying a user&#10; * message, or calling a module function necessary for initial setup, etc.&#10; *&#10; * Please be sure that anything added or modified in this function that can&#10; * be removed during uninstall should be removed with hook_uninstall().&#10; *&#10; * @see hook_schema()&#10; * @see module_enable()&#10; * @see hook_enable()&#10; * @see hook_disable()&#10; * @see hook_uninstall()&#10; * @see hook_modules_installed()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install() {&#10;  // Populate the default {node_access} record.&#10;  db_insert('node_access')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; 0,&#10;      'gid' =&gt; 0,&#10;      'realm' =&gt; 'all',&#10;      'grant_view' =&gt; 1,&#10;      'grant_update' =&gt; 0,&#10;      'grant_delete' =&gt; 0,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_install" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_install" value="/**&#10; * Implements hook_install().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install() {&#10;  // Populate the default {node_access} record.&#10;  db_insert('node_access')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; 0,&#10;      'gid' =&gt; 0,&#10;      'realm' =&gt; 'all',&#10;      'grant_view' =&gt; 1,&#10;      'grant_update' =&gt; 0,&#10;      'grant_delete' =&gt; 0,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_install" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_N" value="/**&#10; * Implements hook_update_N().&#10; *&#10; * Perform a single update.&#10; *&#10; * For each patch which requires a database change add a new hook_update_N()&#10; * which will be called by update.php. The database updates are numbered&#10; * sequentially according to the version of Drupal you are compatible with.&#10; *&#10; * Schema updates should adhere to the Schema API:&#10; * @link http://drupal.org/node/150215 http://drupal.org/node/150215 @endlink&#10; *&#10; * Database updates consist of 3 parts:&#10; * - 1 digit for Drupal core compatibility&#10; * - 1 digit for your module's major release version (e.g. is this the 5.x-1.* (1) or 5.x-2.* (2) series of your module?)&#10; * - 2 digits for sequential counting starting with 00&#10; *&#10; * The 2nd digit should be 0 for initial porting of your module to a new Drupal&#10; * core API.&#10; *&#10; * Examples:&#10; * - mymodule_update_5200()&#10; *   - This is the first update to get the database ready to run mymodule 5.x-2.*.&#10; * - mymodule_update_6000()&#10; *   - This is the required update for mymodule to run with Drupal core API 6.x.&#10; * - mymodule_update_6100()&#10; *   - This is the first update to get the database ready to run mymodule 6.x-1.*.&#10; * - mymodule_update_6200()&#10; *   - This is the first update to get the database ready to run mymodule 6.x-2.*.&#10; *     Users can directly update from 5.x-2.* to 6.x-2.* and they get all 60XX&#10; *     and 62XX updates, but not 61XX updates, because those reside in the&#10; *     6.x-1.x branch only.&#10; *&#10; * A good rule of thumb is to remove updates older than two major releases of&#10; * Drupal. See hook_update_last_removed() to notify Drupal about the removals.&#10; *&#10; * Never renumber update functions.&#10; *&#10; * Further information about releases and release numbers:&#10; * - @link http://drupal.org/handbook/version-info http://drupal.org/handbook/version-info @endlink&#10; * - @link http://drupal.org/node/93999 http://drupal.org/node/93999 @endlink (Overview of contributions branches and tags)&#10; * - @link http://drupal.org/handbook/cvs/releases http://drupal.org/handbook/cvs/releases @endlink&#10; *&#10; * Implementations of this hook should be placed in a mymodule.install file in&#10; * the same directory as mymodule.module. Drupal core's updates are implemented&#10; * using the system module as a name and stored in database/updates.inc.&#10; *&#10; * If your update task is potentially time-consuming, you'll need to implement a&#10; * multipass update to avoid PHP timeouts. Multipass updates use the $sandbox&#10; * parameter provided by the batch API (normally, $context['sandbox']) to store&#10; * information between successive calls, and the $sandbox['#finished'] value&#10; * to provide feedback regarding completion level.&#10; *&#10; * See the batch operations page for more information on how to use the batch API:&#10; * @link http://drupal.org/node/180528 http://drupal.org/node/180528 @endlink&#10; *&#10; * @param $sandbox&#10; *   Stores information for multipass updates. See above for more information.&#10; *&#10; * @throws DrupalUpdateException, PDOException&#10; *   In case of error, update hooks should throw an instance of DrupalUpdateException&#10; *   with a meaningful message for the user. If a database query fails for whatever&#10; *   reason, it will throw a PDOException.&#10; *&#10; * @return&#10; *   Optionally update hooks may return a translated string that will be displayed&#10; *   to the user. If no message is returned, no message will be presented to the&#10; *   user.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_N(&amp;$sandbox) {&#10;  // For non-multipass updates, the signature can simply be;&#10;  // function hook_update_N() {&#10;&#10;  // For most updates, the following is sufficient.&#10;  db_add_field('mytable1', 'newcol', array('type' =&gt; 'int', 'not null' =&gt; TRUE, 'description' =&gt; 'My new integer column.'));&#10;&#10;  // However, for more complex operations that may take a long time,&#10;  // you may hook into Batch API as in the following example.&#10;&#10;  // Update 3 users at a time to have an exclamation point after their names.&#10;  // (They're really happy that we can do batch API in this hook!)&#10;  if (!isset($sandbox['progress'])) {&#10;    $sandbox['progress'] = 0;&#10;    $sandbox['current_uid'] = 0;&#10;    // We'll -1 to disregard the uid 0...&#10;    $sandbox['max'] = db_query('SELECT COUNT(DISTINCT uid) FROM {users}')-&gt;fetchField() - 1;&#10;  }&#10;&#10;  $users = db_select('users', 'u')&#10;    -&gt;fields('u', array('uid', 'name'))&#10;    -&gt;condition('uid', $sandbox['current_uid'], '&gt;')&#10;    -&gt;range(0, 3)&#10;    -&gt;orderBy('uid', 'ASC')&#10;    -&gt;execute();&#10;&#10;  foreach ($users as $user) {&#10;    $user-&gt;name .= '!';&#10;    db_update('users')&#10;      -&gt;fields(array('name' =&gt; $user-&gt;name))&#10;      -&gt;condition('uid', $user-&gt;uid)&#10;      -&gt;execute();&#10;&#10;    $sandbox['progress']++;&#10;    $sandbox['current_uid'] = $user-&gt;uid;&#10;  }&#10;&#10;  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);&#10;&#10;  // To display a message to the user when the update is completed, return it.&#10;  // If you do not want to display a completion message, simply return nothing.&#10;  return t('The update did what it was supposed to do.');&#10;&#10;  // In case of an error, simply throw an exception with an error message.&#10;  throw new DrupalUpdateException('Something went wrong; here is what you should do.');&#10;  $END$&#10;}" description="hook_update_N" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_N" value="/**&#10; * Implements hook_update_N().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_$SCHEMA_VERSION$(&amp;$sandbox) {&#10;  $ret = t('$MESSAGE$');&#10;&#10;  $END$&#10;&#10;  return $ret;&#10;}" description="hook_update_N" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="SCHEMA_VERSION" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MESSAGE" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_dependencies" value="/**&#10; * Implements hook_update_dependencies().&#10; *&#10; * Return an array of information about module update dependencies.&#10; *&#10; * This can be used to indicate update functions from other modules that your&#10; * module's update functions depend on, or vice versa. It is used by the update&#10; * system to determine the appropriate order in which updates should be run, as&#10; * well as to search for missing dependencies.&#10; *&#10; * Implementations of this hook should be placed in a mymodule.install file in&#10; * the same directory as mymodule.module.&#10; *&#10; * @return&#10; *   A multidimensional array containing information about the module update&#10; *   dependencies. The first two levels of keys represent the module and update&#10; *   number (respectively) for which information is being returned, and the&#10; *   value is an array of information about that update's dependencies. Within&#10; *   this array, each key represents a module, and each value represents the&#10; *   number of an update function within that module. In the event that your&#10; *   update function depends on more than one update from a particular module,&#10; *   you should always list the highest numbered one here (since updates within&#10; *   a given module always run in numerical order).&#10; *&#10; * @see update_resolve_dependencies()&#10; * @see hook_update_N()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_dependencies() {&#10;  // Indicate that the mymodule_update_7000() function provided by this module&#10;  // must run after the another_module_update_7002() function provided by the&#10;  // 'another_module' module.&#10;  $dependencies['mymodule'][7000] = array(&#10;    'another_module' =&gt; 7002,&#10;  );&#10;  // Indicate that the mymodule_update_7001() function provided by this module&#10;  // must run before the yet_another_module_update_7004() function provided by&#10;  // the 'yet_another_module' module. (Note that declaring dependencies in this&#10;  // direction should be done only in rare situations, since it can lead to the&#10;  // following problem: If a site has already run the yet_another_module&#10;  // module's database updates before it updates its codebase to pick up the&#10;  // newest mymodule code, then the dependency declared here will be ignored.)&#10;  $dependencies['yet_another_module'][7004] = array(&#10;    'mymodule' =&gt; 7001,&#10;  );&#10;  return $dependencies;&#10;  $END$&#10;}" description="hook_update_dependencies" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_dependencies" value="/**&#10; * Implements hook_update_dependencies().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_dependencies() {&#10;  // Indicate that the mymodule_update_7000() function provided by this module&#10;  // must run after the another_module_update_7002() function provided by the&#10;  // 'another_module' module.&#10;  $dependencies['mymodule'][7000] = array(&#10;    'another_module' =&gt; 7002,&#10;  );&#10;  // Indicate that the mymodule_update_7001() function provided by this module&#10;  // must run before the yet_another_module_update_7004() function provided by&#10;  // the 'yet_another_module' module. (Note that declaring dependencies in this&#10;  // direction should be done only in rare situations, since it can lead to the&#10;  // following problem: If a site has already run the yet_another_module&#10;  // module's database updates before it updates its codebase to pick up the&#10;  // newest mymodule code, then the dependency declared here will be ignored.)&#10;  $dependencies['yet_another_module'][7004] = array(&#10;    'mymodule' =&gt; 7001,&#10;  );&#10;  return $dependencies;&#10;  $END$&#10;}" description="hook_update_dependencies" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_update_last_removed" value="/**&#10; * Implements hook_update_last_removed().&#10; *&#10; * Return a number which is no longer available as hook_update_N().&#10; *&#10; * If you remove some update functions from your mymodule.install file, you&#10; * should notify Drupal of those missing functions. This way, Drupal can&#10; * ensure that no update is accidentally skipped.&#10; *&#10; * Implementations of this hook should be placed in a mymodule.install file in&#10; * the same directory as mymodule.module.&#10; *&#10; * @return&#10; *   An integer, corresponding to hook_update_N() which has been removed from&#10; *   mymodule.install.&#10; *&#10; * @see hook_update_N()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_last_removed() {&#10;  // We've removed the 5.x-1.x version of mymodule, including database updates.&#10;  // The next update function is mymodule_update_5200().&#10;  return 5103;&#10;  $END$&#10;}" description="hook_update_last_removed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_update_last_removed" value="/**&#10; * Implements hook_update_last_removed().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_update_last_removed() {&#10;  // We've removed the 5.x-1.x version of mymodule, including database updates.&#10;  // The next update function is mymodule_update_5200().&#10;  return 5103;&#10;  $END$&#10;}" description="hook_update_last_removed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_uninstall" value="/**&#10; * Implements hook_uninstall().&#10; *&#10; * Remove any information that the module sets.&#10; *&#10; * The information that the module should remove includes:&#10; * - variables that the module has set using variable_set() or system_settings_form()&#10; * - modifications to existing tables&#10; *&#10; * The module should not remove its entry from the {system} table. Database&#10; * tables defined by hook_schema() will be removed automatically.&#10; *&#10; * The uninstall hook must be implemented in the module's .install file. It&#10; * will fire when the module gets uninstalled but before the module's database&#10; * tables are removed, allowing your module to query its own tables during&#10; * this routine.&#10; *&#10; * When hook_uninstall() is called, your module will already be disabled, so&#10; * its .module file will not be automatically included. If you need to call API&#10; * functions from your .module file in this hook, use drupal_load() to make&#10; * them available. (Keep this usage to a minimum, though, especially when&#10; * calling API functions that invoke hooks, or API functions from modules&#10; * listed as dependencies, since these may not be available or work as expected&#10; * when the module is disabled.)&#10; *&#10; * @see hook_install()&#10; * @see hook_schema()&#10; * @see hook_disable()&#10; * @see hook_modules_uninstalled()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_uninstall() {&#10;  variable_del('upload_file_types');&#10;  $END$&#10;}" description="hook_uninstall" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_uninstall" value="/**&#10; * Implements hook_uninstall().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_uninstall() {&#10;  variable_del('upload_file_types');&#10;  $END$&#10;}" description="hook_uninstall" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_enable" value="/**&#10; * Implements hook_enable().&#10; *&#10; * Perform necessary actions after module is enabled.&#10; *&#10; * The hook is called every time the module is enabled. It should be&#10; * implemented in the module's .install file. The implementation can&#10; * rely on the .module file being loaded.&#10; *&#10; * @see module_enable()&#10; * @see hook_install()&#10; * @see hook_modules_enabled()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_enable() {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_enable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_enable" value="/**&#10; * Implements hook_enable().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_enable() {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_enable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_disable" value="/**&#10; * Implements hook_disable().&#10; *&#10; * Perform necessary actions before module is disabled.&#10; *&#10; * The hook is called every time the module is disabled. It should be&#10; * implemented in the module's .install file. The implementation can rely&#10; * on the .module file being loaded.&#10; *&#10; * @see hook_uninstall()&#10; * @see hook_modules_disabled()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_disable() {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_disable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_disable" value="/**&#10; * Implements hook_disable().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_disable() {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_disable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_registry_files_alter" value="/**&#10; * Implements hook_registry_files_alter().&#10; *&#10; * Perform necessary alterations to the list of files parsed by the registry.&#10; *&#10; * Modules can manually modify the list of files before the registry parses&#10; * them. The $modules array provides the .info file information, which includes&#10; * the list of files registered to each module. Any files in the list can then&#10; * be added to the list of files that the registry will parse, or modify&#10; * attributes of a file.&#10; *&#10; * A necessary alteration made by the core SimpleTest module is to force .test&#10; * files provided by disabled modules into the list of files parsed by the&#10; * registry.&#10; *&#10; * @param $files&#10; *   List of files to be parsed by the registry. The list will contain&#10; *   files found in each enabled module's info file and the core includes&#10; *   directory. The array is keyed by the file path and contains an array of&#10; *   the related module's name and weight as used internally by&#10; *   _registry_update() and related functions.&#10; *&#10; *   For example:&#10; *   @code&#10; *     $files[&quot;modules/system/system.module&quot;] = array(&#10; *       'module' =&gt; 'system',&#10; *       'weight' =&gt; 0,&#10; *     );&#10; *   @endcode&#10; * @param $modules&#10; *   An array containing all module information stored in the {system} table.&#10; *   Each element of the array also contains the module's .info file&#10; *   information in the property 'info'. An additional 'dir' property has been&#10; *   added to the module information which provides the path to the directory&#10; *   in which the module resides. The example shows how to take advantage of&#10; *   both properties.&#10; *&#10; * @see _registry_update()&#10; * @see simpletest_test_get_all()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_registry_files_alter(&amp;$files, $modules) {&#10;  foreach ($modules as $module) {&#10;    // Only add test files for disabled modules, as enabled modules should&#10;    // already include any test files they provide.&#10;    if (!$module-&gt;status) {&#10;      $dir = $module-&gt;dir;&#10;      foreach ($module-&gt;info['files'] as $file) {&#10;        if (substr($file, -5) == '.test') {&#10;          $files[&quot;$dir/$file&quot;] = array('module' =&gt; $module-&gt;name, 'weight' =&gt; $module-&gt;weight);&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_registry_files_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_registry_files_alter" value="/**&#10; * Implements hook_registry_files_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_registry_files_alter(&amp;$files, $modules) {&#10;  foreach ($modules as $module) {&#10;    // Only add test files for disabled modules, as enabled modules should&#10;    // already include any test files they provide.&#10;    if (!$module-&gt;status) {&#10;      $dir = $module-&gt;dir;&#10;      foreach ($module-&gt;info['files'] as $file) {&#10;        if (substr($file, -5) == '.test') {&#10;          $files[&quot;$dir/$file&quot;] = array('module' =&gt; $module-&gt;name, 'weight' =&gt; $module-&gt;weight);&#10;        }&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_registry_files_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_install_tasks" value="/**&#10; * Implements hook_install_tasks().&#10; *&#10; * Return an array of tasks to be performed by an installation profile.&#10; *&#10; * Any tasks you define here will be run, in order, after the installer has&#10; * finished the site configuration step but before it has moved on to the&#10; * final import of languages and the end of the installation. You can have any&#10; * number of custom tasks to perform during this phase.&#10; *&#10; * Each task you define here corresponds to a callback function which you must&#10; * separately define and which is called when your task is run. This function&#10; * will receive the global installation state variable, $install_state, as&#10; * input, and has the opportunity to access or modify any of its settings. See&#10; * the install_state_defaults() function in the installer for the list of&#10; * $install_state settings used by Drupal core.&#10; *&#10; * At the end of your task function, you can indicate that you want the&#10; * installer to pause and display a page to the user by returning any themed&#10; * output that should be displayed on that page (but see below for tasks that&#10; * use the form API or batch API; the return values of these task functions are&#10; * handled differently). You should also use drupal_set_title() within the task&#10; * callback function to set a custom page title. For some tasks, however, you&#10; * may want to simply do some processing and pass control to the next task&#10; * without ending the page request; to indicate this, simply do not send back&#10; * a return value from your task function at all. This can be used, for&#10; * example, by installation profiles that need to configure certain site&#10; * settings in the database without obtaining any input from the user.&#10; *&#10; * The task function is treated specially if it defines a form or requires&#10; * batch processing; in that case, you should return either the form API&#10; * definition or batch API array, as appropriate. See below for more&#10; * information on the 'type' key that you must define in the task definition&#10; * to inform the installer that your task falls into one of those two&#10; * categories. It is important to use these APIs directly, since the installer&#10; * may be run non-interactively (for example, via a command line script), all&#10; * in one page request; in that case, the installer will automatically take&#10; * care of submitting forms and processing batches correctly for both types of&#10; * installations. You can inspect the $install_state['interactive'] boolean to&#10; * see whether or not the current installation is interactive, if you need&#10; * access to this information.&#10; *&#10; * Remember that a user installing Drupal interactively will be able to reload&#10; * an installation page multiple times, so you should use variable_set() and&#10; * variable_get() if you are collecting any data that you need to store and&#10; * inspect later. It is important to remove any temporary variables using&#10; * variable_del() before your last task has completed and control is handed&#10; * back to the installer.&#10; *&#10; * @return&#10; *   A keyed array of tasks the profile will perform during the final stage of&#10; *   the installation. Each key represents the name of a function (usually a&#10; *   function defined by this profile, although that is not strictly required)&#10; *   that is called when that task is run. The values are associative arrays&#10; *   containing the following key-value pairs (all of which are optional):&#10; *     - 'display_name'&#10; *       The human-readable name of the task. This will be displayed to the&#10; *       user while the installer is running, along with a list of other tasks&#10; *       that are being run. Leave this unset to prevent the task from&#10; *       appearing in the list.&#10; *     - 'display'&#10; *       This is a boolean which can be used to provide finer-grained control&#10; *       over whether or not the task will display. This is mostly useful for&#10; *       tasks that are intended to display only under certain conditions; for&#10; *       these tasks, you can set 'display_name' to the name that you want to&#10; *       display, but then use this boolean to hide the task only when certain&#10; *       conditions apply.&#10; *     - 'type'&#10; *       A string representing the type of task. This parameter has three&#10; *       possible values:&#10; *       - 'normal': This indicates that the task will be treated as a regular&#10; *       callback function, which does its processing and optionally returns&#10; *       HTML output. This is the default behavior which is used when 'type' is&#10; *       not set.&#10; *       - 'batch': This indicates that the task function will return a batch&#10; *       API definition suitable for batch_set(). The installer will then take&#10; *       care of automatically running the task via batch processing.&#10; *       - 'form': This indicates that the task function will return a standard&#10; *       form API definition (and separately define validation and submit&#10; *       handlers, as appropriate). The installer will then take care of&#10; *       automatically directing the user through the form submission process.&#10; *     - 'run'&#10; *       A constant representing the manner in which the task will be run. This&#10; *       parameter has three possible values:&#10; *       - INSTALL_TASK_RUN_IF_NOT_COMPLETED: This indicates that the task will&#10; *       run once during the installation of the profile. This is the default&#10; *       behavior which is used when 'run' is not set.&#10; *       - INSTALL_TASK_SKIP: This indicates that the task will not run during&#10; *       the current installation page request. It can be used to skip running&#10; *       an installation task when certain conditions are met, even though the&#10; *       task may still show on the list of installation tasks presented to the&#10; *       user.&#10; *       - INSTALL_TASK_RUN_IF_REACHED: This indicates that the task will run&#10; *       on each installation page request that reaches it. This is rarely&#10; *       necessary for an installation profile to use; it is primarily used by&#10; *       the Drupal installer for bootstrap-related tasks.&#10; *     - 'function'&#10; *       Normally this does not need to be set, but it can be used to force the&#10; *       installer to call a different function when the task is run (rather&#10; *       than the function whose name is given by the array key). This could be&#10; *       used, for example, to allow the same function to be called by two&#10; *       different tasks.&#10; *&#10; * @see install_state_defaults()&#10; * @see batch_set()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install_tasks() {&#10;  // Here, we define a variable to allow tasks to indicate that a particular,&#10;  // processor-intensive batch process needs to be triggered later on in the&#10;  // installation.&#10;  $myprofile_needs_batch_processing = variable_get('myprofile_needs_batch_processing', FALSE);&#10;  $tasks = array(&#10;    // This is an example of a task that defines a form which the user who is&#10;    // installing the site will be asked to fill out. To implement this task,&#10;    // your profile would define a function named myprofile_data_import_form()&#10;    // as a normal form API callback function, with associated validation and&#10;    // submit handlers. In the submit handler, in addition to saving whatever&#10;    // other data you have collected from the user, you might also call&#10;    // variable_set('myprofile_needs_batch_processing', TRUE) if the user has&#10;    // entered data which requires that batch processing will need to occur&#10;    // later on.&#10;    'myprofile_data_import_form' =&gt; array(&#10;      'display_name' =&gt; st('Data import options'),&#10;      'type' =&gt; 'form',&#10;    ),&#10;    // Similarly, to implement this task, your profile would define a function&#10;    // named myprofile_settings_form() with associated validation and submit&#10;    // handlers. This form might be used to collect and save additional&#10;    // information from the user that your profile needs. There are no extra&#10;    // steps required for your profile to act as an &quot;installation wizard&quot;; you&#10;    // can simply define as many tasks of type 'form' as you wish to execute,&#10;    // and the forms will be presented to the user, one after another.&#10;    'myprofile_settings_form' =&gt; array(&#10;      'display_name' =&gt; st('Additional options'),&#10;      'type' =&gt; 'form',&#10;    ),&#10;    // This is an example of a task that performs batch operations. To&#10;    // implement this task, your profile would define a function named&#10;    // myprofile_batch_processing() which returns a batch API array definition&#10;    // that the installer will use to execute your batch operations. Due to the&#10;    // 'myprofile_needs_batch_processing' variable used here, this task will be&#10;    // hidden and skipped unless your profile set it to TRUE in one of the&#10;    // previous tasks.&#10;    'myprofile_batch_processing' =&gt; array(&#10;      'display_name' =&gt; st('Import additional data'),&#10;      'display' =&gt; $myprofile_needs_batch_processing,&#10;      'type' =&gt; 'batch',&#10;      'run' =&gt; $myprofile_needs_batch_processing ? INSTALL_TASK_RUN_IF_NOT_COMPLETED : INSTALL_TASK_SKIP,&#10;    ),&#10;    // This is an example of a task that will not be displayed in the list that&#10;    // the user sees. To implement this task, your profile would define a&#10;    // function named myprofile_final_site_setup(), in which additional,&#10;    // automated site setup operations would be performed. Since this is the&#10;    // last task defined by your profile, you should also use this function to&#10;    // call variable_del('myprofile_needs_batch_processing') and clean up the&#10;    // variable that was used above. If you want the user to pass to the final&#10;    // Drupal installation tasks uninterrupted, return no output from this&#10;    // function. Otherwise, return themed output that the user will see (for&#10;    // example, a confirmation page explaining that your profile's tasks are&#10;    // complete, with a link to reload the current page and therefore pass on&#10;    // to the final Drupal installation tasks when the user is ready to do so).&#10;    'myprofile_final_site_setup' =&gt; array(&#10;    ),&#10;  );&#10;  return $tasks;&#10;  $END$&#10;}" description="hook_install_tasks" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_install_tasks" value="/**&#10; * Implements hook_install_tasks().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install_tasks() {&#10;  // Here, we define a variable to allow tasks to indicate that a particular,&#10;  // processor-intensive batch process needs to be triggered later on in the&#10;  // installation.&#10;  $myprofile_needs_batch_processing = variable_get('myprofile_needs_batch_processing', FALSE);&#10;  $tasks = array(&#10;    // This is an example of a task that defines a form which the user who is&#10;    // installing the site will be asked to fill out. To implement this task,&#10;    // your profile would define a function named myprofile_data_import_form()&#10;    // as a normal form API callback function, with associated validation and&#10;    // submit handlers. In the submit handler, in addition to saving whatever&#10;    // other data you have collected from the user, you might also call&#10;    // variable_set('myprofile_needs_batch_processing', TRUE) if the user has&#10;    // entered data which requires that batch processing will need to occur&#10;    // later on.&#10;    'myprofile_data_import_form' =&gt; array(&#10;      'display_name' =&gt; st('Data import options'),&#10;      'type' =&gt; 'form',&#10;    ),&#10;    // Similarly, to implement this task, your profile would define a function&#10;    // named myprofile_settings_form() with associated validation and submit&#10;    // handlers. This form might be used to collect and save additional&#10;    // information from the user that your profile needs. There are no extra&#10;    // steps required for your profile to act as an &quot;installation wizard&quot;; you&#10;    // can simply define as many tasks of type 'form' as you wish to execute,&#10;    // and the forms will be presented to the user, one after another.&#10;    'myprofile_settings_form' =&gt; array(&#10;      'display_name' =&gt; st('Additional options'),&#10;      'type' =&gt; 'form',&#10;    ),&#10;    // This is an example of a task that performs batch operations. To&#10;    // implement this task, your profile would define a function named&#10;    // myprofile_batch_processing() which returns a batch API array definition&#10;    // that the installer will use to execute your batch operations. Due to the&#10;    // 'myprofile_needs_batch_processing' variable used here, this task will be&#10;    // hidden and skipped unless your profile set it to TRUE in one of the&#10;    // previous tasks.&#10;    'myprofile_batch_processing' =&gt; array(&#10;      'display_name' =&gt; st('Import additional data'),&#10;      'display' =&gt; $myprofile_needs_batch_processing,&#10;      'type' =&gt; 'batch',&#10;      'run' =&gt; $myprofile_needs_batch_processing ? INSTALL_TASK_RUN_IF_NOT_COMPLETED : INSTALL_TASK_SKIP,&#10;    ),&#10;    // This is an example of a task that will not be displayed in the list that&#10;    // the user sees. To implement this task, your profile would define a&#10;    // function named myprofile_final_site_setup(), in which additional,&#10;    // automated site setup operations would be performed. Since this is the&#10;    // last task defined by your profile, you should also use this function to&#10;    // call variable_del('myprofile_needs_batch_processing') and clean up the&#10;    // variable that was used above. If you want the user to pass to the final&#10;    // Drupal installation tasks uninterrupted, return no output from this&#10;    // function. Otherwise, return themed output that the user will see (for&#10;    // example, a confirmation page explaining that your profile's tasks are&#10;    // complete, with a link to reload the current page and therefore pass on&#10;    // to the final Drupal installation tasks when the user is ready to do so).&#10;    'myprofile_final_site_setup' =&gt; array(&#10;    ),&#10;  );&#10;  return $tasks;&#10;  $END$&#10;}" description="hook_install_tasks" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_drupal_goto_alter" value="/**&#10; * Implements hook_drupal_goto_alter().&#10; *&#10; * Change the page the user is sent to by drupal_goto().&#10; *&#10; * @param $path&#10; *   A Drupal path or a full URL.&#10; * @param $options&#10; *   An associative array of additional URL options to pass to url().&#10; * @param $http_response_code&#10; *   The HTTP status code to use for the redirection. See drupal_goto() for more&#10; *   information.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_drupal_goto_alter(&amp;$path, &amp;$options, &amp;$http_response_code) {&#10;  // A good addition to misery module.&#10;  $http_response_code = 500;&#10;  $END$&#10;}" description="hook_drupal_goto_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_drupal_goto_alter" value="/**&#10; * Implements hook_drupal_goto_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_drupal_goto_alter(&amp;$path, &amp;$options, &amp;$http_response_code) {&#10;  // A good addition to misery module.&#10;  $http_response_code = 500;&#10;  $END$&#10;}" description="hook_drupal_goto_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_html_head_alter" value="/**&#10; * Implements hook_html_head_alter().&#10; *&#10; * Alter XHTML HEAD tags before they are rendered by drupal_get_html_head().&#10; *&#10; * Elements available to be altered are only those added using&#10; * drupal_add_html_head_link() or drupal_add_html_head(). CSS and JS files&#10; * are handled using drupal_add_css() and drupal_add_js(), so the head links&#10; * for those files will not appear in the $head_elements array.&#10; *&#10; * @param $head_elements&#10; *   An array of renderable elements. Generally the values of the #attributes&#10; *   array will be the most likely target for changes.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_html_head_alter(&amp;$head_elements) {&#10;  foreach ($head_elements as $key =&gt; $element) {&#10;    if (isset($element['#attributes']['rel']) &amp;&amp; $element['#attributes']['rel'] == 'canonical') {&#10;      // I want a custom canonical url.&#10;      $head_elements[$key]['#attributes']['href'] = mymodule_canonical_url();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_html_head_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_html_head_alter" value="/**&#10; * Implements hook_html_head_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_html_head_alter(&amp;$head_elements) {&#10;  foreach ($head_elements as $key =&gt; $element) {&#10;    if (isset($element['#attributes']['rel']) &amp;&amp; $element['#attributes']['rel'] == 'canonical') {&#10;      // I want a custom canonical url.&#10;      $head_elements[$key]['#attributes']['href'] = mymodule_canonical_url();&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_html_head_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_install_tasks_alter" value="/**&#10; * Implements hook_install_tasks_alter().&#10; *&#10; * Alter the full list of installation tasks.&#10; *&#10; * @param $tasks&#10; *   An array of all available installation tasks, including those provided by&#10; *   Drupal core. You can modify this array to change or replace any part of&#10; *   the Drupal installation process that occurs after the installation profile&#10; *   is selected.&#10; * @param $install_state&#10; *   An array of information about the current installation state.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install_tasks_alter(&amp;$tasks, $install_state) {&#10;  // Replace the &quot;Choose language&quot; installation task provided by Drupal core&#10;  // with a custom callback function defined by this installation profile.&#10;  $tasks['install_select_locale']['function'] = 'myprofile_locale_selection';&#10;  $END$&#10;}" description="hook_install_tasks_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_install_tasks_alter" value="/**&#10; * Implements hook_install_tasks_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_install_tasks_alter(&amp;$tasks, $install_state) {&#10;  // Replace the &quot;Choose language&quot; installation task provided by Drupal core&#10;  // with a custom callback function defined by this installation profile.&#10;  $tasks['install_select_locale']['function'] = 'myprofile_locale_selection';&#10;  $END$&#10;}" description="hook_install_tasks_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_mimetype_mapping_alter" value="/**&#10; * Implements hook_file_mimetype_mapping_alter().&#10; *&#10; * Alter MIME type mappings used to determine MIME type from a file extension.&#10; *&#10; * This hook is run when file_mimetype_mapping() is called. It is used to&#10; * allow modules to add to or modify the default mapping from&#10; * file_default_mimetype_mapping().&#10; *&#10; * @param $mapping&#10; *   An array of mimetypes correlated to the extensions that relate to them.&#10; *   The array has 'mimetypes' and 'extensions' elements, each of which is an&#10; *   array.&#10; *&#10; * @see file_default_mimetype_mapping()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_mimetype_mapping_alter(&amp;$mapping) {&#10;  // Add new MIME type 'drupal/info'.&#10;  $mapping['mimetypes']['example_info'] = 'drupal/info';&#10;  // Add new extension '.info' and map it to the 'drupal/info' MIME type.&#10;  $mapping['extensions']['info'] = 'example_info';&#10;  // Override existing extension mapping for '.ogg' files.&#10;  $mapping['extensions']['ogg'] = 189;&#10;  $END$&#10;}" description="hook_file_mimetype_mapping_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_mimetype_mapping_alter" value="/**&#10; * Implements hook_file_mimetype_mapping_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_mimetype_mapping_alter(&amp;$mapping) {&#10;  // Add new MIME type 'drupal/info'.&#10;  $mapping['mimetypes']['example_info'] = 'drupal/info';&#10;  // Add new extension '.info' and map it to the 'drupal/info' MIME type.&#10;  $mapping['extensions']['info'] = 'example_info';&#10;  // Override existing extension mapping for '.ogg' files.&#10;  $mapping['extensions']['ogg'] = 189;&#10;  $END$&#10;}" description="hook_file_mimetype_mapping_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_action_info" value="/**&#10; * Implements hook_action_info().&#10; *&#10; * Declares information about actions.&#10; *&#10; * Any module can define actions, and then call actions_do() to make those&#10; * actions happen in response to events. The trigger module provides a user&#10; * interface for associating actions with module-defined triggers, and it makes&#10; * sure the core triggers fire off actions when their events happen.&#10; *&#10; * An action consists of two or three parts:&#10; * - an action definition (returned by this hook)&#10; * - a function which performs the action (which by convention is named&#10; *   MODULE_description-of-function_action)&#10; * - an optional form definition function that defines a configuration form&#10; *   (which has the name of the action function with '_form' appended to it.)&#10; *&#10; * The action function takes two to four arguments, which come from the input&#10; * arguments to actions_do().&#10; *&#10; * @return&#10; *   An associative array of action descriptions. The keys of the array&#10; *   are the names of the action functions, and each corresponding value&#10; *   is an associative array with the following key-value pairs:&#10; *   - 'type': The type of object this action acts upon. Core actions have types&#10; *     'node', 'user', 'comment', and 'system'.&#10; *   - 'label': The human-readable name of the action, which should be passed&#10; *     through the t() function for translation.&#10; *   - 'configurable': If FALSE, then the action doesn't require any extra&#10; *     configuration. If TRUE, then your module must define a form function with&#10; *     the same name as the action function with '_form' appended (e.g., the&#10; *     form for 'node_assign_owner_action' is 'node_assign_owner_action_form'.)&#10; *     This function takes $context as its only parameter, and is paired with&#10; *     the usual _submit function, and possibly a _validate function.&#10; *   - 'triggers': An array of the events (that is, hooks) that can trigger this&#10; *     action. For example: array('node_insert', 'user_update'). You can also&#10; *     declare support for any trigger by returning array('any') for this value.&#10; *   - 'behavior': (optional) A machine-readable array of behaviors of this&#10; *     action, used to signal additionally required actions that may need to be&#10; *     triggered. Currently recognized behaviors by Trigger module:&#10; *     - 'changes_property': If an action with this behavior is assigned to a&#10; *       trigger other than a &quot;presave&quot; hook, any save actions also assigned to&#10; *       this trigger are moved later in the list. If no save action is present,&#10; *       one will be added.&#10; *       Modules that are processing actions (like Trigger module) should take&#10; *       special care for the &quot;presave&quot; hook, in which case a dependent &quot;save&quot;&#10; *       action should NOT be invoked.&#10; *&#10; * @ingroup actions&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_action_info() {&#10;  return array(&#10;    'comment_unpublish_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Unpublish comment'),&#10;      'configurable' =&gt; FALSE,&#10;      'behavior' =&gt; array('changes_property'),&#10;      'triggers' =&gt; array('comment_presave', 'comment_insert', 'comment_update'),&#10;    ),&#10;    'comment_unpublish_by_keyword_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Unpublish comment containing keyword(s)'),&#10;      'configurable' =&gt; TRUE,&#10;      'behavior' =&gt; array('changes_property'),&#10;      'triggers' =&gt; array('comment_presave', 'comment_insert', 'comment_update'),&#10;    ),&#10;    'comment_save_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Save comment'),&#10;      'configurable' =&gt; FALSE,&#10;      'triggers' =&gt; array('comment_insert', 'comment_update'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_action_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_action_info" value="/**&#10; * Implements hook_action_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_action_info() {&#10;  return array(&#10;    'comment_unpublish_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Unpublish comment'),&#10;      'configurable' =&gt; FALSE,&#10;      'behavior' =&gt; array('changes_property'),&#10;      'triggers' =&gt; array('comment_presave', 'comment_insert', 'comment_update'),&#10;    ),&#10;    'comment_unpublish_by_keyword_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Unpublish comment containing keyword(s)'),&#10;      'configurable' =&gt; TRUE,&#10;      'behavior' =&gt; array('changes_property'),&#10;      'triggers' =&gt; array('comment_presave', 'comment_insert', 'comment_update'),&#10;    ),&#10;    'comment_save_action' =&gt; array(&#10;      'type' =&gt; 'comment',&#10;      'label' =&gt; t('Save comment'),&#10;      'configurable' =&gt; FALSE,&#10;      'triggers' =&gt; array('comment_insert', 'comment_update'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_action_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_actions_delete" value="/**&#10; * Implements hook_actions_delete().&#10; *&#10; * Executes code after an action is deleted.&#10; *&#10; * @param $aid&#10; *   The action ID.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_actions_delete($aid) {&#10;  db_delete('actions_assignments')&#10;    -&gt;condition('aid', $aid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_actions_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_actions_delete" value="/**&#10; * Implements hook_actions_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_actions_delete($aid) {&#10;  db_delete('actions_assignments')&#10;    -&gt;condition('aid', $aid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_actions_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_action_info_alter" value="/**&#10; * Implements hook_action_info_alter().&#10; *&#10; * Alters the actions declared by another module.&#10; *&#10; * Called by actions_list() to allow modules to alter the return values from&#10; * implementations of hook_action_info().&#10; *&#10; * @see trigger_example_action_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_action_info_alter(&amp;$actions) {&#10;  $actions['node_unpublish_action']['label'] = t('Unpublish and remove from public view.');&#10;  $END$&#10;}" description="hook_action_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_action_info_alter" value="/**&#10; * Implements hook_action_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_action_info_alter(&amp;$actions) {&#10;  $actions['node_unpublish_action']['label'] = t('Unpublish and remove from public view.');&#10;  $END$&#10;}" description="hook_action_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_archiver_info" value="/**&#10; * Implements hook_archiver_info().&#10; *&#10; * Declare archivers to the system.&#10; *&#10; * An archiver is a class that is able to package and unpackage one or more files&#10; * into a single possibly compressed file.  Common examples of such files are&#10; * zip files and tar.gz files.  All archiver classes must implement&#10; * ArchiverInterface.&#10; *&#10; * Each entry should be keyed on a unique value, and specify three&#10; * additional keys:&#10; * - class: The name of the PHP class for this archiver.&#10; * - extensions: An array of file extensions that this archiver supports.&#10; * - weight: This optional key specifies the weight of this archiver.&#10; *   When mapping file extensions to archivers, the first archiver by&#10; *   weight found that supports the requested extension will be used.&#10; *&#10; * @see hook_archiver_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_archiver_info() {&#10;  return array(&#10;    'tar' =&gt; array(&#10;      'class' =&gt; 'ArchiverTar',&#10;      'extensions' =&gt; array('tar', 'tar.gz', 'tar.bz2'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_archiver_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_archiver_info" value="/**&#10; * Implements hook_archiver_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_archiver_info() {&#10;  return array(&#10;    'tar' =&gt; array(&#10;      'class' =&gt; 'ArchiverTar',&#10;      'extensions' =&gt; array('tar', 'tar.gz', 'tar.bz2'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_archiver_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_archiver_info_alter" value="/**&#10; * Implements hook_archiver_info_alter().&#10; *&#10; * Alter archiver information declared by other modules.&#10; *&#10; * See hook_archiver_info() for a description of archivers and the archiver&#10; * information structure.&#10; *&#10; * @param $info&#10; *   Archiver information to alter (return values from hook_archiver_info()).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_archiver_info_alter(&amp;$info) {&#10;  $info['tar']['extensions'][] = 'tgz';&#10;  $END$&#10;}" description="hook_archiver_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_archiver_info_alter" value="/**&#10; * Implements hook_archiver_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_archiver_info_alter(&amp;$info) {&#10;  $info['tar']['extensions'][] = 'tgz';&#10;  $END$&#10;}" description="hook_archiver_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_date_format_types" value="/**&#10; * Implements hook_date_format_types().&#10; *&#10; * Define additional date types.&#10; *&#10; * Next to the 'long', 'medium' and 'short' date types defined in core, any&#10; * module can define additional types that can be used when displaying dates,&#10; * by implementing this hook. A date type is basically just a name for a date&#10; * format.&#10; *&#10; * Date types are used in the administration interface: a user can assign&#10; * date format types defined in hook_date_formats() to date types defined in&#10; * this hook. Once a format has been assigned by a user, the machine name of a&#10; * type can be used in the format_date() function to format a date using the&#10; * chosen formatting.&#10; *&#10; * To define a date type in a module and make sure a format has been assigned to&#10; * it, without requiring a user to visit the administrative interface, use&#10; * @code variable_set('date_format_' . $type, $format); @endcode&#10; * where $type is the machine-readable name defined here, and $format is a PHP&#10; * date format string.&#10; *&#10; * To avoid namespace collisions with date types defined by other modules, it is&#10; * recommended that each date type starts with the module name. A date type&#10; * can consist of letters, numbers and underscores.&#10; *&#10; * @return&#10; *   An array of date types where the keys are the machine-readable names and&#10; *   the values are the human-readable labels.&#10; *&#10; * @see hook_date_formats()&#10; * @see format_date()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_format_types() {&#10;  // Define the core date format types.&#10;  return array(&#10;    'long' =&gt; t('Long'),&#10;    'medium' =&gt; t('Medium'),&#10;    'short' =&gt; t('Short'),&#10;  );&#10;  $END$&#10;}" description="hook_date_format_types" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_date_format_types" value="/**&#10; * Implements hook_date_format_types().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_format_types() {&#10;  // Define the core date format types.&#10;  return array(&#10;    'long' =&gt; t('Long'),&#10;    'medium' =&gt; t('Medium'),&#10;    'short' =&gt; t('Short'),&#10;  );&#10;  $END$&#10;}" description="hook_date_format_types" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_date_format_types_alter" value="/**&#10; * Implements hook_date_format_types_alter().&#10; *&#10; * Modify existing date types.&#10; *&#10; * Allows other modules to modify existing date types like 'long'. Called by&#10; * _system_date_format_types_build(). For instance, A module may use this hook&#10; * to apply settings across all date types, such as locking all date types so&#10; * they appear to be provided by the system.&#10; *&#10; * @param $types&#10; *   A list of date types. Each date type is keyed by the machine-readable name&#10; *   and the values are associative arrays containing:&#10; *   - is_new: Set to FALSE to override previous settings.&#10; *   - module: The name of the module that created the date type.&#10; *   - type: The machine-readable date type name.&#10; *   - title: The human-readable date type name.&#10; *   - locked: Specifies that the date type is system-provided.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_format_types_alter(&amp;$types) {&#10;  foreach ($types as $name =&gt; $type) {&#10;    $types[$name]['locked'] = 1;&#10;  }&#10;  $END$&#10;}" description="hook_date_format_types_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_date_format_types_alter" value="/**&#10; * Implements hook_date_format_types_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_format_types_alter(&amp;$types) {&#10;  foreach ($types as $name =&gt; $type) {&#10;    $types[$name]['locked'] = 1;&#10;  }&#10;  $END$&#10;}" description="hook_date_format_types_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_date_formats" value="/**&#10; * Implements hook_date_formats().&#10; *&#10; * Define additional date formats.&#10; *&#10; * This hook is used to define the PHP date format strings that can be assigned&#10; * to date types in the administrative interface. A module can provide date&#10; * format strings for the core-provided date types ('long', 'medium', and&#10; * 'short'), or for date types defined in hook_date_format_types() by itself&#10; * or another module.&#10; *&#10; * Since date formats can be locale-specific, you can specify the locales that&#10; * each date format string applies to. There may be more than one locale for a&#10; * format. There may also be more than one format for the same locale. For&#10; * example d/m/Y and Y/m/d work equally well in some locales. You may wish to&#10; * define some additional date formats that aren't specific to any one locale,&#10; * for example, &quot;Y m&quot;. For these cases, the 'locales' component of the return&#10; * value should be omitted.&#10; *&#10; * Providing a date format here does not normally assign the format to be&#10; * used with the associated date type -- a user has to choose a format for each&#10; * date type in the administrative interface. There is one exception: locale&#10; * initialization chooses a locale-specific format for the three core-provided&#10; * types (see locale_get_localized_date_format() for details). If your module&#10; * needs to ensure that a date type it defines has a format associated with it,&#10; * call @code variable_set('date_format_' . $type, $format); @endcode&#10; * where $type is the machine-readable name defined in hook_date_format_types(),&#10; * and $format is a PHP date format string.&#10; *&#10; * @return&#10; *   A list of date formats to offer as choices in the administrative&#10; *   interface. Each date format is a keyed array consisting of three elements:&#10; *   - 'type': The date type name that this format can be used with, as&#10; *     declared in an implementation of hook_date_format_types().&#10; *   - 'format': A PHP date format string to use when formatting dates. It&#10; *     can contain any of the formatting options described at&#10; *     http://php.net/manual/en/function.date.php&#10; *   - 'locales': (optional) An array of 2 and 5 character locale codes,&#10; *     defining which locales this format applies to (for example, 'en',&#10; *     'en-us', etc.). If your date format is not language-specific, leave this&#10; *     array empty.&#10; *&#10; * @see hook_date_format_types()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_formats() {&#10;  return array(&#10;    array(&#10;      'type' =&gt; 'mymodule_extra_long',&#10;      'format' =&gt; 'l jS F Y H:i:s e',&#10;      'locales' =&gt; array('en-ie'),&#10;    ),&#10;    array(&#10;      'type' =&gt; 'mymodule_extra_long',&#10;      'format' =&gt; 'l jS F Y h:i:sa',&#10;      'locales' =&gt; array('en', 'en-us'),&#10;    ),&#10;    array(&#10;      'type' =&gt; 'short',&#10;      'format' =&gt; 'F Y',&#10;      'locales' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_date_formats" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_date_formats" value="/**&#10; * Implements hook_date_formats().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_formats() {&#10;  return array(&#10;    array(&#10;      'type' =&gt; 'mymodule_extra_long',&#10;      'format' =&gt; 'l jS F Y H:i:s e',&#10;      'locales' =&gt; array('en-ie'),&#10;    ),&#10;    array(&#10;      'type' =&gt; 'mymodule_extra_long',&#10;      'format' =&gt; 'l jS F Y h:i:sa',&#10;      'locales' =&gt; array('en', 'en-us'),&#10;    ),&#10;    array(&#10;      'type' =&gt; 'short',&#10;      'format' =&gt; 'F Y',&#10;      'locales' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_date_formats" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_date_formats_alter" value="/**&#10; * Implements hook_date_formats_alter().&#10; *&#10; * Alter date formats declared by another module.&#10; *&#10; * Called by _system_date_format_types_build() to allow modules to alter the&#10; * return values from implementations of hook_date_formats().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_formats_alter(&amp;$formats) {&#10;  foreach ($formats as $id =&gt; $format) {&#10;    $formats[$id]['locales'][] = 'en-ca';&#10;  }&#10;  $END$&#10;}" description="hook_date_formats_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_date_formats_alter" value="/**&#10; * Implements hook_date_formats_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_date_formats_alter(&amp;$formats) {&#10;  foreach ($formats as $id =&gt; $format) {&#10;    $formats[$id]['locales'][] = 'en-ca';&#10;  }&#10;  $END$&#10;}" description="hook_date_formats_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_page_delivery_callback_alter" value="/**&#10; * Implements hook_page_delivery_callback_alter().&#10; *&#10; * Alters the delivery callback used to send the result of the page callback to the browser.&#10; *&#10; * Called by drupal_deliver_page() to allow modules to alter how the&#10; * page is delivered to the browser.&#10; *&#10; * This hook is intended for altering the delivery callback based on&#10; * information unrelated to the path of the page accessed. For example,&#10; * it can be used to set the delivery callback based on a HTTP request&#10; * header (as shown in the code sample). To specify a delivery callback&#10; * based on path information, use hook_menu() or hook_menu_alter().&#10; *&#10; * This hook can also be used as an API function that can be used to explicitly&#10; * set the delivery callback from some other function. For example, for a module&#10; * named MODULE:&#10; * @code&#10; * function MODULE_page_delivery_callback_alter(&amp;$callback, $set = FALSE) {&#10; *   static $stored_callback;&#10; *   if ($set) {&#10; *     $stored_callback = $callback;&#10; *   }&#10; *   elseif (isset($stored_callback)) {&#10; *     $callback = $stored_callback;&#10; *   }&#10; * }&#10; * function SOMEWHERE_ELSE() {&#10; *   $desired_delivery_callback = 'foo';&#10; *   MODULE_page_delivery_callback_alter($desired_delivery_callback, TRUE);&#10; * }&#10; * @endcode&#10; *&#10; * @param $callback&#10; *   The name of a function.&#10; *&#10; * @see drupal_deliver_page()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_delivery_callback_alter(&amp;$callback) {&#10;  // jQuery sets a HTTP_X_REQUESTED_WITH header of 'XMLHttpRequest'.&#10;  // If a page would normally be delivered as an html page, and it is called&#10;  // from jQuery, deliver it instead as an Ajax response.&#10;  if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest' &amp;&amp; $callback == 'drupal_deliver_html_page') {&#10;    $callback = 'ajax_deliver';&#10;  }&#10;  $END$&#10;}" description="hook_page_delivery_callback_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_page_delivery_callback_alter" value="/**&#10; * Implements hook_page_delivery_callback_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_page_delivery_callback_alter(&amp;$callback) {&#10;  // jQuery sets a HTTP_X_REQUESTED_WITH header of 'XMLHttpRequest'.&#10;  // If a page would normally be delivered as an html page, and it is called&#10;  // from jQuery, deliver it instead as an Ajax response.&#10;  if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest' &amp;&amp; $callback == 'drupal_deliver_html_page') {&#10;    $callback = 'ajax_deliver';&#10;  }&#10;  $END$&#10;}" description="hook_page_delivery_callback_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_system_themes_page_alter" value="/**&#10; * Implements hook_system_themes_page_alter().&#10; *&#10; * Alters theme operation links.&#10; *&#10; * @param $theme_groups&#10; *   An associative array containing groups of themes.&#10; *&#10; * @see system_themes_page()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_system_themes_page_alter(&amp;$theme_groups) {&#10;  foreach ($theme_groups as $state =&gt; &amp;$group) {&#10;    foreach ($theme_groups[$state] as &amp;$theme) {&#10;      // Add a foo link to each list of theme operations.&#10;      $theme-&gt;operations[] = array(&#10;        'title' =&gt; t('Foo'),&#10;        'href' =&gt; 'admin/appearance/foo',&#10;        'query' =&gt; array('theme' =&gt; $theme-&gt;name)&#10;      );&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_system_themes_page_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_system_themes_page_alter" value="/**&#10; * Implements hook_system_themes_page_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_system_themes_page_alter(&amp;$theme_groups) {&#10;  foreach ($theme_groups as $state =&gt; &amp;$group) {&#10;    foreach ($theme_groups[$state] as &amp;$theme) {&#10;      // Add a foo link to each list of theme operations.&#10;      $theme-&gt;operations[] = array(&#10;        'title' =&gt; t('Foo'),&#10;        'href' =&gt; 'admin/appearance/foo',&#10;        'query' =&gt; array('theme' =&gt; $theme-&gt;name)&#10;      );&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_system_themes_page_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_url_inbound_alter" value="/**&#10; * Implements hook_url_inbound_alter().&#10; *&#10; * Alters inbound URL requests.&#10; *&#10; * @param $path&#10; *   The path being constructed, which, if a path alias, has been resolved to a&#10; *   Drupal path by the database, and which also may have been altered by other&#10; *   modules before this one.&#10; * @param $original_path&#10; *   The original path, before being checked for path aliases or altered by any&#10; *   modules.&#10; * @param $path_language&#10; *   The language of the path.&#10; *&#10; * @see drupal_get_normal_path()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_url_inbound_alter(&amp;$path, $original_path, $path_language) {&#10;  // Create the path user/me/edit, which allows a user to edit their account.&#10;  if (preg_match('|^user/me/edit(/.*)?|', $path, $matches)) {&#10;    global $user;&#10;    $path = 'user/' . $user-&gt;uid . '/edit' . $matches[1];&#10;  }&#10;  $END$&#10;}" description="hook_url_inbound_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_url_inbound_alter" value="/**&#10; * Implements hook_url_inbound_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_url_inbound_alter(&amp;$path, $original_path, $path_language) {&#10;  // Create the path user/me/edit, which allows a user to edit their account.&#10;  if (preg_match('|^user/me/edit(/.*)?|', $path, $matches)) {&#10;    global $user;&#10;    $path = 'user/' . $user-&gt;uid . '/edit' . $matches[1];&#10;  }&#10;  $END$&#10;}" description="hook_url_inbound_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_url_outbound_alter" value="/**&#10; * Implements hook_url_outbound_alter().&#10; *&#10; * Alters outbound URLs.&#10; *&#10; * @param $path&#10; *   The outbound path to alter, not adjusted for path aliases yet. It won't be&#10; *   adjusted for path aliases until all modules are finished altering it, thus&#10; *   being consistent with hook_url_alter_inbound(), which adjusts for all path&#10; *   aliases before allowing modules to alter it. This may have been altered by&#10; *   other modules before this one.&#10; * @param $options&#10; *   A set of URL options for the URL so elements such as a fragment or a query&#10; *   string can be added to the URL.&#10; * @param $original_path&#10; *   The original path, before being altered by any modules.&#10; *&#10; * @see url()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_url_outbound_alter(&amp;$path, &amp;$options, $original_path) {&#10;  // Use an external RSS feed rather than the Drupal one.&#10;  if ($path == 'rss.xml') {&#10;    $path = 'http://example.com/rss.xml';&#10;    $options['external'] = TRUE;&#10;  }&#10;&#10;  // Instead of pointing to user/[uid]/edit, point to user/me/edit.&#10;  if (preg_match('|^user/([0-9]*)/edit(/.*)?|', $path, $matches)) {&#10;    global $user;&#10;    if ($user-&gt;uid == $matches[1]) {&#10;      $path = 'user/me/edit' . $matches[2];&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_url_outbound_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_url_outbound_alter" value="/**&#10; * Implements hook_url_outbound_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_url_outbound_alter(&amp;$path, &amp;$options, $original_path) {&#10;  // Use an external RSS feed rather than the Drupal one.&#10;  if ($path == 'rss.xml') {&#10;    $path = 'http://example.com/rss.xml';&#10;    $options['external'] = TRUE;&#10;  }&#10;&#10;  // Instead of pointing to user/[uid]/edit, point to user/me/edit.&#10;  if (preg_match('|^user/([0-9]*)/edit(/.*)?|', $path, $matches)) {&#10;    global $user;&#10;    if ($user-&gt;uid == $matches[1]) {&#10;      $path = 'user/me/edit' . $matches[2];&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_url_outbound_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_username_alter" value="/**&#10; * Implements hook_username_alter().&#10; *&#10; * Alter the username that is displayed for a user.&#10; *&#10; * Called by format_username() to allow modules to alter the username that's&#10; * displayed. Can be used to ensure user privacy in situations where&#10; * $account-&gt;name is too revealing.&#10; *&#10; * @param $name&#10; *   The string that format_username() will return.&#10; *&#10; * @param $account&#10; *   The account object passed to format_username().&#10; *&#10; * @see format_username()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_username_alter(&amp;$name, $account) {&#10;  // Display the user's uid instead of name.&#10;  if (isset($account-&gt;uid)) {&#10;    $name = t('User !uid', array('!uid' =&gt; $account-&gt;uid));&#10;  }&#10;  $END$&#10;}" description="hook_username_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_username_alter" value="/**&#10; * Implements hook_username_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_username_alter(&amp;$name, $account) {&#10;  // Display the user's uid instead of name.&#10;  if (isset($account-&gt;uid)) {&#10;    $name = t('User !uid', array('!uid' =&gt; $account-&gt;uid));&#10;  }&#10;  $END$&#10;}" description="hook_username_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_tokens" value="/**&#10; * Implements hook_tokens().&#10; *&#10; * Provide replacement values for placeholder tokens.&#10; *&#10; * This hook is invoked when someone calls token_replace(). That function first&#10; * scans the text for [type:token] patterns, and splits the needed tokens into&#10; * groups by type. Then hook_tokens() is invoked on each token-type group,&#10; * allowing your module to respond by providing replacement text for any of&#10; * the tokens in the group that your module knows how to process.&#10; *&#10; * A module implementing this hook should also implement hook_token_info() in&#10; * order to list its available tokens on editing screens.&#10; *&#10; * @param $type&#10; *   The machine-readable name of the type (group) of token being replaced, such&#10; *   as 'node', 'user', or another type defined by a hook_token_info()&#10; *   implementation.&#10; * @param $tokens&#10; *   An array of tokens to be replaced. The keys are the machine-readable token&#10; *   names, and the values are the raw [type:token] strings that appeared in the&#10; *   original text.&#10; * @param $data&#10; *   (optional) An associative array of data objects to be used when generating&#10; *   replacement values, as supplied in the $data parameter to token_replace().&#10; * @param $options&#10; *   (optional) An associative array of options for token replacement; see&#10; *   token_replace() for possible values.&#10; *&#10; * @return&#10; *   An associative array of replacement values, keyed by the raw [type:token]&#10; *   strings from the original text.&#10; *&#10; * @see hook_token_info()&#10; * @see hook_tokens_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_tokens($type, $tokens, array $data = array(), array $options = array()) {&#10;  $url_options = array('absolute' =&gt; TRUE);&#10;  if (isset($options['language'])) {&#10;    $url_options['language'] = $options['language'];&#10;    $language_code = $options['language']-&gt;language;&#10;  }&#10;  else {&#10;    $language_code = NULL;&#10;  }&#10;  $sanitize = !empty($options['sanitize']);&#10;&#10;  $replacements = array();&#10;&#10;  if ($type == 'node' &amp;&amp; !empty($data['node'])) {&#10;    $node = $data['node'];&#10;&#10;    foreach ($tokens as $name =&gt; $original) {&#10;      switch ($name) {&#10;        // Simple key values on the node.&#10;        case 'nid':&#10;          $replacements[$original] = $node-&gt;nid;&#10;          break;&#10;&#10;        case 'title':&#10;          $replacements[$original] = $sanitize ? check_plain($node-&gt;title) : $node-&gt;title;&#10;          break;&#10;&#10;        case 'edit-url':&#10;          $replacements[$original] = url('node/' . $node-&gt;nid . '/edit', $url_options);&#10;          break;&#10;&#10;        // Default values for the chained tokens handled below.&#10;        case 'author':&#10;          $name = ($node-&gt;uid == 0) ? variable_get('anonymous', t('Anonymous')) : $node-&gt;name;&#10;          $replacements[$original] = $sanitize ? filter_xss($name) : $name;&#10;          break;&#10;&#10;        case 'created':&#10;          $replacements[$original] = format_date($node-&gt;created, 'medium', '', NULL, $language_code);&#10;          break;&#10;      }&#10;    }&#10;&#10;    if ($author_tokens = token_find_with_prefix($tokens, 'author')) {&#10;      $author = user_load($node-&gt;uid);&#10;      $replacements += token_generate('user', $author_tokens, array('user' =&gt; $author), $options);&#10;    }&#10;&#10;    if ($created_tokens = token_find_with_prefix($tokens, 'created')) {&#10;      $replacements += token_generate('date', $created_tokens, array('date' =&gt; $node-&gt;created), $options);&#10;    }&#10;  }&#10;&#10;  return $replacements;&#10;  $END$&#10;}" description="hook_tokens" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_tokens" value="/**&#10; * Implements hook_tokens().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_tokens($type, $tokens, array $data = array(), array $options = array()) {&#10;  $url_options = array('absolute' =&gt; TRUE);&#10;  if (isset($options['language'])) {&#10;    $url_options['language'] = $options['language'];&#10;    $language_code = $options['language']-&gt;language;&#10;  }&#10;  else {&#10;    $language_code = NULL;&#10;  }&#10;  $sanitize = !empty($options['sanitize']);&#10;&#10;  $replacements = array();&#10;&#10;  if ($type == 'node' &amp;&amp; !empty($data['node'])) {&#10;    $node = $data['node'];&#10;&#10;    foreach ($tokens as $name =&gt; $original) {&#10;      switch ($name) {&#10;        // Simple key values on the node.&#10;        case 'nid':&#10;          $replacements[$original] = $node-&gt;nid;&#10;          break;&#10;&#10;        case 'title':&#10;          $replacements[$original] = $sanitize ? check_plain($node-&gt;title) : $node-&gt;title;&#10;          break;&#10;&#10;        case 'edit-url':&#10;          $replacements[$original] = url('node/' . $node-&gt;nid . '/edit', $url_options);&#10;          break;&#10;&#10;        // Default values for the chained tokens handled below.&#10;        case 'author':&#10;          $name = ($node-&gt;uid == 0) ? variable_get('anonymous', t('Anonymous')) : $node-&gt;name;&#10;          $replacements[$original] = $sanitize ? filter_xss($name) : $name;&#10;          break;&#10;&#10;        case 'created':&#10;          $replacements[$original] = format_date($node-&gt;created, 'medium', '', NULL, $language_code);&#10;          break;&#10;      }&#10;    }&#10;&#10;    if ($author_tokens = token_find_with_prefix($tokens, 'author')) {&#10;      $author = user_load($node-&gt;uid);&#10;      $replacements += token_generate('user', $author_tokens, array('user' =&gt; $author), $options);&#10;    }&#10;&#10;    if ($created_tokens = token_find_with_prefix($tokens, 'created')) {&#10;      $replacements += token_generate('date', $created_tokens, array('date' =&gt; $node-&gt;created), $options);&#10;    }&#10;  }&#10;&#10;  return $replacements;&#10;  $END$&#10;}" description="hook_tokens" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_tokens_alter" value="/**&#10; * Implements hook_tokens_alter().&#10; *&#10; * Alter replacement values for placeholder tokens.&#10; *&#10; * @param $replacements&#10; *   An associative array of replacements returned by hook_tokens().&#10; * @param $context&#10; *   The context in which hook_tokens() was called. An associative array with&#10; *   the following keys, which have the same meaning as the corresponding&#10; *   parameters of hook_tokens():&#10; *   - 'type'&#10; *   - 'tokens'&#10; *   - 'data'&#10; *   - 'options'&#10; *&#10; * @see hook_tokens()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_tokens_alter(array &amp;$replacements, array $context) {&#10;  $options = $context['options'];&#10;&#10;  if (isset($options['language'])) {&#10;    $url_options['language'] = $options['language'];&#10;    $language_code = $options['language']-&gt;language;&#10;  }&#10;  else {&#10;    $language_code = NULL;&#10;  }&#10;  $sanitize = !empty($options['sanitize']);&#10;&#10;  if ($context['type'] == 'node' &amp;&amp; !empty($context['data']['node'])) {&#10;    $node = $context['data']['node'];&#10;&#10;    // Alter the [node:title] token, and replace it with the rendered content&#10;    // of a field (field_title).&#10;    if (isset($context['tokens']['title'])) {&#10;      $title = field_view_field('node', $node, 'field_title', 'default', $language_code);&#10;      $replacements[$context['tokens']['title']] = drupal_render($title);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_tokens_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_tokens_alter" value="/**&#10; * Implements hook_tokens_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_tokens_alter(array &amp;$replacements, array $context) {&#10;  $options = $context['options'];&#10;&#10;  if (isset($options['language'])) {&#10;    $url_options['language'] = $options['language'];&#10;    $language_code = $options['language']-&gt;language;&#10;  }&#10;  else {&#10;    $language_code = NULL;&#10;  }&#10;  $sanitize = !empty($options['sanitize']);&#10;&#10;  if ($context['type'] == 'node' &amp;&amp; !empty($context['data']['node'])) {&#10;    $node = $context['data']['node'];&#10;&#10;    // Alter the [node:title] token, and replace it with the rendered content&#10;    // of a field (field_title).&#10;    if (isset($context['tokens']['title'])) {&#10;      $title = field_view_field('node', $node, 'field_title', 'default', $language_code);&#10;      $replacements[$context['tokens']['title']] = drupal_render($title);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_tokens_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_token_info" value="/**&#10; * Implements hook_token_info().&#10; *&#10; * Provide information about available placeholder tokens and token types.&#10; *&#10; * Tokens are placeholders that can be put into text by using the syntax&#10; * [type:token], where type is the machine-readable name of a token type, and&#10; * token is the machine-readable name of a token within this group. This hook&#10; * provides a list of types and tokens to be displayed on text editing screens,&#10; * so that people editing text can see what their token options are.&#10; *&#10; * The actual token replacement is done by token_replace(), which invokes&#10; * hook_tokens(). Your module will need to implement that hook in order to&#10; * generate token replacements from the tokens defined here.&#10; *&#10; * @return&#10; *   An associative array of available tokens and token types. The outer array&#10; *   has two components:&#10; *   - types: An associative array of token types (groups). Each token type is&#10; *     an associative array with the following components:&#10; *     - name: The translated human-readable short name of the token type.&#10; *     - description: A translated longer description of the token type.&#10; *     - needs-data: The type of data that must be provided to token_replace()&#10; *       in the $data argument (i.e., the key name in $data) in order for tokens&#10; *       of this type to be used in the $text being processed. For instance, if&#10; *       the token needs a node object, 'needs-data' should be 'node', and to&#10; *       use this token in token_replace(), the caller needs to supply a node&#10; *       object as $data['node']. Some token data can also be supplied&#10; *       indirectly; for instance, a node object in $data supplies a user object&#10; *       (the author of the node), allowing user tokens to be used when only&#10; *       a node data object is supplied.&#10; *   - tokens: An associative array of tokens. The outer array is keyed by the&#10; *     group name (the same key as in the types array). Within each group of&#10; *     tokens, each token item is keyed by the machine name of the token, and&#10; *     each token item has the following components:&#10; *     - name: The translated human-readable short name of the token.&#10; *     - description: A translated longer description of the token.&#10; *     - type (optional): A 'needs-data' data type supplied by this token, which&#10; *       should match a 'needs-data' value from another token type. For example,&#10; *       the node author token provides a user object, which can then be used&#10; *       for token replacement data in token_replace() without having to supply&#10; *       a separate user object.&#10; *&#10; * @see hook_token_info_alter()&#10; * @see hook_tokens()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_token_info() {&#10;  $type = array(&#10;    'name' =&gt; t('Nodes'),&#10;    'description' =&gt; t('Tokens related to individual nodes.'),&#10;    'needs-data' =&gt; 'node',&#10;  );&#10;&#10;  // Core tokens for nodes.&#10;  $node['nid'] = array(&#10;    'name' =&gt; t(&quot;Node ID&quot;),&#10;    'description' =&gt; t(&quot;The unique ID of the node.&quot;),&#10;  );&#10;  $node['title'] = array(&#10;    'name' =&gt; t(&quot;Title&quot;),&#10;    'description' =&gt; t(&quot;The title of the node.&quot;),&#10;  );&#10;  $node['edit-url'] = array(&#10;    'name' =&gt; t(&quot;Edit URL&quot;),&#10;    'description' =&gt; t(&quot;The URL of the node's edit page.&quot;),&#10;  );&#10;&#10;  // Chained tokens for nodes.&#10;  $node['created'] = array(&#10;    'name' =&gt; t(&quot;Date created&quot;),&#10;    'description' =&gt; t(&quot;The date the node was posted.&quot;),&#10;    'type' =&gt; 'date',&#10;  );&#10;  $node['author'] = array(&#10;    'name' =&gt; t(&quot;Author&quot;),&#10;    'description' =&gt; t(&quot;The author of the node.&quot;),&#10;    'type' =&gt; 'user',&#10;  );&#10;&#10;  return array(&#10;    'types' =&gt; array('node' =&gt; $type),&#10;    'tokens' =&gt; array('node' =&gt; $node),&#10;  );&#10;  $END$&#10;}" description="hook_token_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_token_info" value="/**&#10; * Implements hook_token_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_token_info() {&#10;  $type = array(&#10;    'name' =&gt; t('Nodes'),&#10;    'description' =&gt; t('Tokens related to individual nodes.'),&#10;    'needs-data' =&gt; 'node',&#10;  );&#10;&#10;  // Core tokens for nodes.&#10;  $node['nid'] = array(&#10;    'name' =&gt; t(&quot;Node ID&quot;),&#10;    'description' =&gt; t(&quot;The unique ID of the node.&quot;),&#10;  );&#10;  $node['title'] = array(&#10;    'name' =&gt; t(&quot;Title&quot;),&#10;    'description' =&gt; t(&quot;The title of the node.&quot;),&#10;  );&#10;  $node['edit-url'] = array(&#10;    'name' =&gt; t(&quot;Edit URL&quot;),&#10;    'description' =&gt; t(&quot;The URL of the node's edit page.&quot;),&#10;  );&#10;&#10;  // Chained tokens for nodes.&#10;  $node['created'] = array(&#10;    'name' =&gt; t(&quot;Date created&quot;),&#10;    'description' =&gt; t(&quot;The date the node was posted.&quot;),&#10;    'type' =&gt; 'date',&#10;  );&#10;  $node['author'] = array(&#10;    'name' =&gt; t(&quot;Author&quot;),&#10;    'description' =&gt; t(&quot;The author of the node.&quot;),&#10;    'type' =&gt; 'user',&#10;  );&#10;&#10;  return array(&#10;    'types' =&gt; array('node' =&gt; $type),&#10;    'tokens' =&gt; array('node' =&gt; $node),&#10;  );&#10;  $END$&#10;}" description="hook_token_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_token_info_alter" value="/**&#10; * Implements hook_token_info_alter().&#10; *&#10; * Alter the metadata about available placeholder tokens and token types.&#10; *&#10; * @param $data&#10; *   The associative array of token definitions from hook_token_info().&#10; *&#10; * @see hook_token_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_token_info_alter(&amp;$data) {&#10;  // Modify description of node tokens for our site.&#10;  $data['tokens']['node']['nid'] = array(&#10;    'name' =&gt; t(&quot;Node ID&quot;),&#10;    'description' =&gt; t(&quot;The unique ID of the article.&quot;),&#10;  );&#10;  $data['tokens']['node']['title'] = array(&#10;    'name' =&gt; t(&quot;Title&quot;),&#10;    'description' =&gt; t(&quot;The title of the article.&quot;),&#10;  );&#10;&#10;  // Chained tokens for nodes.&#10;  $data['tokens']['node']['created'] = array(&#10;    'name' =&gt; t(&quot;Date created&quot;),&#10;    'description' =&gt; t(&quot;The date the article was posted.&quot;),&#10;    'type' =&gt; 'date',&#10;  );&#10;  $END$&#10;}" description="hook_token_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_token_info_alter" value="/**&#10; * Implements hook_token_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_token_info_alter(&amp;$data) {&#10;  // Modify description of node tokens for our site.&#10;  $data['tokens']['node']['nid'] = array(&#10;    'name' =&gt; t(&quot;Node ID&quot;),&#10;    'description' =&gt; t(&quot;The unique ID of the article.&quot;),&#10;  );&#10;  $data['tokens']['node']['title'] = array(&#10;    'name' =&gt; t(&quot;Title&quot;),&#10;    'description' =&gt; t(&quot;The title of the article.&quot;),&#10;  );&#10;&#10;  // Chained tokens for nodes.&#10;  $data['tokens']['node']['created'] = array(&#10;    'name' =&gt; t(&quot;Date created&quot;),&#10;    'description' =&gt; t(&quot;The date the article was posted.&quot;),&#10;    'type' =&gt; 'date',&#10;  );&#10;  $END$&#10;}" description="hook_token_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_batch_alter" value="/**&#10; * Implements hook_batch_alter().&#10; *&#10; * Alter batch information before a batch is processed.&#10; *&#10; * Called by batch_process() to allow modules to alter a batch before it is&#10; * processed.&#10; *&#10; * @param $batch&#10; *   The associative array of batch information. See batch_set() for details on&#10; *   what this could contain.&#10; *&#10; * @see batch_set()&#10; * @see batch_process()&#10; *&#10; * @ingroup batch&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_batch_alter(&amp;$batch) {&#10;  // If the current page request is inside the overlay, add ?render=overlay to&#10;  // the success callback URL, so that it appears correctly within the overlay.&#10;  if (overlay_get_mode() == 'child') {&#10;    if (isset($batch['url_options']['query'])) {&#10;      $batch['url_options']['query']['render'] = 'overlay';&#10;    }&#10;    else {&#10;      $batch['url_options']['query'] = array('render' =&gt; 'overlay');&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_batch_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_batch_alter" value="/**&#10; * Implements hook_batch_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_batch_alter(&amp;$batch) {&#10;  // If the current page request is inside the overlay, add ?render=overlay to&#10;  // the success callback URL, so that it appears correctly within the overlay.&#10;  if (overlay_get_mode() == 'child') {&#10;    if (isset($batch['url_options']['query'])) {&#10;      $batch['url_options']['query']['render'] = 'overlay';&#10;    }&#10;    else {&#10;      $batch['url_options']['query'] = array('render' =&gt; 'overlay');&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_batch_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_updater_info" value="/**&#10; * Implements hook_updater_info().&#10; *&#10; * Provide information on Updaters (classes that can update Drupal).&#10; *&#10; * An Updater is a class that knows how to update various parts of the Drupal&#10; * file system, for example to update modules that have newer releases, or to&#10; * install a new theme.&#10; *&#10; * @return&#10; *   An associative array of information about the updater(s) being provided.&#10; *   This array is keyed by a unique identifier for each updater, and the&#10; *   values are subarrays that can contain the following keys:&#10; *   - class: The name of the PHP class which implements this updater.&#10; *   - name: Human-readable name of this updater.&#10; *   - weight: Controls what order the Updater classes are consulted to decide&#10; *     which one should handle a given task. When an update task is being run,&#10; *     the system will loop through all the Updater classes defined in this&#10; *     registry in weight order and let each class respond to the task and&#10; *     decide if each Updater wants to handle the task. In general, this&#10; *     doesn't matter, but if you need to override an existing Updater, make&#10; *     sure your Updater has a lighter weight so that it comes first.&#10; *&#10; * @see drupal_get_updaters()&#10; * @see hook_updater_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_updater_info() {&#10;  return array(&#10;    'module' =&gt; array(&#10;      'class' =&gt; 'ModuleUpdater',&#10;      'name' =&gt; t('Update modules'),&#10;      'weight' =&gt; 0,&#10;    ),&#10;    'theme' =&gt; array(&#10;      'class' =&gt; 'ThemeUpdater',&#10;      'name' =&gt; t('Update themes'),&#10;      'weight' =&gt; 0,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_updater_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_updater_info" value="/**&#10; * Implements hook_updater_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_updater_info() {&#10;  return array(&#10;    'module' =&gt; array(&#10;      'class' =&gt; 'ModuleUpdater',&#10;      'name' =&gt; t('Update modules'),&#10;      'weight' =&gt; 0,&#10;    ),&#10;    'theme' =&gt; array(&#10;      'class' =&gt; 'ThemeUpdater',&#10;      'name' =&gt; t('Update themes'),&#10;      'weight' =&gt; 0,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_updater_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_updater_info_alter" value="/**&#10; * Implements hook_updater_info_alter().&#10; *&#10; * Alter the Updater information array.&#10; *&#10; * An Updater is a class that knows how to update various parts of the Drupal&#10; * file system, for example to update modules that have newer releases, or to&#10; * install a new theme.&#10; *&#10; * @param array $updaters&#10; *   Associative array of updaters as defined through hook_updater_info().&#10; *   Alter this array directly.&#10; *&#10; * @see drupal_get_updaters()&#10; * @see hook_updater_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_updater_info_alter(&amp;$updaters) {&#10;  // Adjust weight so that the theme Updater gets a chance to handle a given&#10;  // update task before module updaters.&#10;  $updaters['theme']['weight'] = -1;&#10;  $END$&#10;}" description="hook_updater_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_updater_info_alter" value="/**&#10; * Implements hook_updater_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_updater_info_alter(&amp;$updaters) {&#10;  // Adjust weight so that the theme Updater gets a chance to handle a given&#10;  // update task before module updaters.&#10;  $updaters['theme']['weight'] = -1;&#10;  $END$&#10;}" description="hook_updater_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_countries_alter" value="/**&#10; * Implements hook_countries_alter().&#10; *&#10; * Alter the default country list.&#10; *&#10; * @param $countries&#10; *   The associative array of countries keyed by ISO 3166-1 country code.&#10; *&#10; * @see country_get_list()&#10; * @see _country_get_predefined_list()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_countries_alter(&amp;$countries) {&#10;  // Elbonia is now independent, so add it to the country list.&#10;  $countries['EB'] = 'Elbonia';&#10;  $END$&#10;}" description="hook_countries_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_countries_alter" value="/**&#10; * Implements hook_countries_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_countries_alter(&amp;$countries) {&#10;  // Elbonia is now independent, so add it to the country list.&#10;  $countries['EB'] = 'Elbonia';&#10;  $END$&#10;}" description="hook_countries_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_site_status_alter" value="/**&#10; * Implements hook_menu_site_status_alter().&#10; *&#10; * Control site status before menu dispatching.&#10; *&#10; * The hook is called after checking whether the site is offline but before&#10; * the current router item is retrieved and executed by&#10; * menu_execute_active_handler(). If the site is in offline mode,&#10; * $menu_site_status is set to MENU_SITE_OFFLINE.&#10; *&#10; * @param $menu_site_status&#10; *   Supported values are MENU_SITE_OFFLINE, MENU_ACCESS_DENIED,&#10; *   MENU_NOT_FOUND and MENU_SITE_ONLINE. Any other value than&#10; *   MENU_SITE_ONLINE will skip the default menu handling system and be passed&#10; *   for delivery to drupal_deliver_page() with a NULL&#10; *   $default_delivery_callback.&#10; * @param $path&#10; *   Contains the system path that is going to be loaded. This is read only,&#10; *   use hook_url_inbound_alter() to change the path.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_site_status_alter(&amp;$menu_site_status, $path) {&#10;  // Allow access to my_module/authentication even if site is in offline mode.&#10;  if ($menu_site_status == MENU_SITE_OFFLINE &amp;&amp; user_is_anonymous() &amp;&amp; $path == 'my_module/authentication') {&#10;    $menu_site_status = MENU_SITE_ONLINE;&#10;  }&#10;  $END$&#10;}" description="hook_menu_site_status_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_site_status_alter" value="/**&#10; * Implements hook_menu_site_status_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_site_status_alter(&amp;$menu_site_status, $path) {&#10;  // Allow access to my_module/authentication even if site is in offline mode.&#10;  if ($menu_site_status == MENU_SITE_OFFLINE &amp;&amp; user_is_anonymous() &amp;&amp; $path == 'my_module/authentication') {&#10;    $menu_site_status = MENU_SITE_ONLINE;&#10;  }&#10;  $END$&#10;}" description="hook_menu_site_status_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filetransfer_info" value="/**&#10; * Implements hook_filetransfer_info().&#10; *&#10; * Register information about FileTransfer classes provided by a module.&#10; *&#10; * The FileTransfer class allows transferring files over a specific type of&#10; * connection. Core provides classes for FTP and SSH. Contributed modules are&#10; * free to extend the FileTransfer base class to add other connection types,&#10; * and if these classes are registered via hook_filetransfer_info(), those&#10; * connection types will be available to site administrators using the Update&#10; * manager when they are redirected to the authorize.php script to authorize&#10; * the file operations.&#10; *&#10; * @return array&#10; *   Nested array of information about FileTransfer classes. Each key is a&#10; *   FileTransfer type (not human readable, used for form elements and&#10; *   variable names, etc), and the values are subarrays that define properties&#10; *   of that type. The keys in each subarray are:&#10; *   - 'title': Required. The human-readable name of the connection type.&#10; *   - 'class': Required. The name of the FileTransfer class. The constructor&#10; *     will always be passed the full path to the root of the site that should&#10; *     be used to restrict where file transfer operations can occur (the $jail)&#10; *     and an array of settings values returned by the settings form.&#10; *   - 'file': Required. The include file containing the FileTransfer class.&#10; *     This should be a separate .inc file, not just the .module file, so that&#10; *     the minimum possible code is loaded when authorize.php is running.&#10; *   - 'file path': Optional. The directory (relative to the Drupal root)&#10; *     where the include file lives. If not defined, defaults to the base&#10; *     directory of the module implementing the hook.&#10; *   - 'weight': Optional. Integer weight used for sorting connection types on&#10; *     the authorize.php form.&#10; *&#10; * @see FileTransfer&#10; * @see authorize.php&#10; * @see hook_filetransfer_info_alter()&#10; * @see drupal_get_filetransfer_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filetransfer_info() {&#10;  $info['sftp'] = array(&#10;    'title' =&gt; t('SFTP (Secure FTP)'),&#10;    'file' =&gt; 'sftp.filetransfer.inc',&#10;    'class' =&gt; 'FileTransferSFTP',&#10;    'weight' =&gt; 10,&#10;  );&#10;  return $info;&#10;  $END$&#10;}" description="hook_filetransfer_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filetransfer_info" value="/**&#10; * Implements hook_filetransfer_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filetransfer_info() {&#10;  $info['sftp'] = array(&#10;    'title' =&gt; t('SFTP (Secure FTP)'),&#10;    'file' =&gt; 'sftp.filetransfer.inc',&#10;    'class' =&gt; 'FileTransferSFTP',&#10;    'weight' =&gt; 10,&#10;  );&#10;  return $info;&#10;  $END$&#10;}" description="hook_filetransfer_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filetransfer_info_alter" value="/**&#10; * Implements hook_filetransfer_info_alter().&#10; *&#10; * Alter the FileTransfer class registry.&#10; *&#10; * @param array $filetransfer_info&#10; *   Reference to a nested array containing information about the FileTransfer&#10; *   class registry.&#10; *&#10; * @see hook_filetransfer_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filetransfer_info_alter(&amp;$filetransfer_info) {&#10;  if (variable_get('paranoia', FALSE)) {&#10;    // Remove the FTP option entirely.&#10;    unset($filetransfer_info['ftp']);&#10;    // Make sure the SSH option is listed first.&#10;    $filetransfer_info['ssh']['weight'] = -10;&#10;  }&#10;  $END$&#10;}" description="hook_filetransfer_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filetransfer_info_alter" value="/**&#10; * Implements hook_filetransfer_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filetransfer_info_alter(&amp;$filetransfer_info) {&#10;  if (variable_get('paranoia', FALSE)) {&#10;    // Remove the FTP option entirely.&#10;    unset($filetransfer_info['ftp']);&#10;    // Make sure the SSH option is listed first.&#10;    $filetransfer_info['ssh']['weight'] = -10;&#10;  }&#10;  $END$&#10;}" description="hook_filetransfer_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_form_system_theme_settings_alter" value="/**&#10; * Implements hook_form_system_theme_settings_alter().&#10; *&#10; * Allow themes to alter the theme-specific settings form.&#10; *&#10; * With this hook, themes can alter the theme-specific settings form in any way&#10; * allowable by Drupal's Forms API, such as adding form elements, changing&#10; * default values and removing form elements. See the Forms API documentation on&#10; * api.drupal.org for detailed information.&#10; *&#10; * Note that the base theme's form alterations will be run before any sub-theme&#10; * alterations.&#10; *&#10; * @param $form&#10; *   Nested array of form elements that comprise the form.&#10; * @param $form_state&#10; *   A keyed array containing the current state of the form.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_system_theme_settings_alter(&amp;$form, &amp;$form_state) {&#10;  // Add a checkbox to toggle the breadcrumb trail.&#10;  $form['toggle_breadcrumb'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t('Display the breadcrumb'),&#10;    '#default_value' =&gt; theme_get_setting('toggle_breadcrumb'),&#10;    '#description'   =&gt; t('Show a trail of links from the homepage to the current page.'),&#10;  );&#10;  $END$&#10;}" description="hook_form_system_theme_settings_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_form_system_theme_settings_alter" value="/**&#10; * Implements hook_form_system_theme_settings_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_form_system_theme_settings_alter(&amp;$form, &amp;$form_state) {&#10;  // Add a checkbox to toggle the breadcrumb trail.&#10;  $form['toggle_breadcrumb'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t('Display the breadcrumb'),&#10;    '#default_value' =&gt; theme_get_setting('toggle_breadcrumb'),&#10;    '#description'   =&gt; t('Show a trail of links from the homepage to the current page.'),&#10;  );&#10;  $END$&#10;}" description="hook_form_system_theme_settings_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_preprocess" value="/**&#10; * Implements hook_preprocess().&#10; *&#10; * Preprocess theme variables.&#10; *&#10; * This hook allows modules to preprocess theme variables for theme templates.&#10; * It is called for all invocations of theme(), to allow modules to add to&#10; * or override variables for all theme hooks.&#10; *&#10; * For more detailed information, see theme().&#10; *&#10; * @param $variables&#10; *   The variables array (modify in place).&#10; * @param $hook&#10; *   The name of the theme hook.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_preprocess(&amp;$variables, $hook) {&#10; static $hooks;&#10;&#10;  // Add contextual links to the variables, if the user has permission.&#10;&#10;  if (!user_access('access contextual links')) {&#10;    return;&#10;  }&#10;&#10;  if (!isset($hooks)) {&#10;    $hooks = theme_get_registry();&#10;  }&#10;&#10;  // Determine the primary theme function argument.&#10;  if (isset($hooks[$hook]['variables'])) {&#10;    $keys = array_keys($hooks[$hook]['variables']);&#10;    $key = $keys[0];&#10;  }&#10;  else {&#10;    $key = $hooks[$hook]['render element'];&#10;  }&#10;&#10;  if (isset($variables[$key])) {&#10;    $element = $variables[$key];&#10;  }&#10;&#10;  if (isset($element) &amp;&amp; is_array($element) &amp;&amp; !empty($element['#contextual_links'])) {&#10;    $variables['title_suffix']['contextual_links'] = contextual_links_view($element);&#10;    if (!empty($variables['title_suffix']['contextual_links'])) {&#10;      $variables['classes_array'][] = 'contextual-links-region';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_preprocess" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_preprocess" value="/**&#10; * Implements hook_preprocess().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_preprocess(&amp;$variables, $hook) {&#10; static $hooks;&#10;&#10;  // Add contextual links to the variables, if the user has permission.&#10;&#10;  if (!user_access('access contextual links')) {&#10;    return;&#10;  }&#10;&#10;  if (!isset($hooks)) {&#10;    $hooks = theme_get_registry();&#10;  }&#10;&#10;  // Determine the primary theme function argument.&#10;  if (isset($hooks[$hook]['variables'])) {&#10;    $keys = array_keys($hooks[$hook]['variables']);&#10;    $key = $keys[0];&#10;  }&#10;  else {&#10;    $key = $hooks[$hook]['render element'];&#10;  }&#10;&#10;  if (isset($variables[$key])) {&#10;    $element = $variables[$key];&#10;  }&#10;&#10;  if (isset($element) &amp;&amp; is_array($element) &amp;&amp; !empty($element['#contextual_links'])) {&#10;    $variables['title_suffix']['contextual_links'] = contextual_links_view($element);&#10;    if (!empty($variables['title_suffix']['contextual_links'])) {&#10;      $variables['classes_array'][] = 'contextual-links-region';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_preprocess" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_preprocess_HOOK" value="/**&#10; * Implements hook_preprocess_HOOK().&#10; *&#10; * Preprocess theme variables for a specific theme hook.&#10; *&#10; * This hook allows modules to preprocess theme variables for a specific theme&#10; * hook. It should only be used if a module needs to override or add to the&#10; * theme preprocessing for a theme hook it didn't define.&#10; *&#10; * For more detailed information, see theme().&#10; *&#10; * @param $variables&#10; *   The variables array (modify in place).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_preprocess_HOOK(&amp;$variables) {&#10;  // This example is from rdf_preprocess_image(). It adds an RDF attribute&#10;  // to the image hook's variables.&#10;  $variables['attributes']['typeof'] = array('foaf:Image');&#10;  $END$&#10;}" description="hook_preprocess_HOOK" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_preprocess_HOOK" value="/**&#10; * Implements hook_preprocess_HOOK().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_preprocess_HOOK(&amp;$variables) {&#10;  // This example is from rdf_preprocess_image(). It adds an RDF attribute&#10;  // to the image hook's variables.&#10;  $variables['attributes']['typeof'] = array('foaf:Image');&#10;  $END$&#10;}" description="hook_preprocess_HOOK" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_process" value="/**&#10; * Implements hook_process().&#10; *&#10; * Process theme variables.&#10; *&#10; * This hook allows modules to process theme variables for theme templates.&#10; * It is called for all invocations of theme(), to allow modules to add to&#10; * or override variables for all theme hooks.&#10; *&#10; * For more detailed information, see theme().&#10; *&#10; * @param $variables&#10; *   The variables array (modify in place).&#10; * @param $hook&#10; *   The name of the theme hook.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_process(&amp;$variables, $hook) {&#10;  // Wraps variables in RDF wrappers.&#10;  if (!empty($variables['rdf_template_variable_attributes_array'])) {&#10;    foreach ($variables['rdf_template_variable_attributes_array'] as $variable_name =&gt; $attributes) {&#10;      $context = array(&#10;        'hook' =&gt; $hook,&#10;        'variable_name' =&gt; $variable_name,&#10;        'variables' =&gt; $variables,&#10;      );&#10;      $variables[$variable_name] = theme('rdf_template_variable_wrapper', array('content' =&gt; $variables[$variable_name], 'attributes' =&gt; $attributes, 'context' =&gt; $context));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_process" value="/**&#10; * Implements hook_process().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_process(&amp;$variables, $hook) {&#10;  // Wraps variables in RDF wrappers.&#10;  if (!empty($variables['rdf_template_variable_attributes_array'])) {&#10;    foreach ($variables['rdf_template_variable_attributes_array'] as $variable_name =&gt; $attributes) {&#10;      $context = array(&#10;        'hook' =&gt; $hook,&#10;        'variable_name' =&gt; $variable_name,&#10;        'variables' =&gt; $variables,&#10;      );&#10;      $variables[$variable_name] = theme('rdf_template_variable_wrapper', array('content' =&gt; $variables[$variable_name], 'attributes' =&gt; $attributes, 'context' =&gt; $context));&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_process_HOOK" value="/**&#10; * Implements hook_process_HOOK().&#10; *&#10; * Process theme variables for a specific theme hook.&#10; *&#10; * This hook allows modules to process theme variables for a specific theme&#10; * hook. It should only be used if a module needs to override or add to the&#10; * theme processing for a theme hook it didn't define.&#10; *&#10; * For more detailed information, see theme().&#10; *&#10; * @param $variables&#10; *   The variables array (modify in place).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_process_HOOK(&amp;$variables) {&#10;  $variables['classes'] .= ' my_added_class';&#10;  $END$&#10;}" description="hook_process_HOOK" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_process_HOOK" value="/**&#10; * Implements hook_process_HOOK().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_process_HOOK(&amp;$variables) {&#10;  $variables['classes'] .= ' my_added_class';&#10;  $END$&#10;}" description="hook_process_HOOK" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_themes_enabled" value="/**&#10; * Implements hook_themes_enabled().&#10; *&#10; * Respond to themes being enabled.&#10; *&#10; * @param array $theme_list&#10; *   Array containing the names of the themes being enabled.&#10; *&#10; * @see theme_enable()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_themes_enabled($theme_list) {&#10;  foreach ($theme_list as $theme) {&#10;    block_theme_initialize($theme);&#10;  }&#10;  $END$&#10;}" description="hook_themes_enabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_themes_enabled" value="/**&#10; * Implements hook_themes_enabled().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_themes_enabled($theme_list) {&#10;  foreach ($theme_list as $theme) {&#10;    block_theme_initialize($theme);&#10;  }&#10;  $END$&#10;}" description="hook_themes_enabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_themes_disabled" value="/**&#10; * Implements hook_themes_disabled().&#10; *&#10; * Respond to themes being disabled.&#10; *&#10; * @param array $theme_list&#10; *   Array containing the names of the themes being disabled.&#10; *&#10; * @see theme_disable()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_themes_disabled($theme_list) {&#10; // Clear all update module caches.&#10;  _update_cache_clear();&#10;  $END$&#10;}" description="hook_themes_disabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_themes_disabled" value="/**&#10; * Implements hook_themes_disabled().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_themes_disabled($theme_list) {&#10; // Clear all update module caches.&#10;  _update_cache_clear();&#10;  $END$&#10;}" description="hook_themes_disabled" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_presave" value="/**&#10; * Implements hook_comment_presave().&#10; *&#10; * The comment passed validation and is about to be saved.&#10; *&#10; * Modules may make changes to the comment before it is saved to the database.&#10; *&#10; * @param $comment&#10; *   The comment object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_presave($comment) {&#10;  // Remove leading &amp; trailing spaces from the comment subject.&#10;  $comment-&gt;subject = trim($comment-&gt;subject);&#10;  $END$&#10;}" description="hook_comment_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_presave" value="/**&#10; * Implements hook_comment_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_presave($comment) {&#10;  // Remove leading &amp; trailing spaces from the comment subject.&#10;  $comment-&gt;subject = trim($comment-&gt;subject);&#10;  $END$&#10;}" description="hook_comment_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_insert" value="/**&#10; * Implements hook_comment_insert().&#10; *&#10; * The comment is being inserted.&#10; *&#10; * @param $comment&#10; *   The comment object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_insert($comment) {&#10;  // Reindex the node when comments are added.&#10;  search_touch_node($comment-&gt;nid);&#10;  $END$&#10;}" description="hook_comment_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_insert" value="/**&#10; * Implements hook_comment_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_insert($comment) {&#10;  // Reindex the node when comments are added.&#10;  search_touch_node($comment-&gt;nid);&#10;  $END$&#10;}" description="hook_comment_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_update" value="/**&#10; * Implements hook_comment_update().&#10; *&#10; * The comment is being updated.&#10; *&#10; * @param $comment&#10; *   The comment object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_update($comment) {&#10;  // Reindex the node when comments are updated.&#10;  search_touch_node($comment-&gt;nid);&#10;  $END$&#10;}" description="hook_comment_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_update" value="/**&#10; * Implements hook_comment_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_update($comment) {&#10;  // Reindex the node when comments are updated.&#10;  search_touch_node($comment-&gt;nid);&#10;  $END$&#10;}" description="hook_comment_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_load" value="/**&#10; * Implements hook_comment_load().&#10; *&#10; * Comments are being loaded from the database.&#10; *&#10; * @param $comments&#10; *  An array of comment objects indexed by cid.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_load($comments) {&#10;  $result = db_query('SELECT cid, foo FROM {mytable} WHERE cid IN (:cids)', array(':cids' =&gt; array_keys($comments)));&#10;  foreach ($result as $record) {&#10;    $comments[$record-&gt;cid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_comment_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_load" value="/**&#10; * Implements hook_comment_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_load($comments) {&#10;  $result = db_query('SELECT cid, foo FROM {mytable} WHERE cid IN (:cids)', array(':cids' =&gt; array_keys($comments)));&#10;  foreach ($result as $record) {&#10;    $comments[$record-&gt;cid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_comment_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_view" value="/**&#10; * Implements hook_comment_view().&#10; *&#10; * The comment is being viewed. This hook can be used to add additional data to the comment before theming.&#10; *&#10; * @param $comment&#10; *   Passes in the comment the action is being performed on.&#10; * @param $view_mode&#10; *   View mode, e.g. 'full', 'teaser'...&#10; * @param $langcode&#10; *   The language code used for rendering.&#10; *&#10; * @see hook_entity_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_view($comment, $view_mode, $langcode) {&#10;  // how old is the comment&#10;  $comment-&gt;time_ago = time() - $comment-&gt;changed;&#10;  $END$&#10;}" description="hook_comment_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_view" value="/**&#10; * Implements hook_comment_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_view($comment, $view_mode, $langcode) {&#10;  // how old is the comment&#10;  $comment-&gt;time_ago = time() - $comment-&gt;changed;&#10;  $END$&#10;}" description="hook_comment_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_view_alter" value="/**&#10; * Implements hook_comment_view_alter().&#10; *&#10; * The comment was built; the module may modify the structured content.&#10; *&#10; * This hook is called after the content has been assembled in a structured array&#10; * and may be used for doing processing which requires that the complete comment&#10; * content structure has been built.&#10; *&#10; * If the module wishes to act on the rendered HTML of the comment rather than the&#10; * structured content array, it may use this hook to add a #post_render callback.&#10; * Alternatively, it could also implement hook_preprocess_comment(). See&#10; * drupal_render() and theme() documentation respectively for details.&#10; *&#10; * @param $build&#10; *   A renderable array representing the comment.&#10; *&#10; * @see comment_view()&#10; * @see hook_entity_view_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_view_alter(&amp;$build) {&#10;  // Check for the existence of a field added by another module.&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the comment.&#10;  $build['#post_render'][] = 'my_module_comment_post_render';&#10;  $END$&#10;}" description="hook_comment_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_view_alter" value="/**&#10; * Implements hook_comment_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_view_alter(&amp;$build) {&#10;  // Check for the existence of a field added by another module.&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the comment.&#10;  $build['#post_render'][] = 'my_module_comment_post_render';&#10;  $END$&#10;}" description="hook_comment_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_publish" value="/**&#10; * Implements hook_comment_publish().&#10; *&#10; * The comment is being published by the moderator.&#10; *&#10; * @param $comment&#10; *   Passes in the comment the action is being performed on.&#10; * @return&#10; *   Nothing.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_publish($comment) {&#10;  drupal_set_message(t('Comment: @subject has been published', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_publish" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_publish" value="/**&#10; * Implements hook_comment_publish().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_publish($comment) {&#10;  drupal_set_message(t('Comment: @subject has been published', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_publish" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_unpublish" value="/**&#10; * Implements hook_comment_unpublish().&#10; *&#10; * The comment is being unpublished by the moderator.&#10; *&#10; * @param $comment&#10; *   Passes in the comment the action is being performed on.&#10; * @return&#10; *   Nothing.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_unpublish($comment) {&#10;  drupal_set_message(t('Comment: @subject has been unpublished', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_unpublish" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_unpublish" value="/**&#10; * Implements hook_comment_unpublish().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_unpublish($comment) {&#10;  drupal_set_message(t('Comment: @subject has been unpublished', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_unpublish" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_comment_delete" value="/**&#10; * Implements hook_comment_delete().&#10; *&#10; * The comment is being deleted by the moderator.&#10; *&#10; * @param $comment&#10; *   Passes in the comment the action is being performed on.&#10; * @return&#10; *   Nothing.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_delete($comment) {&#10;  drupal_set_message(t('Comment: @subject has been deleted', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_comment_delete" value="/**&#10; * Implements hook_comment_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_comment_delete($comment) {&#10;  drupal_set_message(t('Comment: @subject has been deleted', array('@subject' =&gt; $comment-&gt;subject)));&#10;  $END$&#10;}" description="hook_comment_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_vocabulary_load" value="/**&#10; * Implements hook_taxonomy_vocabulary_load().&#10; *&#10; * Act on taxonomy vocabularies when loaded.&#10; *&#10; * Modules implementing this hook can act on the vocabulary objects before they&#10; * are returned by taxonomy_vocabulary_load_multiple().&#10; *&#10; * @param $vocabulary&#10; *   An array of taxonomy vocabulary objects.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_load($vocabularies) {&#10;  foreach ($vocabularies as $vocabulary) {&#10;    $vocabulary-&gt;synonyms = variable_get('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', FALSE);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_vocabulary_load" value="/**&#10; * Implements hook_taxonomy_vocabulary_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_load($vocabularies) {&#10;  foreach ($vocabularies as $vocabulary) {&#10;    $vocabulary-&gt;synonyms = variable_get('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', FALSE);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_vocabulary_presave" value="/**&#10; * Implements hook_taxonomy_vocabulary_presave().&#10; *&#10; * Act on taxonomy vocabularies before they are saved.&#10; *&#10; * Modules implementing this hook can act on the vocabulary object before it is&#10; * inserted or updated.&#10; *&#10; * @param $vocabulary&#10; *   A taxonomy vocabulary object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_presave($vocabulary) {&#10;  $vocabulary-&gt;foo = 'bar';&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_vocabulary_presave" value="/**&#10; * Implements hook_taxonomy_vocabulary_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_presave($vocabulary) {&#10;  $vocabulary-&gt;foo = 'bar';&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_vocabulary_insert" value="/**&#10; * Implements hook_taxonomy_vocabulary_insert().&#10; *&#10; * Act on taxonomy vocabularies when inserted.&#10; *&#10; * Modules implementing this hook can act on the vocabulary object when saved&#10; * to the database.&#10; *&#10; * @param $vocabulary&#10; *   A taxonomy vocabulary object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_insert($vocabulary) {&#10;  if ($vocabulary-&gt;synonyms) {&#10;    variable_set('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', TRUE);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_vocabulary_insert" value="/**&#10; * Implements hook_taxonomy_vocabulary_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_insert($vocabulary) {&#10;  if ($vocabulary-&gt;synonyms) {&#10;    variable_set('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', TRUE);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_vocabulary_update" value="/**&#10; * Implements hook_taxonomy_vocabulary_update().&#10; *&#10; * Act on taxonomy vocabularies when updated.&#10; *&#10; * Modules implementing this hook can act on the vocabulary object when updated.&#10; *&#10; * @param $vocabulary&#10; *   A taxonomy vocabulary object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_update($vocabulary) {&#10;  $status = $vocabulary-&gt;synonyms ? TRUE : FALSE;&#10;  if ($vocabulary-&gt;synonyms) {&#10;    variable_set('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', $status);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_vocabulary_update" value="/**&#10; * Implements hook_taxonomy_vocabulary_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_update($vocabulary) {&#10;  $status = $vocabulary-&gt;synonyms ? TRUE : FALSE;&#10;  if ($vocabulary-&gt;synonyms) {&#10;    variable_set('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', $status);&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_vocabulary_delete" value="/**&#10; * Implements hook_taxonomy_vocabulary_delete().&#10; *&#10; * Respond to the deletion of taxonomy vocabularies.&#10; *&#10; * Modules implementing this hook can respond to the deletion of taxonomy&#10; * vocabularies from the database.&#10; *&#10; * @param $vocabulary&#10; *   A taxonomy vocabulary object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_delete($vocabulary) {&#10;  if (variable_get('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', FALSE)) {&#10;    variable_del('taxonomy_' . $vocabulary-&gt;vid . '_synonyms');&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_vocabulary_delete" value="/**&#10; * Implements hook_taxonomy_vocabulary_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_vocabulary_delete($vocabulary) {&#10;  if (variable_get('taxonomy_' . $vocabulary-&gt;vid . '_synonyms', FALSE)) {&#10;    variable_del('taxonomy_' . $vocabulary-&gt;vid . '_synonyms');&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_vocabulary_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_load" value="/**&#10; * Implements hook_taxonomy_term_load().&#10; *&#10; * Act on taxonomy terms when loaded.&#10; *&#10; * Modules implementing this hook can act on the term objects returned by&#10; * taxonomy_term_load_multiple().&#10; *&#10; * For performance reasons, information to be added to term objects should be&#10; * loaded in a single query for all terms where possible.&#10; *&#10; * Since terms are stored and retrieved from cache during a page request, avoid&#10; * altering properties provided by the {taxonomy_term_data} table, since this&#10; * may affect the way results are loaded from cache in subsequent calls.&#10; *&#10; * @param $terms&#10; *   An array of term objects, indexed by tid.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_load($terms) {&#10;  $result = db_query('SELECT tid, foo FROM {mytable} WHERE tid IN (:tids)', array(':tids' =&gt; array_keys($terms)));&#10;  foreach ($result as $record) {&#10;    $terms[$record-&gt;tid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_load" value="/**&#10; * Implements hook_taxonomy_term_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_load($terms) {&#10;  $result = db_query('SELECT tid, foo FROM {mytable} WHERE tid IN (:tids)', array(':tids' =&gt; array_keys($terms)));&#10;  foreach ($result as $record) {&#10;    $terms[$record-&gt;tid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_presave" value="/**&#10; * Implements hook_taxonomy_term_presave().&#10; *&#10; * Act on taxonomy terms before they are saved.&#10; *&#10; * Modules implementing this hook can act on the term object before it is&#10; * inserted or updated.&#10; *&#10; * @param $term&#10; *   A term object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_presave($term) {&#10;  $term-&gt;foo = 'bar';&#10;  $END$&#10;}" description="hook_taxonomy_term_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_presave" value="/**&#10; * Implements hook_taxonomy_term_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_presave($term) {&#10;  $term-&gt;foo = 'bar';&#10;  $END$&#10;}" description="hook_taxonomy_term_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_insert" value="/**&#10; * Implements hook_taxonomy_term_insert().&#10; *&#10; * Act on taxonomy terms when inserted.&#10; *&#10; * Modules implementing this hook can act on the term object when saved to&#10; * the database.&#10; *&#10; * @param $term&#10; *   A taxonomy term object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_insert($term) {&#10;  if (!empty($term-&gt;synonyms)) {&#10;    foreach (explode (&quot;\n&quot;, str_replace(&quot;\r&quot;, '', $term-&gt;synonyms)) as $synonym) {&#10;      if ($synonym) {&#10;        db_insert('taxonomy_term_synonym')&#10;        -&gt;fields(array(&#10;          'tid' =&gt; $term-&gt;tid,&#10;          'name' =&gt; rtrim($synonym),&#10;        ))&#10;        -&gt;execute();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_insert" value="/**&#10; * Implements hook_taxonomy_term_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_insert($term) {&#10;  if (!empty($term-&gt;synonyms)) {&#10;    foreach (explode (&quot;\n&quot;, str_replace(&quot;\r&quot;, '', $term-&gt;synonyms)) as $synonym) {&#10;      if ($synonym) {&#10;        db_insert('taxonomy_term_synonym')&#10;        -&gt;fields(array(&#10;          'tid' =&gt; $term-&gt;tid,&#10;          'name' =&gt; rtrim($synonym),&#10;        ))&#10;        -&gt;execute();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_update" value="/**&#10; * Implements hook_taxonomy_term_update().&#10; *&#10; * Act on taxonomy terms when updated.&#10; *&#10; * Modules implementing this hook can act on the term object when updated.&#10; *&#10; * @param $term&#10; *   A taxonomy term object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_update($term) {&#10;  hook_taxonomy_term_delete($term);&#10;  if (!empty($term-&gt;synonyms)) {&#10;    foreach (explode (&quot;\n&quot;, str_replace(&quot;\r&quot;, '', $term-&gt;synonyms)) as $synonym) {&#10;      if ($synonym) {&#10;        db_insert('taxonomy_term_synonym')&#10;        -&gt;fields(array(&#10;          'tid' =&gt; $term-&gt;tid,&#10;          'name' =&gt; rtrim($synonym),&#10;        ))&#10;        -&gt;execute();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_update" value="/**&#10; * Implements hook_taxonomy_term_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_update($term) {&#10;  hook_taxonomy_term_delete($term);&#10;  if (!empty($term-&gt;synonyms)) {&#10;    foreach (explode (&quot;\n&quot;, str_replace(&quot;\r&quot;, '', $term-&gt;synonyms)) as $synonym) {&#10;      if ($synonym) {&#10;        db_insert('taxonomy_term_synonym')&#10;        -&gt;fields(array(&#10;          'tid' =&gt; $term-&gt;tid,&#10;          'name' =&gt; rtrim($synonym),&#10;        ))&#10;        -&gt;execute();&#10;      }&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_taxonomy_term_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_delete" value="/**&#10; * Implements hook_taxonomy_term_delete().&#10; *&#10; * Respond to the deletion of taxonomy terms.&#10; *&#10; * Modules implementing this hook can respond to the deletion of taxonomy&#10; * terms from the database.&#10; *&#10; * @param $term&#10; *   A taxonomy term object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_delete($term) {&#10;  db_delete('term_synoynm')-&gt;condition('tid', $term-&gt;tid)-&gt;execute();&#10;  $END$&#10;}" description="hook_taxonomy_term_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_delete" value="/**&#10; * Implements hook_taxonomy_term_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_delete($term) {&#10;  db_delete('term_synoynm')-&gt;condition('tid', $term-&gt;tid)-&gt;execute();&#10;  $END$&#10;}" description="hook_taxonomy_term_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_term_view_alter" value="/**&#10; * Implements hook_taxonomy_term_view_alter().&#10; *&#10; * Alter the results of taxonomy_term_view().&#10; *&#10; * This hook is called after the content has been assembled in a structured&#10; * array and may be used for doing processing which requires that the complete&#10; * taxonomy term content structure has been built.&#10; *&#10; * If the module wishes to act on the rendered HTML of the term rather than the&#10; * structured content array, it may use this hook to add a #post_render&#10; * callback. Alternatively, it could also implement&#10; * hook_preprocess_taxonomy_term(). See drupal_render() and theme()&#10; * documentation respectively for details.&#10; *&#10; * @param $build&#10; *   A renderable array representing the node content.&#10; *&#10; * @see hook_entity_view_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_view_alter(&amp;$build) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the term.&#10;  $build['#post_render'][] = 'my_module_node_post_render';&#10;  $END$&#10;}" description="hook_taxonomy_term_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_term_view_alter" value="/**&#10; * Implements hook_taxonomy_term_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_term_view_alter(&amp;$build) {&#10;  if ($build['#view_mode'] == 'full' &amp;&amp; isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the term.&#10;  $build['#post_render'][] = 'my_module_node_post_render';&#10;  $END$&#10;}" description="hook_taxonomy_term_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_load" value="/**&#10; * Implements hook_user_load().&#10; *&#10; * Act on user objects when loaded from the database.&#10; *&#10; * Due to the static cache in user_load_multiple() you should not use this&#10; * hook to modify the user properties returned by the {users} table itself&#10; * since this may result in unreliable results when loading from cache.&#10; *&#10; * @param $users&#10; *   An array of user objects, indexed by uid.&#10; *&#10; * @see user_load_multiple()&#10; * @see profile_user_load()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_load($users) {&#10;  $result = db_query('SELECT uid, foo FROM {my_table} WHERE uid IN (:uids)', array(':uids' =&gt; array_keys($users)));&#10;  foreach ($result as $record) {&#10;    $users[$record-&gt;uid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_user_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_load" value="/**&#10; * Implements hook_user_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_load($users) {&#10;  $result = db_query('SELECT uid, foo FROM {my_table} WHERE uid IN (:uids)', array(':uids' =&gt; array_keys($users)));&#10;  foreach ($result as $record) {&#10;    $users[$record-&gt;uid]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_user_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_delete" value="/**&#10; * Implements hook_user_delete().&#10; *&#10; * Respond to user deletion.&#10; *&#10; * This hook is invoked from user_delete_multiple() before field_attach_delete()&#10; * is called and before users are actually removed from the database.&#10; *&#10; * Modules should additionally implement hook_user_cancel() to process stored&#10; * user data for other account cancellation methods.&#10; *&#10; * @param $account&#10; *   The account that is being deleted.&#10; *&#10; * @see user_delete_multiple()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_delete($account) {&#10;  db_delete('mytable')&#10;    -&gt;condition('uid', $account-&gt;uid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_delete" value="/**&#10; * Implements hook_user_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_delete($account) {&#10;  db_delete('mytable')&#10;    -&gt;condition('uid', $account-&gt;uid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_cancel" value="/**&#10; * Implements hook_user_cancel().&#10; *&#10; * Act on user account cancellations.&#10; *&#10; * This hook is invoked from user_cancel() before a user account is canceled.&#10; * Depending on the account cancellation method, the module should either do&#10; * nothing, unpublish content, or anonymize content. See user_cancel_methods()&#10; * for the list of default account cancellation methods provided by User module.&#10; * Modules may add further methods via hook_user_cancel_methods_alter().&#10; *&#10; * This hook is NOT invoked for the 'user_cancel_delete' account cancellation&#10; * method. To react on this method, implement hook_user_delete() instead.&#10; *&#10; * Expensive operations should be added to the global account cancellation batch&#10; * by using batch_set().&#10; *&#10; * @param $edit&#10; *   The array of form values submitted by the user.&#10; * @param $account&#10; *   The user object on which the operation is being performed.&#10; * @param $method&#10; *   The account cancellation method.&#10; *&#10; * @see user_cancel_methods()&#10; * @see hook_user_cancel_methods_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_cancel($edit, $account, $method) {&#10;  switch ($method) {&#10;    case 'user_cancel_block_unpublish':&#10;      // Unpublish nodes (current revisions).&#10;      module_load_include('inc', 'node', 'node.admin');&#10;      $nodes = db_select('node', 'n')&#10;        -&gt;fields('n', array('nid'))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute()&#10;        -&gt;fetchCol();&#10;      node_mass_update($nodes, array('status' =&gt; 0));&#10;      break;&#10;&#10;    case 'user_cancel_reassign':&#10;      // Anonymize nodes (current revisions).&#10;      module_load_include('inc', 'node', 'node.admin');&#10;      $nodes = db_select('node', 'n')&#10;        -&gt;fields('n', array('nid'))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute()&#10;        -&gt;fetchCol();&#10;      node_mass_update($nodes, array('uid' =&gt; 0));&#10;      // Anonymize old revisions.&#10;      db_update('node_revision')&#10;        -&gt;fields(array('uid' =&gt; 0))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute();&#10;      // Clean history.&#10;      db_delete('history')&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute();&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_user_cancel" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_cancel" value="/**&#10; * Implements hook_user_cancel().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_cancel($edit, $account, $method) {&#10;  switch ($method) {&#10;    case 'user_cancel_block_unpublish':&#10;      // Unpublish nodes (current revisions).&#10;      module_load_include('inc', 'node', 'node.admin');&#10;      $nodes = db_select('node', 'n')&#10;        -&gt;fields('n', array('nid'))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute()&#10;        -&gt;fetchCol();&#10;      node_mass_update($nodes, array('status' =&gt; 0));&#10;      break;&#10;&#10;    case 'user_cancel_reassign':&#10;      // Anonymize nodes (current revisions).&#10;      module_load_include('inc', 'node', 'node.admin');&#10;      $nodes = db_select('node', 'n')&#10;        -&gt;fields('n', array('nid'))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute()&#10;        -&gt;fetchCol();&#10;      node_mass_update($nodes, array('uid' =&gt; 0));&#10;      // Anonymize old revisions.&#10;      db_update('node_revision')&#10;        -&gt;fields(array('uid' =&gt; 0))&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute();&#10;      // Clean history.&#10;      db_delete('history')&#10;        -&gt;condition('uid', $account-&gt;uid)&#10;        -&gt;execute();&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_user_cancel" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_cancel_methods_alter" value="/**&#10; * Implements hook_user_cancel_methods_alter().&#10; *&#10; * Modify account cancellation methods.&#10; *&#10; * By implementing this hook, modules are able to add, customize, or remove&#10; * account cancellation methods. All defined methods are turned into radio&#10; * button form elements by user_cancel_methods() after this hook is invoked.&#10; * The following properties can be defined for each method:&#10; * - title: The radio button's title.&#10; * - description: (optional) A description to display on the confirmation form&#10; *   if the user is not allowed to select the account cancellation method. The&#10; *   description is NOT used for the radio button, but instead should provide&#10; *   additional explanation to the user seeking to cancel their account.&#10; * - access: (optional) A boolean value indicating whether the user can access&#10; *   a method. If #access is defined, the method cannot be configured as default&#10; *   method.&#10; *&#10; * @param $methods&#10; *   An array containing user account cancellation methods, keyed by method id.&#10; *&#10; * @see user_cancel_methods()&#10; * @see user_cancel_confirm_form()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_cancel_methods_alter(&amp;$methods) {&#10;  // Limit access to disable account and unpublish content method.&#10;  $methods['user_cancel_block_unpublish']['access'] = user_access('administer site configuration');&#10;&#10;  // Remove the content re-assigning method.&#10;  unset($methods['user_cancel_reassign']);&#10;&#10;  // Add a custom zero-out method.&#10;  $methods['mymodule_zero_out'] = array(&#10;    'title' =&gt; t('Delete the account and remove all content.'),&#10;    'description' =&gt; t('All your content will be replaced by empty strings.'),&#10;    // access should be used for administrative methods only.&#10;    'access' =&gt; user_access('access zero-out account cancellation method'),&#10;  );&#10;  $END$&#10;}" description="hook_user_cancel_methods_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_cancel_methods_alter" value="/**&#10; * Implements hook_user_cancel_methods_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_cancel_methods_alter(&amp;$methods) {&#10;  // Limit access to disable account and unpublish content method.&#10;  $methods['user_cancel_block_unpublish']['access'] = user_access('administer site configuration');&#10;&#10;  // Remove the content re-assigning method.&#10;  unset($methods['user_cancel_reassign']);&#10;&#10;  // Add a custom zero-out method.&#10;  $methods['mymodule_zero_out'] = array(&#10;    'title' =&gt; t('Delete the account and remove all content.'),&#10;    'description' =&gt; t('All your content will be replaced by empty strings.'),&#10;    // access should be used for administrative methods only.&#10;    'access' =&gt; user_access('access zero-out account cancellation method'),&#10;  );&#10;  $END$&#10;}" description="hook_user_cancel_methods_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_operations" value="/**&#10; * Implements hook_user_operations().&#10; *&#10; * Add mass user operations.&#10; *&#10; * This hook enables modules to inject custom operations into the mass operations&#10; * dropdown found at admin/people, by associating a callback function with&#10; * the operation, which is called when the form is submitted. The callback function&#10; * receives one initial argument, which is an array of the checked users.&#10; *&#10; * @return&#10; *   An array of operations. Each operation is an associative array that may&#10; *   contain the following key-value pairs:&#10; *   - &quot;label&quot;: Required. The label for the operation, displayed in the dropdown menu.&#10; *   - &quot;callback&quot;: Required. The function to call for the operation.&#10; *   - &quot;callback arguments&quot;: Optional. An array of additional arguments to pass to&#10; *     the callback function.&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_operations() {&#10;  $operations = array(&#10;    'unblock' =&gt; array(&#10;      'label' =&gt; t('Unblock the selected users'),&#10;      'callback' =&gt; 'user_user_operations_unblock',&#10;    ),&#10;    'block' =&gt; array(&#10;      'label' =&gt; t('Block the selected users'),&#10;      'callback' =&gt; 'user_user_operations_block',&#10;    ),&#10;    'cancel' =&gt; array(&#10;      'label' =&gt; t('Cancel the selected user accounts'),&#10;    ),&#10;  );&#10;  return $operations;&#10;  $END$&#10;}" description="hook_user_operations" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_operations" value="/**&#10; * Implements hook_user_operations().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_operations() {&#10;  $operations = array(&#10;    'unblock' =&gt; array(&#10;      'label' =&gt; t('Unblock the selected users'),&#10;      'callback' =&gt; 'user_user_operations_unblock',&#10;    ),&#10;    'block' =&gt; array(&#10;      'label' =&gt; t('Block the selected users'),&#10;      'callback' =&gt; 'user_user_operations_block',&#10;    ),&#10;    'cancel' =&gt; array(&#10;      'label' =&gt; t('Cancel the selected user accounts'),&#10;    ),&#10;  );&#10;  return $operations;&#10;  $END$&#10;}" description="hook_user_operations" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_categories" value="/**&#10; * Implements hook_user_categories().&#10; *&#10; * Retrieve a list of user setting or profile information categories.&#10; *&#10; * @return&#10; *   An array of associative arrays. Each inner array has elements:&#10; *   - &quot;name&quot;: The internal name of the category.&#10; *   - &quot;title&quot;: The human-readable, localized name of the category.&#10; *   - &quot;weight&quot;: An integer specifying the category's sort ordering.&#10; *   - &quot;access callback&quot;: Name of the access callback function to use to&#10; *     determine whether the user can edit the category. Defaults to using&#10; *     user_edit_access(). See hook_menu() for more information on access&#10; *     callbacks.&#10; *   - &quot;access arguments&quot;: Arguments for the access callback function. Defaults&#10; *     to array(1).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_categories() {&#10;  return array(array(&#10;    'name' =&gt; 'account',&#10;    'title' =&gt; t('Account settings'),&#10;    'weight' =&gt; 1,&#10;  ));&#10;  $END$&#10;}" description="hook_user_categories" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_categories" value="/**&#10; * Implements hook_user_categories().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_categories() {&#10;  return array(array(&#10;    'name' =&gt; 'account',&#10;    'title' =&gt; t('Account settings'),&#10;    'weight' =&gt; 1,&#10;  ));&#10;  $END$&#10;}" description="hook_user_categories" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_presave" value="/**&#10; * Implements hook_user_presave().&#10; *&#10; * A user account is about to be created or updated.&#10; *&#10; * This hook is primarily intended for modules that want to store properties in&#10; * the serialized {users}.data column, which is automatically loaded whenever a&#10; * user account object is loaded, modules may add to $edit['data'] in order&#10; * to have their data serialized on save.&#10; *&#10; * @param $edit&#10; *   The array of form values submitted by the user.&#10; * @param $account&#10; *   The user object on which the operation is performed.&#10; * @param $category&#10; *   The active category of user information being edited.&#10; *&#10; * @see hook_user_insert()&#10; * @see hook_user_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_presave(&amp;$edit, $account, $category) {&#10;  // Make sure that our form value 'mymodule_foo' is stored as 'mymodule_bar'.&#10;  if (isset($edit['mymodule_foo'])) {&#10;    $edit['data']['my_module_foo'] = $edit['my_module_foo'];&#10;  }&#10;  $END$&#10;}" description="hook_user_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_presave" value="/**&#10; * Implements hook_user_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_presave(&amp;$edit, $account, $category) {&#10;  // Make sure that our form value 'mymodule_foo' is stored as 'mymodule_bar'.&#10;  if (isset($edit['mymodule_foo'])) {&#10;    $edit['data']['my_module_foo'] = $edit['my_module_foo'];&#10;  }&#10;  $END$&#10;}" description="hook_user_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_insert" value="/**&#10; * Implements hook_user_insert().&#10; *&#10; * A user account was created.&#10; *&#10; * The module should save its custom additions to the user object into the&#10; * database.&#10; *&#10; * @param $edit&#10; *   The array of form values submitted by the user.&#10; * @param $account&#10; *   The user object on which the operation is being performed.&#10; * @param $category&#10; *   The active category of user information being edited.&#10; *&#10; * @see hook_user_presave()&#10; * @see hook_user_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_insert(&amp;$edit, $account, $category) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'myfield' =&gt; $edit['myfield'],&#10;      'uid' =&gt; $account-&gt;uid,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_insert" value="/**&#10; * Implements hook_user_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_insert(&amp;$edit, $account, $category) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'myfield' =&gt; $edit['myfield'],&#10;      'uid' =&gt; $account-&gt;uid,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_update" value="/**&#10; * Implements hook_user_update().&#10; *&#10; * A user account was updated.&#10; *&#10; * Modules may use this hook to update their user data in a custom storage&#10; * after a user account has been updated.&#10; *&#10; * @param $edit&#10; *   The array of form values submitted by the user.&#10; * @param $account&#10; *   The user object on which the operation is performed.&#10; * @param $category&#10; *   The active category of user information being edited.&#10; *&#10; * @see hook_user_presave()&#10; * @see hook_user_insert()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_update(&amp;$edit, $account, $category) {&#10;  db_insert('user_changes')&#10;    -&gt;fields(array(&#10;      'uid' =&gt; $account-&gt;uid,&#10;      'changed' =&gt; time(),&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_update" value="/**&#10; * Implements hook_user_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_update(&amp;$edit, $account, $category) {&#10;  db_insert('user_changes')&#10;    -&gt;fields(array(&#10;      'uid' =&gt; $account-&gt;uid,&#10;      'changed' =&gt; time(),&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_login" value="/**&#10; * Implements hook_user_login().&#10; *&#10; * The user just logged in.&#10; *&#10; * @param $edit&#10; *   The array of form values submitted by the user.&#10; * @param $account&#10; *   The user object on which the operation was just performed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_login(&amp;$edit, $account) {&#10;  // If the user has a NULL time zone, notify them to set a time zone.&#10;  if (!$account-&gt;timezone &amp;&amp; variable_get('configurable_timezones', 1) &amp;&amp; variable_get('empty_timezone_message', 0)) {&#10;    drupal_set_message(t('Configure your &lt;a href=&quot;@user-edit&quot;&gt;account time zone setting&lt;/a&gt;.', array('@user-edit' =&gt; url(&quot;user/$account-&gt;uid/edit&quot;, array('query' =&gt; drupal_get_destination(), 'fragment' =&gt; 'edit-timezone')))));&#10;  }&#10;  $END$&#10;}" description="hook_user_login" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_login" value="/**&#10; * Implements hook_user_login().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_login(&amp;$edit, $account) {&#10;  // If the user has a NULL time zone, notify them to set a time zone.&#10;  if (!$account-&gt;timezone &amp;&amp; variable_get('configurable_timezones', 1) &amp;&amp; variable_get('empty_timezone_message', 0)) {&#10;    drupal_set_message(t('Configure your &lt;a href=&quot;@user-edit&quot;&gt;account time zone setting&lt;/a&gt;.', array('@user-edit' =&gt; url(&quot;user/$account-&gt;uid/edit&quot;, array('query' =&gt; drupal_get_destination(), 'fragment' =&gt; 'edit-timezone')))));&#10;  }&#10;  $END$&#10;}" description="hook_user_login" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_logout" value="/**&#10; * Implements hook_user_logout().&#10; *&#10; * The user just logged out.&#10; *&#10; * @param $account&#10; *   The user object on which the operation was just performed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_logout($account) {&#10;  db_insert('logouts')&#10;    -&gt;fields(array(&#10;      'uid' =&gt; $account-&gt;uid,&#10;      'time' =&gt; time(),&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_logout" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_logout" value="/**&#10; * Implements hook_user_logout().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_logout($account) {&#10;  db_insert('logouts')&#10;    -&gt;fields(array(&#10;      'uid' =&gt; $account-&gt;uid,&#10;      'time' =&gt; time(),&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_logout" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_view" value="/**&#10; * Implements hook_user_view().&#10; *&#10; * The user's account information is being displayed.&#10; *&#10; * The module should format its custom additions for display and add them to the&#10; * $account-&gt;content array.&#10; *&#10; * @param $account&#10; *   The user object on which the operation is being performed.&#10; * @param $view_mode&#10; *   View mode, e.g. 'full'.&#10; * @param $langcode&#10; *   The language code used for rendering.&#10; *&#10; * @see hook_user_view_alter()&#10; * @see hook_entity_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_view($account, $view_mode, $langcode) {&#10;  if (user_access('create blog content', $account)) {&#10;    $account-&gt;content['summary']['blog'] =  array(&#10;      '#type' =&gt; 'user_profile_item',&#10;      '#title' =&gt; t('Blog'),&#10;      '#markup' =&gt; l(t('View recent blog entries'), &quot;blog/$account-&gt;uid&quot;, array('attributes' =&gt; array('title' =&gt; t(&quot;Read !username's latest blog entries.&quot;, array('!username' =&gt; format_username($account)))))),&#10;      '#attributes' =&gt; array('class' =&gt; array('blog')),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_user_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_view" value="/**&#10; * Implements hook_user_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_view($account, $view_mode, $langcode) {&#10;  if (user_access('create blog content', $account)) {&#10;    $account-&gt;content['summary']['blog'] =  array(&#10;      '#type' =&gt; 'user_profile_item',&#10;      '#title' =&gt; t('Blog'),&#10;      '#markup' =&gt; l(t('View recent blog entries'), &quot;blog/$account-&gt;uid&quot;, array('attributes' =&gt; array('title' =&gt; t(&quot;Read !username's latest blog entries.&quot;, array('!username' =&gt; format_username($account)))))),&#10;      '#attributes' =&gt; array('class' =&gt; array('blog')),&#10;    );&#10;  }&#10;  $END$&#10;}" description="hook_user_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_view_alter" value="/**&#10; * Implements hook_user_view_alter().&#10; *&#10; * The user was built; the module may modify the structured content.&#10; *&#10; * This hook is called after the content has been assembled in a structured array&#10; * and may be used for doing processing which requires that the complete user&#10; * content structure has been built.&#10; *&#10; * If the module wishes to act on the rendered HTML of the user rather than the&#10; * structured content array, it may use this hook to add a #post_render callback.&#10; * Alternatively, it could also implement hook_preprocess_user_profile(). See&#10; * drupal_render() and theme() documentation respectively for details.&#10; *&#10; * @param $build&#10; *   A renderable array representing the user.&#10; *&#10; * @see user_view()&#10; * @see hook_entity_view_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_view_alter(&amp;$build) {&#10;  // Check for the existence of a field added by another module.&#10;  if (isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the user.&#10;  $build['#post_render'][] = 'my_module_user_post_render';&#10;  $END$&#10;}" description="hook_user_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_view_alter" value="/**&#10; * Implements hook_user_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_view_alter(&amp;$build) {&#10;  // Check for the existence of a field added by another module.&#10;  if (isset($build['an_additional_field'])) {&#10;    // Change its weight.&#10;    $build['an_additional_field']['#weight'] = -10;&#10;  }&#10;&#10;  // Add a #post_render callback to act on the rendered HTML of the user.&#10;  $build['#post_render'][] = 'my_module_user_post_render';&#10;  $END$&#10;}" description="hook_user_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_role_presave" value="/**&#10; * Implements hook_user_role_presave().&#10; *&#10; * Inform other modules that a user role is about to be saved.&#10; *&#10; * Modules implementing this hook can act on the user role object before&#10; * it has been saved to the database.&#10; *&#10; * @param $role&#10; *   A user role object.&#10; *&#10; * @see hook_user_role_insert()&#10; * @see hook_user_role_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_presave($role) {&#10;  // Set a UUID for the user role if it doesn't already exist&#10;  if (empty($role-&gt;uuid)) {&#10;    $role-&gt;uuid = uuid_uuid();&#10;  }&#10;  $END$&#10;}" description="hook_user_role_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_role_presave" value="/**&#10; * Implements hook_user_role_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_presave($role) {&#10;  // Set a UUID for the user role if it doesn't already exist&#10;  if (empty($role-&gt;uuid)) {&#10;    $role-&gt;uuid = uuid_uuid();&#10;  }&#10;  $END$&#10;}" description="hook_user_role_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_role_insert" value="/**&#10; * Implements hook_user_role_insert().&#10; *&#10; * Inform other modules that a user role has been added.&#10; *&#10; * Modules implementing this hook can act on the user role object when saved to&#10; * the database. It's recommended that you implement this hook if your module&#10; * adds additional data to user roles object. The module should save its custom&#10; * additions to the database.&#10; *&#10; * @param $role&#10; *   A user role object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_insert($role) {&#10;  // Save extra fields provided by the module to user roles.&#10;  db_insert('my_module_table')&#10;    -&gt;fields(array(&#10;      'rid' =&gt; $role-&gt;rid,&#10;      'role_description' =&gt; $role-&gt;description,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_role_insert" value="/**&#10; * Implements hook_user_role_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_insert($role) {&#10;  // Save extra fields provided by the module to user roles.&#10;  db_insert('my_module_table')&#10;    -&gt;fields(array(&#10;      'rid' =&gt; $role-&gt;rid,&#10;      'role_description' =&gt; $role-&gt;description,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_role_update" value="/**&#10; * Implements hook_user_role_update().&#10; *&#10; * Inform other modules that a user role has been updated.&#10; *&#10; * Modules implementing this hook can act on the user role object when updated.&#10; * It's recommended that you implement this hook if your module adds additional&#10; * data to user roles object. The module should save its custom additions to&#10; * the database.&#10; *&#10; * @param $role&#10; *   A user role object.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_update($role) {&#10;  // Save extra fields provided by the module to user roles.&#10;  db_merge('my_module_table')&#10;    -&gt;key(array('rid' =&gt; $role-&gt;rid))&#10;    -&gt;fields(array(&#10;      'role_description' =&gt; $role-&gt;description&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_role_update" value="/**&#10; * Implements hook_user_role_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_update($role) {&#10;  // Save extra fields provided by the module to user roles.&#10;  db_merge('my_module_table')&#10;    -&gt;key(array('rid' =&gt; $role-&gt;rid))&#10;    -&gt;fields(array(&#10;      'role_description' =&gt; $role-&gt;description&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_role_delete" value="/**&#10; * Implements hook_user_role_delete().&#10; *&#10; * Inform other modules that a user role has been deleted.&#10; *&#10; * This hook allows you act when a user role has been deleted.&#10; * If your module stores references to roles, it's recommended that you&#10; * implement this hook and delete existing instances of the deleted role&#10; * in your module database tables.&#10; *&#10; * @param $role&#10; *   The $role object being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_delete($role) {&#10;  // Delete existing instances of the deleted role.&#10;  db_delete('my_module_table')&#10;    -&gt;condition('rid', $role-&gt;rid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_role_delete" value="/**&#10; * Implements hook_user_role_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_role_delete($role) {&#10;  // Delete existing instances of the deleted role.&#10;  db_delete('my_module_table')&#10;    -&gt;condition('rid', $role-&gt;rid)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_user_role_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rdf_mapping" value="/**&#10; * Implements hook_rdf_mapping().&#10; *&#10; * Allow modules to define RDF mappings for field bundles.&#10; *&#10; * Modules defining their own field bundles can specify which RDF semantics&#10; * should be used to annotate these bundles. These mappings are then used for&#10; * automatic RDFa output in the HTML code.&#10; *&#10; * @return&#10; *   A list of mapping structures, where each mapping is an associative array:&#10; *   - type: The name of an entity type (e.g., 'node', 'comment', and so on.)&#10; *   - bundle: The name of the bundle (e.g., 'page', 'blog', or&#10; *     RDF_DEFAULT_BUNDLE for default mappings.)&#10; *   - mapping: The mapping structure which applies to the entity type and&#10; *     bundle. A mapping structure is an array with keys corresponding to&#10; *     existing field instances in the bundle. Each field is then described in&#10; *     terms of the RDF mapping:&#10; *     - predicates: An array of RDF predicates which describe the relation&#10; *       between the bundle (RDF subject) and the value of the field (RDF&#10; *       object). This value is either some text, another bundle, or a URI in&#10; *       general.&#10; *     - datatype: Is used along with 'callback' to format data so that it is&#10; *       readable by machines. A typical example is a date which can be written&#10; *       in many different formats but should be translated into a uniform&#10; *       format for machine consumption.&#10; *     - callback: A function name to invoke for 'datatype'.&#10; *     - type: A string used to determine the type of RDFa markup which will be&#10; *       used in the final HTML output, depending on whether the RDF object is a&#10; *       literal text or another RDF resource.&#10; *     - rdftype: A special property used to define the type of the instance.&#10; *       Its value should be an array of RDF classes.&#10; *&#10; *       @ingroup rdf&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rdf_mapping() {&#10;  return array(&#10;    array(&#10;      'type' =&gt; 'node',&#10;      'bundle' =&gt; 'blog',&#10;      'mapping' =&gt; array(&#10;        'rdftype' =&gt; array('sioct:Weblog'),&#10;        'title' =&gt; array(&#10;          'predicates' =&gt; array('dc:title'),&#10;        ),&#10;        'created' =&gt; array(&#10;          'predicates' =&gt; array('dc:date', 'dc:created'),&#10;          'datatype' =&gt; 'xsd:dateTime',&#10;          'callback' =&gt; 'date_iso8601',&#10;        ),&#10;        'body' =&gt; array(&#10;          'predicates' =&gt; array('content:encoded'),&#10;        ),&#10;        'uid' =&gt; array(&#10;          'predicates' =&gt; array('sioc:has_creator'),&#10;          'type' =&gt; 'rel',&#10;        ),&#10;        'name' =&gt; array(&#10;          'predicates' =&gt; array('foaf:name'),&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rdf_mapping" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rdf_mapping" value="/**&#10; * Implements hook_rdf_mapping().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rdf_mapping() {&#10;  return array(&#10;    array(&#10;      'type' =&gt; 'node',&#10;      'bundle' =&gt; 'blog',&#10;      'mapping' =&gt; array(&#10;        'rdftype' =&gt; array('sioct:Weblog'),&#10;        'title' =&gt; array(&#10;          'predicates' =&gt; array('dc:title'),&#10;        ),&#10;        'created' =&gt; array(&#10;          'predicates' =&gt; array('dc:date', 'dc:created'),&#10;          'datatype' =&gt; 'xsd:dateTime',&#10;          'callback' =&gt; 'date_iso8601',&#10;        ),&#10;        'body' =&gt; array(&#10;          'predicates' =&gt; array('content:encoded'),&#10;        ),&#10;        'uid' =&gt; array(&#10;          'predicates' =&gt; array('sioc:has_creator'),&#10;          'type' =&gt; 'rel',&#10;        ),&#10;        'name' =&gt; array(&#10;          'predicates' =&gt; array('foaf:name'),&#10;        ),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rdf_mapping" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rdf_namespaces" value="/**&#10; * Implements hook_rdf_namespaces().&#10; *&#10; * Allow modules to define namespaces for RDF mappings.&#10; *&#10; * Many common namespace prefixes are defined in rdf_rdf_namespaces(). However,&#10; * if a module implements hook_rdf_mapping() and uses a prefix that is not&#10; * defined in rdf_rdf_namespaces(), this hook should be used to define the new&#10; * namespace prefix.&#10; *&#10; * @return&#10; *   An associative array of namespaces where the key is the namespace prefix&#10; *   and the value is the namespace URI.&#10; *&#10; * @ingroup rdf&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rdf_namespaces() {&#10;  return array(&#10;    'content'  =&gt; 'http://purl.org/rss/1.0/modules/content/',&#10;    'dc'       =&gt; 'http://purl.org/dc/terms/',&#10;    'foaf'     =&gt; 'http://xmlns.com/foaf/0.1/',&#10;    'og'       =&gt; 'http://ogp.me/ns#',&#10;    'rdfs'     =&gt; 'http://www.w3.org/2000/01/rdf-schema#',&#10;    'sioc'     =&gt; 'http://rdfs.org/sioc/ns#',&#10;    'sioct'    =&gt; 'http://rdfs.org/sioc/types#',&#10;    'skos'     =&gt; 'http://www.w3.org/2004/02/skos/core#',&#10;    'xsd'      =&gt; 'http://www.w3.org/2001/XMLSchema#',&#10;  );&#10;  $END$&#10;}" description="hook_rdf_namespaces" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rdf_namespaces" value="/**&#10; * Implements hook_rdf_namespaces().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rdf_namespaces() {&#10;  return array(&#10;    'content'  =&gt; 'http://purl.org/rss/1.0/modules/content/',&#10;    'dc'       =&gt; 'http://purl.org/dc/terms/',&#10;    'foaf'     =&gt; 'http://xmlns.com/foaf/0.1/',&#10;    'og'       =&gt; 'http://ogp.me/ns#',&#10;    'rdfs'     =&gt; 'http://www.w3.org/2000/01/rdf-schema#',&#10;    'sioc'     =&gt; 'http://rdfs.org/sioc/ns#',&#10;    'sioct'    =&gt; 'http://rdfs.org/sioc/types#',&#10;    'skos'     =&gt; 'http://www.w3.org/2004/02/skos/core#',&#10;    'xsd'      =&gt; 'http://www.w3.org/2001/XMLSchema#',&#10;  );&#10;  $END$&#10;}" description="hook_rdf_namespaces" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_overlay_parent_initialize" value="/**&#10; * Implements hook_overlay_parent_initialize().&#10; *&#10; * Allow modules to act when an overlay parent window is initialized.&#10; *&#10; * The parent window is initialized when a page is displayed in which the&#10; * overlay might be required to be displayed, so modules can act here if they&#10; * need to take action to accommodate the possibility of the overlay appearing&#10; * within a Drupal page.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_overlay_parent_initialize() {&#10;  // Add our custom JavaScript.&#10;  drupal_add_js(drupal_get_path('module', 'hook') . '/hook-overlay.js');&#10;  $END$&#10;}" description="hook_overlay_parent_initialize" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_overlay_parent_initialize" value="/**&#10; * Implements hook_overlay_parent_initialize().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_overlay_parent_initialize() {&#10;  // Add our custom JavaScript.&#10;  drupal_add_js(drupal_get_path('module', 'hook') . '/hook-overlay.js');&#10;  $END$&#10;}" description="hook_overlay_parent_initialize" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_overlay_child_initialize" value="/**&#10; * Implements hook_overlay_child_initialize().&#10; *&#10; * Allow modules to act when an overlay child window is initialized.&#10; *&#10; * The child window is initialized when a page is displayed from within the&#10; * overlay, so modules can act here if they need to take action to work from&#10; * within the confines of the overlay.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_overlay_child_initialize() {&#10;  // Add our custom JavaScript.&#10;  drupal_add_js(drupal_get_path('module', 'hook') . '/hook-overlay-child.js');&#10;  $END$&#10;}" description="hook_overlay_child_initialize" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_overlay_child_initialize" value="/**&#10; * Implements hook_overlay_child_initialize().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_overlay_child_initialize() {&#10;  // Add our custom JavaScript.&#10;  drupal_add_js(drupal_get_path('module', 'hook') . '/hook-overlay-child.js');&#10;  $END$&#10;}" description="hook_overlay_child_initialize" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_settings_form" value="/**&#10; * Implements hook_field_settings_form().&#10; *&#10; * Add settings to a field settings form.&#10; *&#10; * Invoked from field_ui_field_settings_form() to allow the module defining the&#10; * field to add global settings (i.e. settings that do not depend on the bundle&#10; * or instance) to the field settings form. If the field already has data, only&#10; * include settings that are safe to change.&#10; *&#10; * @todo: Only the field type module knows which settings will affect the&#10; * field's schema, but only the field storage module knows what schema&#10; * changes are permitted once a field already has data. Probably we need an&#10; * easy way for a field type module to ask whether an update to a new schema&#10; * will be allowed without having to build up a fake $prior_field structure&#10; * for hook_field_update_forbid().&#10; *&#10; * @param $field&#10; *   The field structure being configured.&#10; * @param $instance&#10; *   The instance structure being configured.&#10; * @param $has_data&#10; *   TRUE if the field already has data, FALSE if not.&#10; *&#10; * @return&#10; *   The form definition for the field settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_settings_form($field, $instance, $has_data) {&#10;  $settings = $field['settings'];&#10;  $form['max_length'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; t('Maximum length'),&#10;    '#default_value' =&gt; $settings['max_length'],&#10;    '#required' =&gt; FALSE,&#10;    '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;    '#description' =&gt; t('The maximum length of the field in characters. Leave blank for an unlimited size.'),&#10;  );&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_settings_form" value="/**&#10; * Implements hook_field_settings_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_settings_form($field, $instance, $has_data) {&#10;  $settings = $field['settings'];&#10;  $form['max_length'] = array(&#10;    '#type' =&gt; 'textfield',&#10;    '#title' =&gt; t('Maximum length'),&#10;    '#default_value' =&gt; $settings['max_length'],&#10;    '#required' =&gt; FALSE,&#10;    '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;    '#description' =&gt; t('The maximum length of the field in characters. Leave blank for an unlimited size.'),&#10;  );&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_instance_settings_form" value="/**&#10; * Implements hook_field_instance_settings_form().&#10; *&#10; * Add settings to an instance field settings form.&#10; *&#10; * Invoked from field_ui_field_edit_form() to allow the module defining the&#10; * field to add settings for a field instance.&#10; *&#10; * @param $field&#10; *   The field structure being configured.&#10; * @param $instance&#10; *   The instance structure being configured.&#10; *&#10; * @return&#10; *   The form definition for the field instance settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_instance_settings_form($field, $instance) {&#10;  $settings = $instance['settings'];&#10;&#10;  $form['text_processing'] = array(&#10;    '#type' =&gt; 'radios',&#10;    '#title' =&gt; t('Text processing'),&#10;    '#default_value' =&gt; $settings['text_processing'],&#10;    '#options' =&gt; array(&#10;      t('Plain text'),&#10;      t('Filtered text (user selects text format)'),&#10;    ),&#10;  );&#10;  if ($field['type'] == 'text_with_summary') {&#10;    $form['display_summary'] = array(&#10;      '#type' =&gt; 'select',&#10;      '#title' =&gt; t('Display summary'),&#10;      '#options' =&gt; array(&#10;        t('No'),&#10;        t('Yes'),&#10;      ),&#10;      '#description' =&gt; t('Display the summary to allow the user to input a summary value. Hide the summary to automatically fill it with a trimmed portion from the main post.'),&#10;      '#default_value' =&gt; !empty($settings['display_summary']) ? $settings['display_summary'] :  0,&#10;    );&#10;  }&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_instance_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_instance_settings_form" value="/**&#10; * Implements hook_field_instance_settings_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_instance_settings_form($field, $instance) {&#10;  $settings = $instance['settings'];&#10;&#10;  $form['text_processing'] = array(&#10;    '#type' =&gt; 'radios',&#10;    '#title' =&gt; t('Text processing'),&#10;    '#default_value' =&gt; $settings['text_processing'],&#10;    '#options' =&gt; array(&#10;      t('Plain text'),&#10;      t('Filtered text (user selects text format)'),&#10;    ),&#10;  );&#10;  if ($field['type'] == 'text_with_summary') {&#10;    $form['display_summary'] = array(&#10;      '#type' =&gt; 'select',&#10;      '#title' =&gt; t('Display summary'),&#10;      '#options' =&gt; array(&#10;        t('No'),&#10;        t('Yes'),&#10;      ),&#10;      '#description' =&gt; t('Display the summary to allow the user to input a summary value. Hide the summary to automatically fill it with a trimmed portion from the main post.'),&#10;      '#default_value' =&gt; !empty($settings['display_summary']) ? $settings['display_summary'] :  0,&#10;    );&#10;  }&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_instance_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_widget_settings_form" value="/**&#10; * Implements hook_field_widget_settings_form().&#10; *&#10; * Add settings to a widget settings form.&#10; *&#10; * Invoked from field_ui_field_edit_form() to allow the module defining the&#10; * widget to add settings for a widget instance.&#10; *&#10; * @param $field&#10; *   The field structure being configured.&#10; * @param $instance&#10; *   The instance structure being configured.&#10; *&#10; * @return&#10; *   The form definition for the widget settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_settings_form($field, $instance) {&#10;  $widget = $instance['widget'];&#10;  $settings = $widget['settings'];&#10;&#10;  if ($widget['type'] == 'text_textfield') {&#10;    $form['size'] = array(&#10;      '#type' =&gt; 'textfield',&#10;      '#title' =&gt; t('Size of textfield'),&#10;      '#default_value' =&gt; $settings['size'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;  else {&#10;    $form['rows'] = array(&#10;      '#type' =&gt; 'textfield',&#10;      '#title' =&gt; t('Rows'),&#10;      '#default_value' =&gt; $settings['rows'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_widget_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_widget_settings_form" value="/**&#10; * Implements hook_field_widget_settings_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_widget_settings_form($field, $instance) {&#10;  $widget = $instance['widget'];&#10;  $settings = $widget['settings'];&#10;&#10;  if ($widget['type'] == 'text_textfield') {&#10;    $form['size'] = array(&#10;      '#type' =&gt; 'textfield',&#10;      '#title' =&gt; t('Size of textfield'),&#10;      '#default_value' =&gt; $settings['size'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;  else {&#10;    $form['rows'] = array(&#10;      '#type' =&gt; 'textfield',&#10;      '#title' =&gt; t('Rows'),&#10;      '#default_value' =&gt; $settings['rows'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;&#10;  return $form;&#10;  $END$&#10;}" description="hook_field_widget_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_settings_form" value="/**&#10; * Implements hook_field_formatter_settings_form().&#10; *&#10; * Returns form elements for a formatter's settings.&#10; *&#10; * @param $field&#10; *   The field structure being configured.&#10; * @param $instance&#10; *   The instance structure being configured.&#10; * @param $view_mode&#10; *   The view mode being configured.&#10; * @param $form&#10; *   The (entire) configuration form array, which will usually have no use here.&#10; * @param $form_state&#10; *   The form state of the (entire) configuration form.&#10; *&#10; * @return&#10; *   The form elements for the formatter settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_settings_form($field, $instance, $view_mode, $form, &amp;$form_state) {&#10;  $display = $instance['display'][$view_mode];&#10;  $settings = $display['settings'];&#10;&#10;  $element = array();&#10;&#10;  if ($display['type'] == 'text_trimmed' || $display['type'] == 'text_summary_or_trimmed') {&#10;    $element['trim_length'] = array(&#10;      '#title' =&gt; t('Length'),&#10;      '#type' =&gt; 'textfield',&#10;      '#size' =&gt; 20,&#10;      '#default_value' =&gt; $settings['trim_length'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;&#10;  return $element;&#10;&#10;  $END$&#10;}" description="hook_field_formatter_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_settings_form" value="/**&#10; * Implements hook_field_formatter_settings_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_settings_form($field, $instance, $view_mode, $form, &amp;$form_state) {&#10;  $display = $instance['display'][$view_mode];&#10;  $settings = $display['settings'];&#10;&#10;  $element = array();&#10;&#10;  if ($display['type'] == 'text_trimmed' || $display['type'] == 'text_summary_or_trimmed') {&#10;    $element['trim_length'] = array(&#10;      '#title' =&gt; t('Length'),&#10;      '#type' =&gt; 'textfield',&#10;      '#size' =&gt; 20,&#10;      '#default_value' =&gt; $settings['trim_length'],&#10;      '#element_validate' =&gt; array('element_validate_integer_positive'),&#10;      '#required' =&gt; TRUE,&#10;    );&#10;  }&#10;&#10;  return $element;&#10;&#10;  $END$&#10;}" description="hook_field_formatter_settings_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_field_formatter_settings_summary" value="/**&#10; * Implements hook_field_formatter_settings_summary().&#10; *&#10; * Returns a short summary for the current formatter settings of an instance.&#10; *&#10; * If an empty result is returned, the formatter is assumed to have no&#10; * configurable settings, and no UI will be provided to display a settings&#10; * form.&#10; *&#10; * @param $field&#10; *   The field structure.&#10; * @param $instance&#10; *   The instance structure.&#10; * @param $view_mode&#10; *   The view mode for which a settings summary is requested.&#10; *&#10; * @return&#10; *   A string containing a short summary of the formatter settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_settings_summary($field, $instance, $view_mode) {&#10;  $display = $instance['display'][$view_mode];&#10;  $settings = $display['settings'];&#10;&#10;  $summary = '';&#10;&#10;  if ($display['type'] == 'text_trimmed' || $display['type'] == 'text_summary_or_trimmed') {&#10;    $summary = t('Length: @chars chars', array('@chars' =&gt; $settings['trim_length']));&#10;  }&#10;&#10;  return $summary;&#10;  $END$&#10;}" description="hook_field_formatter_settings_summary" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_field_formatter_settings_summary" value="/**&#10; * Implements hook_field_formatter_settings_summary().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_field_formatter_settings_summary($field, $instance, $view_mode) {&#10;  $display = $instance['display'][$view_mode];&#10;  $settings = $display['settings'];&#10;&#10;  $summary = '';&#10;&#10;  if ($display['type'] == 'text_trimmed' || $display['type'] == 'text_summary_or_trimmed') {&#10;    $summary = t('Length: @chars chars', array('@chars' =&gt; $settings['trim_length']));&#10;  }&#10;&#10;  return $summary;&#10;  $END$&#10;}" description="hook_field_formatter_settings_summary" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_locale" value="/**&#10; * Implements hook_locale().&#10; *&#10; * Allows modules to define their own text groups that can be translated.&#10; *&#10; * @param $op&#10; *   Type of operation. Currently, only supports 'groups'.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_locale($op = 'groups') {&#10;  switch ($op) {&#10;    case 'groups':&#10;      return array('custom' =&gt; t('Custom'));&#10;  }&#10;  $END$&#10;}" description="hook_locale" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_locale" value="/**&#10; * Implements hook_locale().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_locale($op = 'groups') {&#10;  switch ($op) {&#10;    case 'groups':&#10;      return array('custom' =&gt; t('Custom'));&#10;  }&#10;  $END$&#10;}" description="hook_locale" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_init" value="/**&#10; * Implements hook_language_init().&#10; *&#10; * Allows modules to act after language initialization has been performed.&#10; *&#10; * This is primarily needed to provide translation for configuration variables&#10; * in the proper bootstrap phase. Variables are user-defined strings and&#10; * therefore should not be translated via t(), since the source string can&#10; * change without notice and any previous translation would be lost. Moreover,&#10; * since variables can be used in the bootstrap phase, we need a bootstrap hook&#10; * to provide a translation early enough to avoid misalignments between code&#10; * using the original values and code using the translated values. However&#10; * modules implementing hook_boot() should be aware that language initialization&#10; * did not happen yet and thus they cannot rely on translated variables.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_init() {&#10;  global $language, $conf;&#10;&#10;  switch ($language-&gt;language) {&#10;    case 'it':&#10;      $conf['site_name'] = 'Il mio sito Drupal';&#10;      break;&#10;&#10;    case 'fr':&#10;      $conf['site_name'] = 'Mon site Drupal';&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_language_init" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_init" value="/**&#10; * Implements hook_language_init().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_init() {&#10;  global $language, $conf;&#10;&#10;  switch ($language-&gt;language) {&#10;    case 'it':&#10;      $conf['site_name'] = 'Il mio sito Drupal';&#10;      break;&#10;&#10;    case 'fr':&#10;      $conf['site_name'] = 'Mon site Drupal';&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_language_init" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_switch_links_alter" value="/**&#10; * Implements hook_language_switch_links_alter().&#10; *&#10; * Perform alterations on language switcher links.&#10; *&#10; * A language switcher link may need to point to a different path or use a&#10; * translated link text before going through l(), which will just handle the&#10; * path aliases.&#10; *&#10; * @param $links&#10; *   Nested array of links keyed by language code.&#10; * @param $type&#10; *   The language type the links will switch.&#10; * @param $path&#10; *   The current path.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_switch_links_alter(array &amp;$links, $type, $path) {&#10;  global $language;&#10;&#10;  if ($type == LANGUAGE_TYPE_CONTENT &amp;&amp; isset($links[$language-&gt;language])) {&#10;    foreach ($links[$language-&gt;language] as $link) {&#10;      $link['attributes']['class'][] = 'active-language';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_language_switch_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_switch_links_alter" value="/**&#10; * Implements hook_language_switch_links_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_switch_links_alter(array &amp;$links, $type, $path) {&#10;  global $language;&#10;&#10;  if ($type == LANGUAGE_TYPE_CONTENT &amp;&amp; isset($links[$language-&gt;language])) {&#10;    foreach ($links[$language-&gt;language] as $link) {&#10;      $link['attributes']['class'][] = 'active-language';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_language_switch_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_types_info" value="/**&#10; * Implements hook_language_types_info().&#10; *&#10; * Allow modules to define their own language types.&#10; *&#10; * @return&#10; *   An array of language type definitions. Each language type has an identifier&#10; *   key. The language type definition is an associative array that may contain&#10; *   the following key-value pairs:&#10; *   - &quot;name&quot;: The human-readable language type identifier.&#10; *   - &quot;description&quot;: A description of the language type.&#10; *   - &quot;fixed&quot;: An array of language provider identifiers. Defining this key&#10; *     makes the language type non-configurable.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_types_info() {&#10;  return array(&#10;    'custom_language_type' =&gt; array(&#10;      'name' =&gt; t('Custom language'),&#10;      'description' =&gt; t('A custom language type.'),&#10;    ),&#10;    'fixed_custom_language_type' =&gt; array(&#10;      'fixed' =&gt; array('custom_language_provider'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_language_types_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_types_info" value="/**&#10; * Implements hook_language_types_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_types_info() {&#10;  return array(&#10;    'custom_language_type' =&gt; array(&#10;      'name' =&gt; t('Custom language'),&#10;      'description' =&gt; t('A custom language type.'),&#10;    ),&#10;    'fixed_custom_language_type' =&gt; array(&#10;      'fixed' =&gt; array('custom_language_provider'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_language_types_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_types_info_alter" value="/**&#10; * Implements hook_language_types_info_alter().&#10; *&#10; * Perform alterations on language types.&#10; *&#10; * @param $language_types&#10; *   Array of language type definitions.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_types_info_alter(array &amp;$language_types) {&#10;  if (isset($language_types['custom_language_type'])) {&#10;    $language_types['custom_language_type_custom']['description'] = t('A far better description.');&#10;  }&#10;  $END$&#10;}" description="hook_language_types_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_types_info_alter" value="/**&#10; * Implements hook_language_types_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_types_info_alter(array &amp;$language_types) {&#10;  if (isset($language_types['custom_language_type'])) {&#10;    $language_types['custom_language_type_custom']['description'] = t('A far better description.');&#10;  }&#10;  $END$&#10;}" description="hook_language_types_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_negotiation_info" value="/**&#10; * Implements hook_language_negotiation_info().&#10; *&#10; * Allow modules to define their own language providers.&#10; *&#10; * @return&#10; *   An array of language provider definitions. Each language provider has an&#10; *   identifier key. The language provider definition is an associative array&#10; *   that may contain the following key-value pairs:&#10; *   - &quot;types&quot;: An array of allowed language types. If a language provider does&#10; *     not specify which language types it should be used with, it will be&#10; *     available for all the configurable language types.&#10; *   - &quot;callbacks&quot;: An array of functions that will be called to perform various&#10; *     tasks. Possible key-value pairs are:&#10; *     - &quot;language&quot;: Required. The callback that will determine the language&#10; *       value.&#10; *     - &quot;switcher&quot;: The callback that will determine the language switch links&#10; *       associated to the current language provider.&#10; *     - &quot;url_rewrite&quot;: The callback that will provide URL rewriting.&#10; *   - &quot;file&quot;: A file that will be included before the callback is invoked; this&#10; *     allows callback functions to be in separate files.&#10; *   - &quot;weight&quot;: The default weight the language provider has.&#10; *   - &quot;name&quot;: A human-readable identifier.&#10; *   - &quot;description&quot;: A description of the language provider.&#10; *   - &quot;config&quot;: An internal path pointing to the language provider&#10; *     configuration page.&#10; *   - &quot;cache&quot;: The value Drupal's page cache should be set to for the current&#10; *     language provider to be invoked.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_negotiation_info() {&#10;  return array(&#10;    'custom_language_provider' =&gt; array(&#10;      'callbacks' =&gt; array(&#10;        'language' =&gt; 'custom_language_provider_callback',&#10;        'switcher' =&gt; 'custom_language_switcher_callback',&#10;        'url_rewrite' =&gt; 'custom_language_url_rewrite_callback',&#10;      ),&#10;      'file' =&gt; drupal_get_path('module', 'custom') . '/custom.module',&#10;      'weight' =&gt; -4,&#10;      'types' =&gt; array('custom_language_type'),&#10;      'name' =&gt; t('Custom language provider'),&#10;      'description' =&gt; t('This is a custom language provider.'),&#10;      'cache' =&gt; 0,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_language_negotiation_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_negotiation_info" value="/**&#10; * Implements hook_language_negotiation_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_negotiation_info() {&#10;  return array(&#10;    'custom_language_provider' =&gt; array(&#10;      'callbacks' =&gt; array(&#10;        'language' =&gt; 'custom_language_provider_callback',&#10;        'switcher' =&gt; 'custom_language_switcher_callback',&#10;        'url_rewrite' =&gt; 'custom_language_url_rewrite_callback',&#10;      ),&#10;      'file' =&gt; drupal_get_path('module', 'custom') . '/custom.module',&#10;      'weight' =&gt; -4,&#10;      'types' =&gt; array('custom_language_type'),&#10;      'name' =&gt; t('Custom language provider'),&#10;      'description' =&gt; t('This is a custom language provider.'),&#10;      'cache' =&gt; 0,&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_language_negotiation_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_negotiation_info_alter" value="/**&#10; * Implements hook_language_negotiation_info_alter().&#10; *&#10; * Perform alterations on language providers.&#10; *&#10; * @param $language_providers&#10; *   Array of language provider definitions.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_negotiation_info_alter(array &amp;$language_providers) {&#10;  if (isset($language_providers['custom_language_provider'])) {&#10;    $language_providers['custom_language_provider']['config'] = 'admin/config/regional/language/configure/custom-language-provider';&#10;  }&#10;  $END$&#10;}" description="hook_language_negotiation_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_negotiation_info_alter" value="/**&#10; * Implements hook_language_negotiation_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_negotiation_info_alter(array &amp;$language_providers) {&#10;  if (isset($language_providers['custom_language_provider'])) {&#10;    $language_providers['custom_language_provider']['config'] = 'admin/config/regional/language/configure/custom-language-provider';&#10;  }&#10;  $END$&#10;}" description="hook_language_negotiation_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_multilingual_settings_changed" value="/**&#10; * Implements hook_multilingual_settings_changed().&#10; *&#10; * Allow modules to react to language settings changes.&#10; *&#10; * Every module needing to act when the number of enabled languages changes&#10; * should implement this. This is an &quot;internal&quot; hook and should not be invoked&#10; * elsewhere. The typical implementation would trigger some kind of rebuilding,&#10; * this way system components could properly react to the change of the enabled&#10; * languages number.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_multilingual_settings_changed() {&#10;  field_info_cache_clear();&#10;  $END$&#10;}" description="hook_multilingual_settings_changed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_multilingual_settings_changed" value="/**&#10; * Implements hook_multilingual_settings_changed().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_multilingual_settings_changed() {&#10;  field_info_cache_clear();&#10;  $END$&#10;}" description="hook_multilingual_settings_changed" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_language_fallback_candidates_alter" value="/**&#10; * Implements hook_language_fallback_candidates_alter().&#10; *&#10; * Perform alterations on the language fallback candidates.&#10; *&#10; * @param $fallback_candidates&#10; *   An array of language codes whose order will determine the language fallback&#10; *   order.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_fallback_candidates_alter(array &amp;$fallback_candidates) {&#10;  $fallback_candidates = array_reverse($fallback_candidates);&#10;  $END$&#10;}" description="hook_language_fallback_candidates_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_language_fallback_candidates_alter" value="/**&#10; * Implements hook_language_fallback_candidates_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_language_fallback_candidates_alter(array &amp;$fallback_candidates) {&#10;  $fallback_candidates = array_reverse($fallback_candidates);&#10;  $END$&#10;}" description="hook_language_fallback_candidates_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_info" value="/**&#10; * Implements hook_filter_info().&#10; *&#10; * Define content filters.&#10; *&#10; * User submitted content is passed through a group of filters before it is&#10; * output in HTML, in order to remove insecure or unwanted parts, correct or&#10; * enhance the formatting, transform special keywords, etc. A group of filters&#10; * is referred to as a &quot;text format&quot;. Administrators can create as many text&#10; * formats as needed. Individual filters can be enabled and configured&#10; * differently for each text format.&#10; *&#10; * This hook is invoked by filter_get_filters() and allows modules to register&#10; * input filters they provide.&#10; *&#10; * Filtering is a two-step process. First, the content is 'prepared' by calling&#10; * the 'prepare callback' function for every filter. The purpose of the 'prepare&#10; * callback' is to escape HTML-like structures. For example, imagine a filter&#10; * which allows the user to paste entire chunks of programming code without&#10; * requiring manual escaping of special HTML characters like &lt; or &amp;. If the&#10; * programming code were left untouched, then other filters could think it was&#10; * HTML and change it. For many filters, the prepare step is not necessary.&#10; *&#10; * The second step is the actual processing step. The result from passing the&#10; * text through all the filters' prepare steps gets passed to all the filters&#10; * again, this time with the 'process callback' function. The process callbacks&#10; * should then actually change the content: transform URLs into hyperlinks,&#10; * convert smileys into images, etc.&#10; *&#10; * For performance reasons content is only filtered once; the result is stored&#10; * in the cache table and retrieved from the cache the next time the same piece&#10; * of content is displayed. If a filter's output is dynamic, it can override the&#10; * cache mechanism, but obviously this should be used with caution: having one&#10; * filter that does not support caching in a particular text format disables&#10; * caching for the entire format, not just for one filter.&#10; *&#10; * Beware of the filter cache when developing your module: it is advised to set&#10; * your filter to 'cache' =&gt; FALSE while developing, but be sure to remove that&#10; * setting if it's not needed, when you are no longer in development mode.&#10; *&#10; * @return&#10; *   An associative array of filters, whose keys are internal filter names,&#10; *   which should be unique and therefore prefixed with the name of the module.&#10; *   Each value is an associative array describing the filter, with the&#10; *   following elements (all are optional except as noted):&#10; *   - title: (required) An administrative summary of what the filter does.&#10; *   - description: Additional administrative information about the filter's&#10; *     behavior, if needed for clarification.&#10; *   - settings callback: The name of a function that returns configuration form&#10; *     elements for the filter. See hook_filter_FILTER_settings() for details.&#10; *   - default settings: An associative array containing default settings for&#10; *     the filter, to be applied when the filter has not been configured yet.&#10; *   - prepare callback: The name of a function that escapes the content before&#10; *     the actual filtering happens. See hook_filter_FILTER_prepare() for&#10; *     details.&#10; *   - process callback: (required) The name the function that performs the&#10; *     actual filtering. See hook_filter_FILTER_process() for details.&#10; *   - cache (default TRUE): Specifies whether the filtered text can be cached.&#10; *     Note that setting this to FALSE makes the entire text format not&#10; *     cacheable, which may have an impact on the site's overall performance.&#10; *     See filter_format_allowcache() for details.&#10; *   - tips callback: The name of a function that returns end-user-facing filter&#10; *     usage guidelines for the filter. See hook_filter_FILTER_tips() for&#10; *     details.&#10; *   - weight: A default weight for the filter in new text formats.&#10; *&#10; * @see filter_example.module&#10; * @see hook_filter_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_info() {&#10;  $filters['filter_html'] = array(&#10;    'title' =&gt; t('Limit allowed HTML tags'),&#10;    'description' =&gt; t('Allows you to restrict the HTML tags the user can use. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.'),&#10;    'process callback' =&gt; '_filter_html',&#10;    'settings callback' =&gt; '_filter_html_settings',&#10;    'default settings' =&gt; array(&#10;      'allowed_html' =&gt; '&lt;a&gt; &lt;em&gt; &lt;strong&gt; &lt;cite&gt; &lt;blockquote&gt; &lt;code&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt;',&#10;      'filter_html_help' =&gt; 1,&#10;      'filter_html_nofollow' =&gt; 0,&#10;    ),&#10;    'tips callback' =&gt; '_filter_html_tips',&#10;  );&#10;  $filters['filter_autop'] = array(&#10;    'title' =&gt; t('Convert line breaks'),&#10;    'description' =&gt; t('Converts line breaks into HTML (i.e. &amp;lt;br&amp;gt; and &amp;lt;p&amp;gt;) tags.'),&#10;    'process callback' =&gt; '_filter_autop',&#10;    'tips callback' =&gt; '_filter_autop_tips',&#10;  );&#10;  return $filters;&#10;  $END$&#10;}" description="hook_filter_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_info" value="/**&#10; * Implements hook_filter_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_info() {&#10;  $filters['filter_html'] = array(&#10;    'title' =&gt; t('Limit allowed HTML tags'),&#10;    'description' =&gt; t('Allows you to restrict the HTML tags the user can use. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.'),&#10;    'process callback' =&gt; '_filter_html',&#10;    'settings callback' =&gt; '_filter_html_settings',&#10;    'default settings' =&gt; array(&#10;      'allowed_html' =&gt; '&lt;a&gt; &lt;em&gt; &lt;strong&gt; &lt;cite&gt; &lt;blockquote&gt; &lt;code&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt;',&#10;      'filter_html_help' =&gt; 1,&#10;      'filter_html_nofollow' =&gt; 0,&#10;    ),&#10;    'tips callback' =&gt; '_filter_html_tips',&#10;  );&#10;  $filters['filter_autop'] = array(&#10;    'title' =&gt; t('Convert line breaks'),&#10;    'description' =&gt; t('Converts line breaks into HTML (i.e. &amp;lt;br&amp;gt; and &amp;lt;p&amp;gt;) tags.'),&#10;    'process callback' =&gt; '_filter_autop',&#10;    'tips callback' =&gt; '_filter_autop_tips',&#10;  );&#10;  return $filters;&#10;  $END$&#10;}" description="hook_filter_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_info_alter" value="/**&#10; * Implements hook_filter_info_alter().&#10; *&#10; * Perform alterations on filter definitions.&#10; *&#10; * @param $info&#10; *   Array of information on filters exposed by hook_filter_info()&#10; *   implementations.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_info_alter(&amp;$info) {&#10;  // Replace the PHP evaluator process callback with an improved&#10;  // PHP evaluator provided by a module.&#10;  $info['php_code']['process callback'] = 'my_module_php_evaluator';&#10;&#10;  // Alter the default settings of the URL filter provided by core.&#10;  $info['filter_url']['default settings'] = array(&#10;    'filter_url_length' =&gt; 100,&#10;  );&#10;  $END$&#10;}" description="hook_filter_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_info_alter" value="/**&#10; * Implements hook_filter_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_info_alter(&amp;$info) {&#10;  // Replace the PHP evaluator process callback with an improved&#10;  // PHP evaluator provided by a module.&#10;  $info['php_code']['process callback'] = 'my_module_php_evaluator';&#10;&#10;  // Alter the default settings of the URL filter provided by core.&#10;  $info['filter_url']['default settings'] = array(&#10;    'filter_url_length' =&gt; 100,&#10;  );&#10;  $END$&#10;}" description="hook_filter_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_FILTER_settings" value="/**&#10; * Implements hook_filter_FILTER_settings().&#10; *&#10; * Settings callback for hook_filter_info().&#10; *&#10; * Note: This is not really a hook. The function name is manually specified via&#10; * 'settings callback' in hook_filter_info(), with this recommended callback&#10; * name pattern. It is called from filter_admin_format_form().&#10; *&#10; * This callback function is used to provide a settings form for filter&#10; * settings, for filters that need settings on a per-text-format basis. This&#10; * function should return the form elements for the settings; the filter&#10; * module will take care of saving the settings in the database.&#10; *&#10; * If the filter's behavior depends on an extensive list and/or external data&#10; * (e.g. a list of smileys, a list of glossary terms), then the filter module&#10; * can choose to provide a separate, global configuration page rather than&#10; * per-text-format settings. In that case, the settings callback function&#10; * should provide a link to the separate settings page.&#10; *&#10; * @param $form&#10; *   The prepopulated form array of the filter administration form.&#10; * @param $form_state&#10; *   The state of the (entire) configuration form.&#10; * @param $filter&#10; *   The filter object containing the current settings for the given format,&#10; *   in $filter-&gt;settings.&#10; * @param $format&#10; *   The format object being configured.&#10; * @param $defaults&#10; *   The default settings for the filter, as defined in 'default settings' in&#10; *   hook_filter_info(). These should be combined with $filter-&gt;settings to&#10; *   define the form element defaults.&#10; * @param $filters&#10; *   The complete list of filter objects that are enabled for the given format.&#10; *&#10; * @return&#10; *   An array of form elements defining settings for the filter. Array keys&#10; *   should match the array keys in $filter-&gt;settings and $defaults.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_settings($form, &amp;$form_state, $filter, $format, $defaults, $filters) {&#10;  $filter-&gt;settings += $defaults;&#10;&#10;  $elements = array();&#10;  $elements['nofollow'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t('Add rel=&quot;nofollow&quot; to all links'),&#10;    '#default_value' =&gt; $filter-&gt;settings['nofollow'],&#10;  );&#10;  return $elements;&#10;  $END$&#10;}" description="hook_filter_FILTER_settings" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_FILTER_settings" value="/**&#10; * Implements hook_filter_FILTER_settings().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_settings($form, &amp;$form_state, $filter, $format, $defaults, $filters) {&#10;  $filter-&gt;settings += $defaults;&#10;&#10;  $elements = array();&#10;  $elements['nofollow'] = array(&#10;    '#type' =&gt; 'checkbox',&#10;    '#title' =&gt; t('Add rel=&quot;nofollow&quot; to all links'),&#10;    '#default_value' =&gt; $filter-&gt;settings['nofollow'],&#10;  );&#10;  return $elements;&#10;  $END$&#10;}" description="hook_filter_FILTER_settings" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_FILTER_prepare" value="/**&#10; * Implements hook_filter_FILTER_prepare().&#10; *&#10; * Prepare callback for hook_filter_info().&#10; *&#10; * Note: This is not really a hook. The function name is manually specified via&#10; * 'prepare callback' in hook_filter_info(), with this recommended callback&#10; * name pattern. It is called from check_markup().&#10; *&#10; * See hook_filter_info() for a description of the filtering process. Filters&#10; * should not use the 'prepare callback' step for anything other than escaping,&#10; * because that would short-circuit the control the user has over the order in&#10; * which filters are applied.&#10; *&#10; * @param $text&#10; *   The text string to be filtered.&#10; * @param $filter&#10; *   The filter object containing settings for the given format.&#10; * @param $format&#10; *   The text format object assigned to the text to be filtered.&#10; * @param $langcode&#10; *   The language code of the text to be filtered.&#10; * @param $cache&#10; *   A Boolean indicating whether the filtered text is going to be cached in&#10; *   {cache_filter}.&#10; * @param $cache_id&#10; *   The ID of the filtered text in {cache_filter}, if $cache is TRUE.&#10; *&#10; * @return&#10; *   The prepared, escaped text.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {&#10;  // Escape &lt;code&gt; and &lt;/code&gt; tags.&#10;  $text = preg_replace('|&lt;code&gt;(.+?)&lt;/code&gt;|se', &quot;[codefilter_code]$1[/codefilter_code]&quot;, $text);&#10;  return $text;&#10;  $END$&#10;}" description="hook_filter_FILTER_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_FILTER_prepare" value="/**&#10; * Implements hook_filter_FILTER_prepare().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {&#10;  // Escape &lt;code&gt; and &lt;/code&gt; tags.&#10;  $text = preg_replace('|&lt;code&gt;(.+?)&lt;/code&gt;|se', &quot;[codefilter_code]$1[/codefilter_code]&quot;, $text);&#10;  return $text;&#10;  $END$&#10;}" description="hook_filter_FILTER_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_FILTER_process" value="/**&#10; * Implements hook_filter_FILTER_process().&#10; *&#10; * Process callback for hook_filter_info().&#10; *&#10; * Note: This is not really a hook. The function name is manually specified via&#10; * 'process callback' in hook_filter_info(), with this recommended callback&#10; * name pattern. It is called from check_markup().&#10; *&#10; * See hook_filter_info() for a description of the filtering process. This step&#10; * is where the filter actually transforms the text.&#10; *&#10; * @param $text&#10; *   The text string to be filtered.&#10; * @param $filter&#10; *   The filter object containing settings for the given format.&#10; * @param $format&#10; *   The text format object assigned to the text to be filtered.&#10; * @param $langcode&#10; *   The language code of the text to be filtered.&#10; * @param $cache&#10; *   A Boolean indicating whether the filtered text is going to be cached in&#10; *   {cache_filter}.&#10; * @param $cache_id&#10; *   The ID of the filtered text in {cache_filter}, if $cache is TRUE.&#10; *&#10; * @return&#10; *   The filtered text.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_process($text, $filter, $format, $langcode, $cache, $cache_id) {&#10;  $text = preg_replace('|\[codefilter_code\](.+?)\[/codefilter_code\]|se', &quot;&lt;pre&gt;$1&lt;/pre&gt;&quot;, $text);&#10;&#10;  return $text;&#10;  $END$&#10;}" description="hook_filter_FILTER_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_FILTER_process" value="/**&#10; * Implements hook_filter_FILTER_process().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_process($text, $filter, $format, $langcode, $cache, $cache_id) {&#10;  $text = preg_replace('|\[codefilter_code\](.+?)\[/codefilter_code\]|se', &quot;&lt;pre&gt;$1&lt;/pre&gt;&quot;, $text);&#10;&#10;  return $text;&#10;  $END$&#10;}" description="hook_filter_FILTER_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_FILTER_tips" value="/**&#10; * Implements hook_filter_FILTER_tips().&#10; *&#10; * Tips callback for hook_filter_info().&#10; *&#10; * Note: This is not really a hook. The function name is manually specified via&#10; * 'tips callback' in hook_filter_info(), with this recommended callback&#10; * name pattern. It is called from _filter_tips().&#10; *&#10; * A filter's tips should be informative and to the point. Short tips are&#10; * preferably one-liners.&#10; *&#10; * @param $filter&#10; *   An object representing the filter.&#10; * @param $format&#10; *   An object representing the text format the filter is contained in.&#10; * @param $long&#10; *   Whether this callback should return a short tip to display in a form&#10; *   (FALSE), or whether a more elaborate filter tips should be returned for&#10; *   theme_filter_tips() (TRUE).&#10; *&#10; * @return&#10; *   Translated text to display as a tip.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_tips($filter, $format, $long) {&#10; if ($long) {&#10;    return t('Lines and paragraphs are automatically recognized. The &amp;lt;br /&amp;gt; line break, &amp;lt;p&amp;gt; paragraph and &amp;lt;/p&amp;gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');&#10;  }&#10;  else {&#10;    return t('Lines and paragraphs break automatically.');&#10;  }&#10;  $END$&#10;}" description="hook_filter_FILTER_tips" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_FILTER_tips" value="/**&#10; * Implements hook_filter_FILTER_tips().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_FILTER_tips($filter, $format, $long) {&#10; if ($long) {&#10;    return t('Lines and paragraphs are automatically recognized. The &amp;lt;br /&amp;gt; line break, &amp;lt;p&amp;gt; paragraph and &amp;lt;/p&amp;gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');&#10;  }&#10;  else {&#10;    return t('Lines and paragraphs break automatically.');&#10;  }&#10;  $END$&#10;}" description="hook_filter_FILTER_tips" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_format_insert" value="/**&#10; * Implements hook_filter_format_insert().&#10; *&#10; * Perform actions when a new text format has been created.&#10; *&#10; * @param $format&#10; *   The format object of the format being updated.&#10; *&#10; * @see hook_filter_format_update()&#10; * @see hook_filter_format_disable()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_insert($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_format_insert" value="/**&#10; * Implements hook_filter_format_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_insert($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_format_update" value="/**&#10; * Implements hook_filter_format_update().&#10; *&#10; * Perform actions when a text format has been updated.&#10; *&#10; * This hook allows modules to act when a text format has been updated in any&#10; * way. For example, when filters have been reconfigured, disabled, or&#10; * re-arranged in the text format.&#10; *&#10; * @param $format&#10; *   The format object of the format being updated.&#10; *&#10; * @see hook_filter_format_insert()&#10; * @see hook_filter_format_disable()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_update($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_format_update" value="/**&#10; * Implements hook_filter_format_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_update($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_format_disable" value="/**&#10; * Implements hook_filter_format_disable().&#10; *&#10; * Perform actions when a text format has been disabled.&#10; *&#10; * @param $format&#10; *   The format object of the format being disabled.&#10; *&#10; * @see hook_filter_format_insert()&#10; * @see hook_filter_format_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_disable($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_disable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_format_disable" value="/**&#10; * Implements hook_filter_format_disable().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_format_disable($format) {&#10;  mymodule_cache_rebuild();&#10;  $END$&#10;}" description="hook_filter_format_disable" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_trigger_info" value="/**&#10; * Implements hook_trigger_info().&#10; *&#10; * Declare triggers (events) for users to assign actions to.&#10; *&#10; * This hook is used by the trigger module to create a list of triggers (events)&#10; * that users can assign actions to. Your module is responsible for detecting&#10; * that the events have occurred, calling trigger_get_assigned_actions() to find&#10; * out which actions the user has associated with your trigger, and then calling&#10; * actions_do() to fire off the actions.&#10; *&#10; * @return&#10; *   A nested associative array.&#10; *   - The outermost key is the name of the module that is defining the triggers.&#10; *     This will be used to create a local task (tab) in the trigger module's&#10; *     user interface. A contrib module may supply a trigger for a core module by&#10; *     giving the core module's name as the key. For example, you could use the&#10; *     'node' key to add a node-related trigger.&#10; *     - Within each module, each individual trigger is keyed by a hook name&#10; *       describing the particular trigger (this is not visible to the user, but&#10; *       can be used by your module for identification).&#10; *       - Each trigger is described by an associative array. Currently, the only&#10; *         key-value pair is 'label', which contains a translated human-readable&#10; *         description of the triggering event.&#10; *   For example, the trigger set for the 'node' module has 'node' as the&#10; *   outermost key and defines triggers for 'node_insert', 'node_update',&#10; *   'node_delete' etc. that fire when a node is saved, updated, etc.&#10; *&#10; * @see hook_action_info()&#10; * @see hook_trigger_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_trigger_info() {&#10;  return array(&#10;    'node' =&gt; array(&#10;      'node_presave' =&gt; array(&#10;        'label' =&gt; t('When either saving new content or updating existing content'),&#10;      ),&#10;      'node_insert' =&gt; array(&#10;        'label' =&gt; t('After saving new content'),&#10;      ),&#10;      'node_update' =&gt; array(&#10;        'label' =&gt; t('After saving updated content'),&#10;      ),&#10;      'node_delete' =&gt; array(&#10;        'label' =&gt; t('After deleting content'),&#10;      ),&#10;      'node_view' =&gt; array(&#10;        'label' =&gt; t('When content is viewed by an authenticated user'),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_trigger_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_trigger_info" value="/**&#10; * Implements hook_trigger_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_trigger_info() {&#10;  return array(&#10;    'node' =&gt; array(&#10;      'node_presave' =&gt; array(&#10;        'label' =&gt; t('When either saving new content or updating existing content'),&#10;      ),&#10;      'node_insert' =&gt; array(&#10;        'label' =&gt; t('After saving new content'),&#10;      ),&#10;      'node_update' =&gt; array(&#10;        'label' =&gt; t('After saving updated content'),&#10;      ),&#10;      'node_delete' =&gt; array(&#10;        'label' =&gt; t('After deleting content'),&#10;      ),&#10;      'node_view' =&gt; array(&#10;        'label' =&gt; t('When content is viewed by an authenticated user'),&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_trigger_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_trigger_info_alter" value="/**&#10; * Implements hook_trigger_info_alter().&#10; *&#10; * Alter triggers declared by hook_trigger_info().&#10; *&#10; * @param $triggers&#10; *   Array of trigger information returned by hook_trigger_info()&#10; *   implementations. Modify this array in place. See hook_trigger_info()&#10; *   for information on what this might contain.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_trigger_info_alter(&amp;$triggers) {&#10;  $triggers['node']['node_insert']['label'] = t('When content is saved');&#10;  $END$&#10;}" description="hook_trigger_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_trigger_info_alter" value="/**&#10; * Implements hook_trigger_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_trigger_info_alter(&amp;$triggers) {&#10;  $triggers['node']['node_insert']['label'] = t('When content is saved');&#10;  $END$&#10;}" description="hook_trigger_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_insert" value="/**&#10; * Implements hook_menu_insert().&#10; *&#10; * Informs modules that a custom menu was created.&#10; *&#10; * This hook is used to notify modules that a custom menu has been created.&#10; * Contributed modules may use the information to perform actions based on the&#10; * information entered into the menu system.&#10; *&#10; * @param $menu&#10; *   An array representing a custom menu:&#10; *   - menu_name: The unique name of the custom menu.&#10; *   - title: The human readable menu title.&#10; *   - description: The custom menu description.&#10; *&#10; * @see hook_menu_update()&#10; * @see hook_menu_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_insert($menu) {&#10;  // For example, we track available menus in a variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  $my_menus[$menu['menu_name']] = $menu['menu_name'];&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_insert" value="/**&#10; * Implements hook_menu_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_insert($menu) {&#10;  // For example, we track available menus in a variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  $my_menus[$menu['menu_name']] = $menu['menu_name'];&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_update" value="/**&#10; * Implements hook_menu_update().&#10; *&#10; * Informs modules that a custom menu was updated.&#10; *&#10; * This hook is used to notify modules that a custom menu has been updated.&#10; * Contributed modules may use the information to perform actions based on the&#10; * information entered into the menu system.&#10; *&#10; * @param $menu&#10; *   An array representing a custom menu:&#10; *   - menu_name: The unique name of the custom menu.&#10; *   - title: The human readable menu title.&#10; *   - description: The custom menu description.&#10; *   - old_name: The current 'menu_name'. Note that internal menu names cannot&#10; *     be changed after initial creation.&#10; *&#10; * @see hook_menu_insert()&#10; * @see hook_menu_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_update($menu) {&#10;  // For example, we track available menus in a variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  $my_menus[$menu['menu_name']] = $menu['menu_name'];&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_update" value="/**&#10; * Implements hook_menu_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_update($menu) {&#10;  // For example, we track available menus in a variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  $my_menus[$menu['menu_name']] = $menu['menu_name'];&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_delete" value="/**&#10; * Implements hook_menu_delete().&#10; *&#10; * Informs modules that a custom menu was deleted.&#10; *&#10; * This hook is used to notify modules that a custom menu along with all links&#10; * contained in it (if any) has been deleted. Contributed modules may use the&#10; * information to perform actions based on the information entered into the menu&#10; * system.&#10; *&#10; * @param $link&#10; *   An array representing a custom menu:&#10; *   - menu_name: The unique name of the custom menu.&#10; *   - title: The human readable menu title.&#10; *   - description: The custom menu description.&#10; *&#10; * @see hook_menu_insert()&#10; * @see hook_menu_update()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_delete($menu) {&#10;  // Delete the record from our variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  unset($my_menus[$menu['menu_name']]);&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_delete" value="/**&#10; * Implements hook_menu_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_delete($menu) {&#10;  // Delete the record from our variable.&#10;  $my_menus = variable_get('my_module_menus', array());&#10;  unset($my_menus[$menu['menu_name']]);&#10;  variable_set('my_module_menus', $my_menus);&#10;  $END$&#10;}" description="hook_menu_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_fetch" value="/**&#10; * Implements hook_aggregator_fetch().&#10; *&#10; * Implement this hook to create an alternative fetcher for aggregator module.&#10; *&#10; * A fetcher downloads feed data to a Drupal site. The fetcher is called&#10; * at the first of the three aggregation stages: data is downloaded by the&#10; * active fetcher, it is converted to a common format by the active parser and&#10; * finally, it is passed to all active processors which manipulate or store the&#10; * data.&#10; *&#10; * Modules that define this hook can be set as active fetcher on&#10; * admin/config/services/aggregator. Only one fetcher can be active at a time.&#10; *&#10; * @param $feed&#10; *   The $feed object that describes the resource to be downloaded.&#10; *   $feed-&gt;url contains the link to the feed. Download the data at the URL&#10; *   and expose it to other modules by attaching it to $feed-&gt;source_string.&#10; *&#10; * @return&#10; *   TRUE if fetching was successful, FALSE otherwise.&#10; *&#10; * @see hook_aggregator_fetch_info()&#10; * @see hook_aggregator_parse()&#10; * @see hook_aggregator_process()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_fetch($feed) {&#10;  $feed-&gt;source_string = mymodule_fetch($feed-&gt;url);&#10;  $END$&#10;}" description="hook_aggregator_fetch" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_fetch" value="/**&#10; * Implements hook_aggregator_fetch().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_fetch($feed) {&#10;  $feed-&gt;source_string = mymodule_fetch($feed-&gt;url);&#10;  $END$&#10;}" description="hook_aggregator_fetch" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_fetch_info" value="/**&#10; * Implements hook_aggregator_fetch_info().&#10; *&#10; * Implement this hook to expose the title and a short description of your&#10; * fetcher.&#10; *&#10; * The title and the description provided are shown on&#10; * admin/config/services/aggregator among other places. Use as title the human&#10; * readable name of the fetcher and as description a brief (40 to 80 characters)&#10; * explanation of the fetcher's functionality.&#10; *&#10; * This hook is only called if your module implements hook_aggregator_fetch().&#10; * If this hook is not implemented aggregator will use your module's file name&#10; * as title and there will be no description.&#10; *&#10; * @return&#10; *   An associative array defining a title and a description string.&#10; *&#10; * @see hook_aggregator_fetch()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_fetch_info() {&#10;  return array(&#10;    'title' =&gt; t('Default fetcher'),&#10;    'description' =&gt; t('Default fetcher for resources available by URL.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_fetch_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_fetch_info" value="/**&#10; * Implements hook_aggregator_fetch_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_fetch_info() {&#10;  return array(&#10;    'title' =&gt; t('Default fetcher'),&#10;    'description' =&gt; t('Default fetcher for resources available by URL.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_fetch_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_parse" value="/**&#10; * Implements hook_aggregator_parse().&#10; *&#10; * Implement this hook to create an alternative parser for aggregator module.&#10; *&#10; * A parser converts feed item data to a common format. The parser is called&#10; * at the second of the three aggregation stages: data is downloaded by the&#10; * active fetcher, it is converted to a common format by the active parser and&#10; * finally, it is passed to all active processors which manipulate or store the&#10; * data.&#10; *&#10; * Modules that define this hook can be set as active parser on&#10; * admin/config/services/aggregator. Only one parser can be active at a time.&#10; *&#10; * @param $feed&#10; *   The $feed object that describes the resource to be parsed.&#10; *   $feed-&gt;source_string contains the raw feed data as a string. Parse data&#10; *   from $feed-&gt;source_string and expose it to other modules as an array of&#10; *   data items on $feed-&gt;items.&#10; *&#10; *   Feed format:&#10; *   - $feed-&gt;description (string) - description of the feed&#10; *   - $feed-&gt;image (string) - image for the feed&#10; *   - $feed-&gt;etag (string) - value of feed's entity tag header field&#10; *   - $feed-&gt;modified (UNIX timestamp) - value of feed's last modified header&#10; *     field&#10; *   - $feed-&gt;items (Array) - array of feed items.&#10; *&#10; *   By convention, the common format for a single feed item is:&#10; *   $item[key-name] = value;&#10; *&#10; *   Recognized keys:&#10; *   TITLE (string) - the title of a feed item&#10; *   DESCRIPTION (string) - the description (body text) of a feed item&#10; *   TIMESTAMP (UNIX timestamp) - the feed item's published time as UNIX timestamp&#10; *   AUTHOR (string) - the feed item's author&#10; *   GUID (string) - RSS/Atom global unique identifier&#10; *   LINK (string) - the feed item's URL&#10; *&#10; * @return&#10; *   TRUE if parsing was successful, FALSE otherwise.&#10; *&#10; * @see hook_aggregator_parse_info()&#10; * @see hook_aggregator_fetch()&#10; * @see hook_aggregator_process()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_parse($feed) {&#10;  if ($items = mymodule_parse($feed-&gt;source_string)) {&#10;    $feed-&gt;items = $items;&#10;    return TRUE;&#10;  }&#10;  return FALSE;&#10;  $END$&#10;}" description="hook_aggregator_parse" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_parse" value="/**&#10; * Implements hook_aggregator_parse().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_parse($feed) {&#10;  if ($items = mymodule_parse($feed-&gt;source_string)) {&#10;    $feed-&gt;items = $items;&#10;    return TRUE;&#10;  }&#10;  return FALSE;&#10;  $END$&#10;}" description="hook_aggregator_parse" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_parse_info" value="/**&#10; * Implements hook_aggregator_parse_info().&#10; *&#10; * Implement this hook to expose the title and a short description of your&#10; * parser.&#10; *&#10; * The title and the description provided are shown on&#10; * admin/config/services/aggregator among other places. Use as title the human&#10; * readable name of the parser and as description a brief (40 to 80 characters)&#10; * explanation of the parser's functionality.&#10; *&#10; * This hook is only called if your module implements hook_aggregator_parse().&#10; * If this hook is not implemented aggregator will use your module's file name&#10; * as title and there will be no description.&#10; *&#10; * @return&#10; *   An associative array defining a title and a description string.&#10; *&#10; * @see hook_aggregator_parse()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_parse_info() {&#10;  return array(&#10;    'title' =&gt; t('Default parser'),&#10;    'description' =&gt; t('Default parser for RSS, Atom and RDF feeds.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_parse_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_parse_info" value="/**&#10; * Implements hook_aggregator_parse_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_parse_info() {&#10;  return array(&#10;    'title' =&gt; t('Default parser'),&#10;    'description' =&gt; t('Default parser for RSS, Atom and RDF feeds.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_parse_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_process" value="/**&#10; * Implements hook_aggregator_process().&#10; *&#10; * Implement this hook to create a processor for aggregator module.&#10; *&#10; * A processor acts on parsed feed data. Active processors are called at the&#10; * third and last of the aggregation stages: data is downloaded by the active&#10; * fetcher, it is converted to a common format by the active parser and&#10; * finally, it is passed to all active processors which manipulate or store the&#10; * data.&#10; *&#10; * Modules that define this hook can be activated as processor on&#10; * admin/config/services/aggregator.&#10; *&#10; * @param $feed&#10; *   The $feed object that describes the resource to be processed. $feed-&gt;items&#10; *   contains an array of feed items downloaded and parsed at the parsing&#10; *   stage. See hook_aggregator_parse() for the basic format of a single item&#10; *   in the $feed-&gt;items array. For the exact format refer to the particular&#10; *   parser in use.&#10; *&#10; * @see hook_aggregator_process_info()&#10; * @see hook_aggregator_fetch()&#10; * @see hook_aggregator_parse()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_process($feed) {&#10;  foreach ($feed-&gt;items as $item) {&#10;    mymodule_save($item);&#10;  }&#10;  $END$&#10;}" description="hook_aggregator_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_process" value="/**&#10; * Implements hook_aggregator_process().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_process($feed) {&#10;  foreach ($feed-&gt;items as $item) {&#10;    mymodule_save($item);&#10;  }&#10;  $END$&#10;}" description="hook_aggregator_process" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_process_info" value="/**&#10; * Implements hook_aggregator_process_info().&#10; *&#10; * Implement this hook to expose the title and a short description of your&#10; * processor.&#10; *&#10; * The title and the description provided are shown most importantly on&#10; * admin/config/services/aggregator. Use as title the natural name of the&#10; * processor and as description a brief (40 to 80 characters) explanation of&#10; * the functionality.&#10; *&#10; * This hook is only called if your module implements&#10; * hook_aggregator_process(). If this hook is not implemented aggregator&#10; * will use your module's file name as title and there will be no description.&#10; *&#10; * @return&#10; *   An associative array defining a title and a description string.&#10; *&#10; * @see hook_aggregator_process()&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_process_info($feed) {&#10;  return array(&#10;    'title' =&gt; t('Default processor'),&#10;    'description' =&gt; t('Creates lightweight records of feed items.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_process_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_process_info" value="/**&#10; * Implements hook_aggregator_process_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_process_info($feed) {&#10;  return array(&#10;    'title' =&gt; t('Default processor'),&#10;    'description' =&gt; t('Creates lightweight records of feed items.'),&#10;  );&#10;  $END$&#10;}" description="hook_aggregator_process_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_aggregator_remove" value="/**&#10; * Implements hook_aggregator_remove().&#10; *&#10; * Implement this hook to remove stored data if a feed is being deleted or a&#10; * feed's items are being removed.&#10; *&#10; * Aggregator calls this hook if either a feed is deleted or a user clicks on&#10; * &quot;remove items&quot;.&#10; *&#10; * If your module stores feed items for example on hook_aggregator_process() it&#10; * is recommended to implement this hook and to remove data related to $feed&#10; * when called.&#10; *&#10; * @param $feed&#10; *   The $feed object whose items are being removed.&#10; *&#10; * @ingroup aggregator&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_remove($feed) {&#10;  mymodule_remove_items($feed-&gt;fid);&#10;  $END$&#10;}" description="hook_aggregator_remove" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_aggregator_remove" value="/**&#10; * Implements hook_aggregator_remove().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_aggregator_remove($feed) {&#10;  mymodule_remove_items($feed-&gt;fid);&#10;  $END$&#10;}" description="hook_aggregator_remove" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_info" value="/**&#10; * Implements hook_block_info().&#10; *&#10; * Define all blocks provided by the module.&#10; *&#10; * This hook declares to Drupal what blocks are provided by your module and can&#10; * optionally specify initial block configuration settings.&#10; *&#10; * In hook_block_info(), each block your module provides is given a unique&#10; * identifier referred to as &quot;delta&quot; (the array key in the return value). Delta&#10; * values only need to be unique within your module, and they are used in the&#10; * following ways:&#10; * - Passed into the other block hooks in your module as an argument to&#10; *   identify the block being configured or viewed.&#10; * - Used to construct the default HTML ID of &quot;block-MODULE-DELTA&quot; applied to&#10; *   each block when it is rendered (which can then be used for CSS styling or&#10; *   JavaScript programming).&#10; * - Used to define a theming template suggestion of block__MODULE__DELTA, for&#10; *   advanced theming possibilities.&#10; * - Used by other modules to identify your block in hook_block_info_alter() and&#10; *   other alter hooks.&#10; * The values of delta can be strings or numbers, but because of the uses above&#10; * it is preferable to use descriptive strings whenever possible, and only use a&#10; * numeric identifier if you have to (for instance if your module allows users&#10; * to create several similar blocks that you identify within your module code&#10; * with numeric IDs). The maximum length for delta values is 32 bytes.&#10; *&#10; * @return&#10; *   An associative array whose keys define the delta for each block and whose&#10; *   values contain the block descriptions. Each block description is itself an&#10; *   associative array, with the following key-value pairs:&#10; *   - 'info': (required) The human-readable administrative name of the block.&#10; *     This is used to identify the block on administration screens, and&#10; *     is not displayed to non-administrative users.&#10; *   - 'cache': (optional) A bitmask describing what kind of caching is&#10; *     appropriate for the block. Drupal provides the following bitmask&#10; *     constants for defining cache granularity:&#10; *     - DRUPAL_CACHE_PER_ROLE (default): The block can change depending on the&#10; *       roles the user viewing the page belongs to.&#10; *     - DRUPAL_CACHE_PER_USER: The block can change depending on the user&#10; *       viewing the page. This setting can be resource-consuming for sites&#10; *       with large number of users, and should only be used when&#10; *       DRUPAL_CACHE_PER_ROLE is not sufficient.&#10; *     - DRUPAL_CACHE_PER_PAGE: The block can change depending on the page&#10; *       being viewed.&#10; *     - DRUPAL_CACHE_GLOBAL: The block is the same for every user on every&#10; *       page where it is visible.&#10; *     - DRUPAL_NO_CACHE: The block should not get cached.&#10; *   - 'properties': (optional) Array of additional metadata to add to the&#10; *     block. Common properties include:&#10; *     - 'administrative': Boolean which categorizes this block as usable in&#10; *       an administrative context. This might include blocks which help an&#10; *       administrator approve/deny comments, or view recently created&#10; *       user accounts.&#10; *   - 'weight': (optional) Initial value for the ordering weight of this block.&#10; *     Most modules do not provide an initial value, and any value provided can&#10; *     be modified by a user on the block configuration screen.&#10; *   - 'status': (optional) Initial value for block enabled status. (1 =&#10; *     enabled, 0 = disabled). Most modules do not provide an initial value,&#10; *     and any value provided can be modified by a user on the block&#10; *     configuration screen.&#10; *   - 'region': (optional) Initial value for theme region within which this&#10; *     block is set. Most modules do not provide an initial value, and&#10; *     any value provided can be modified by a user on the block configuration&#10; *     screen. Note: If you set a region that isn't available in the currently&#10; *     enabled theme, the block will be disabled.&#10; *   - 'visibility': (optional) Initial value for the visibility flag, which&#10; *     tells how to interpret the 'pages' value. Possible values are:&#10; *     - BLOCK_VISIBILITY_NOTLISTED: Show on all pages except listed pages.&#10; *       'pages' lists the paths where the block should not be shown.&#10; *     - BLOCK_VISIBILITY_LISTED: Show only on listed pages. 'pages' lists the&#10; *       paths where the block should be shown.&#10; *     - BLOCK_VISIBILITY_PHP: Use custom PHP code to determine visibility.&#10; *       'pages' gives the PHP code to use.&#10; *     Most modules do not provide an initial value for 'visibility' or 'pages',&#10; *     and any value provided can be modified by a user on the block&#10; *     configuration screen.&#10; *   - 'pages': (optional) See 'visibility' above.&#10; *&#10; * For a detailed usage example, see block_example.module.&#10; *&#10; * @see hook_block_configure()&#10; * @see hook_block_save()&#10; * @see hook_block_view()&#10; * @see hook_block_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_info() {&#10;  // This example comes from node.module.&#10;  $blocks['syndicate'] = array(&#10;    'info' =&gt; t('Syndicate'),&#10;    'cache' =&gt; DRUPAL_NO_CACHE&#10;  );&#10;&#10;  $blocks['recent'] = array(&#10;    'info' =&gt; t('Recent content'),&#10;    // DRUPAL_CACHE_PER_ROLE will be assumed.&#10;  );&#10;&#10;  return $blocks;&#10;  $END$&#10;}" description="hook_block_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_info" value="/**&#10; * Implements hook_block_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_info() {&#10;  // This example comes from node.module.&#10;  $blocks['syndicate'] = array(&#10;    'info' =&gt; t('Syndicate'),&#10;    'cache' =&gt; DRUPAL_NO_CACHE&#10;  );&#10;&#10;  $blocks['recent'] = array(&#10;    'info' =&gt; t('Recent content'),&#10;    // DRUPAL_CACHE_PER_ROLE will be assumed.&#10;  );&#10;&#10;  return $blocks;&#10;  $END$&#10;}" description="hook_block_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_info_alter" value="/**&#10; * Implements hook_block_info_alter().&#10; *&#10; * Change block definition before saving to the database.&#10; *&#10; * @param $blocks&#10; *   A multidimensional array of blocks keyed by the defining module and delta;&#10; *   the values are blocks returned by hook_block_info(). This hook is fired&#10; *   after the blocks are collected from hook_block_info() and the database,&#10; *   right before saving back to the database.&#10; * @param $theme&#10; *   The theme these blocks belong to.&#10; * @param $code_blocks&#10; *   The blocks as defined in hook_block_info() before being overwritten by the&#10; *   database data.&#10; *&#10; * @see hook_block_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_info_alter(&amp;$blocks, $theme, $code_blocks) {&#10;  // Disable the login block.&#10;  $blocks['user']['login']['status'] = 0;&#10;  $END$&#10;}" description="hook_block_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_info_alter" value="/**&#10; * Implements hook_block_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_info_alter(&amp;$blocks, $theme, $code_blocks) {&#10;  // Disable the login block.&#10;  $blocks['user']['login']['status'] = 0;&#10;  $END$&#10;}" description="hook_block_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_configure" value="/**&#10; * Implements hook_block_configure().&#10; *&#10; * Define a configuration form for a block.&#10; *&#10; * @param $delta&#10; *   Which block is being configured. This is a unique identifier for the block&#10; *   within the module, defined in hook_block_info().&#10; *&#10; * @return&#10; *   A configuration form, if one is needed for your block beyond the standard&#10; *   elements that the block module provides (block title, visibility, etc.).&#10; *&#10; * For a detailed usage example, see block_example.module.&#10; *&#10; * @see hook_block_info()&#10; * @see hook_block_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_configure($delta = '') {&#10;  // This example comes from node.module.&#10;  $form = array();&#10;  if ($delta == 'recent') {&#10;    $form['node_recent_block_count'] = array(&#10;      '#type' =&gt; 'select',&#10;      '#title' =&gt; t('Number of recent content items to display'),&#10;      '#default_value' =&gt; variable_get('node_recent_block_count', 10),&#10;      '#options' =&gt; drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 30)),&#10;    );&#10;  }&#10;  return $form;&#10;  $END$&#10;}" description="hook_block_configure" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_configure" value="/**&#10; * Implements hook_block_configure().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_configure($delta = '') {&#10;  // This example comes from node.module.&#10;  $form = array();&#10;  if ($delta == 'recent') {&#10;    $form['node_recent_block_count'] = array(&#10;      '#type' =&gt; 'select',&#10;      '#title' =&gt; t('Number of recent content items to display'),&#10;      '#default_value' =&gt; variable_get('node_recent_block_count', 10),&#10;      '#options' =&gt; drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 30)),&#10;    );&#10;  }&#10;  return $form;&#10;  $END$&#10;}" description="hook_block_configure" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_save" value="/**&#10; * Implements hook_block_save().&#10; *&#10; * Save the configuration options from hook_block_configure().&#10; *&#10; * This hook allows you to save the block-specific configuration settings&#10; * defined within your hook_block_configure().&#10; *&#10; * @param $delta&#10; *   Which block is being configured. This is a unique identifier for the block&#10; *   within the module, defined in hook_block_info().&#10; * @param $edit&#10; *   The submitted form data from the configuration form.&#10; *&#10; * For a detailed usage example, see block_example.module.&#10; *&#10; * @see hook_block_configure()&#10; * @see hook_block_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_save($delta = '', $edit = array()) {&#10;  // This example comes from node.module.&#10;  if ($delta == 'recent') {&#10;    variable_set('node_recent_block_count', $edit['node_recent_block_count']);&#10;  }&#10;  $END$&#10;}" description="hook_block_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_save" value="/**&#10; * Implements hook_block_save().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_save($delta = '', $edit = array()) {&#10;  // This example comes from node.module.&#10;  if ($delta == 'recent') {&#10;    variable_set('node_recent_block_count', $edit['node_recent_block_count']);&#10;  }&#10;  $END$&#10;}" description="hook_block_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_view" value="/**&#10; * Implements hook_block_view().&#10; *&#10; * Return a rendered or renderable view of a block.&#10; *&#10; * @param $delta&#10; *   Which block to render. This is a unique identifier for the block&#10; *   within the module, defined in hook_block_info().&#10; *&#10; * @return&#10; *   An array containing the following elements:&#10; *   - subject: The default localized title of the block. If the block does not&#10; *     have a default title, this should be set to NULL.&#10; *   - content: The content of the block's body. This may be a renderable array&#10; *     (preferable) or a string containing rendered HTML content.&#10; *&#10; * For a detailed usage example, see block_example.module.&#10; *&#10; * @see hook_block_info()&#10; * @see hook_block_view_alter()&#10; * @see hook_block_view_MODULE_DELTA_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view($delta = '') {&#10;  // This example is adapted from node.module.&#10;  $block = array();&#10;&#10;  switch ($delta) {&#10;    case 'syndicate':&#10;      $block['subject'] = t('Syndicate');&#10;      $block['content'] = array(&#10;        '#theme' =&gt; 'feed_icon',&#10;        '#url' =&gt; 'rss.xml',&#10;        '#title' =&gt; t('Syndicate'),&#10;      );&#10;      break;&#10;&#10;    case 'recent':&#10;      if (user_access('access content')) {&#10;        $block['subject'] = t('Recent content');&#10;        if ($nodes = node_get_recent(variable_get('node_recent_block_count', 10))) {&#10;          $block['content'] = array(&#10;            '#theme' =&gt; 'node_recent_block',&#10;            '#nodes' =&gt; $nodes,&#10;          );&#10;        } else {&#10;          $block['content'] = t('No content available.');&#10;        }&#10;      }&#10;      break;&#10;  }&#10;  return $block;&#10;  $END$&#10;}" description="hook_block_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_view" value="/**&#10; * Implements hook_block_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view($delta = '') {&#10;  // This example is adapted from node.module.&#10;  $block = array();&#10;&#10;  switch ($delta) {&#10;    case 'syndicate':&#10;      $block['subject'] = t('Syndicate');&#10;      $block['content'] = array(&#10;        '#theme' =&gt; 'feed_icon',&#10;        '#url' =&gt; 'rss.xml',&#10;        '#title' =&gt; t('Syndicate'),&#10;      );&#10;      break;&#10;&#10;    case 'recent':&#10;      if (user_access('access content')) {&#10;        $block['subject'] = t('Recent content');&#10;        if ($nodes = node_get_recent(variable_get('node_recent_block_count', 10))) {&#10;          $block['content'] = array(&#10;            '#theme' =&gt; 'node_recent_block',&#10;            '#nodes' =&gt; $nodes,&#10;          );&#10;        } else {&#10;          $block['content'] = t('No content available.');&#10;        }&#10;      }&#10;      break;&#10;  }&#10;  return $block;&#10;  $END$&#10;}" description="hook_block_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_view_alter" value="/**&#10; * Implements hook_block_view_alter().&#10; *&#10; * Perform alterations to the content of a block.&#10; *&#10; * This hook allows you to modify any data returned by hook_block_view().&#10; *&#10; * Note that instead of hook_block_view_alter(), which is called for all&#10; * blocks, you can also use hook_block_view_MODULE_DELTA_alter() to alter a&#10; * specific block.&#10; *&#10; * @param $data&#10; *   An array of data, as returned from the hook_block_view() implementation of&#10; *   the module that defined the block:&#10; *   - subject: The default localized title of the block.&#10; *   - content: Either a string or a renderable array representing the content&#10; *     of the block. You should check that the content is an array before trying&#10; *     to modify parts of the renderable structure.&#10; * @param $block&#10; *   The block object, as loaded from the database, having the main properties:&#10; *   - module: The name of the module that defined the block.&#10; *   - delta: The unique identifier for the block within that module, as defined&#10; *     in hook_block_info().&#10; *&#10; * @see hook_block_view_MODULE_DELTA_alter()&#10; * @see hook_block_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view_alter(&amp;$data, $block) {&#10;  // Remove the contextual links on all blocks that provide them.&#10;  if (is_array($data['content']) &amp;&amp; isset($data['content']['#contextual_links'])) {&#10;    unset($data['content']['#contextual_links']);&#10;  }&#10;  // Add a theme wrapper function defined by the current module to all blocks&#10;  // provided by the &quot;somemodule&quot; module.&#10;  if (is_array($data['content']) &amp;&amp; $block-&gt;module == 'somemodule') {&#10;    $data['content']['#theme_wrappers'][] = 'mymodule_special_block';&#10;  }&#10;  $END$&#10;}" description="hook_block_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_view_alter" value="/**&#10; * Implements hook_block_view_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view_alter(&amp;$data, $block) {&#10;  // Remove the contextual links on all blocks that provide them.&#10;  if (is_array($data['content']) &amp;&amp; isset($data['content']['#contextual_links'])) {&#10;    unset($data['content']['#contextual_links']);&#10;  }&#10;  // Add a theme wrapper function defined by the current module to all blocks&#10;  // provided by the &quot;somemodule&quot; module.&#10;  if (is_array($data['content']) &amp;&amp; $block-&gt;module == 'somemodule') {&#10;    $data['content']['#theme_wrappers'][] = 'mymodule_special_block';&#10;  }&#10;  $END$&#10;}" description="hook_block_view_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_view_MODULE_DELTA_alter" value="/**&#10; * Implements hook_block_view_MODULE_DELTA_alter().&#10; *&#10; * Perform alterations to a specific block.&#10; *&#10; * Modules can implement hook_block_view_MODULE_DELTA_alter() to modify a&#10; * specific block, rather than implementing hook_block_view_alter().&#10; *&#10; * @param $data&#10; *   An array of data, as returned from the hook_block_view() implementation of&#10; *   the module that defined the block:&#10; *   - subject: The localized title of the block.&#10; *   - content: Either a string or a renderable array representing the content&#10; *     of the block. You should check that the content is an array before trying&#10; *     to modify parts of the renderable structure.&#10; * @param $block&#10; *   The block object, as loaded from the database, having the main properties:&#10; *   - module: The name of the module that defined the block.&#10; *   - delta: The unique identifier for the block within that module, as defined&#10; *     in hook_block_info().&#10; *&#10; * @see hook_block_view_alter()&#10; * @see hook_block_view()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view_MODULE_DELTA_alter(&amp;$data, $block) {&#10;  // This code will only run for a specific block. For example, if MODULE_DELTA&#10;  // in the function definition above is set to &quot;mymodule_somedelta&quot;, the code&#10;  // will only run on the &quot;somedelta&quot; block provided by the &quot;mymodule&quot; module.&#10;&#10;  // Change the title of the &quot;somedelta&quot; block provided by the &quot;mymodule&quot;&#10;  // module.&#10;  $data['subject'] = t('New title of the block');&#10;  $END$&#10;}" description="hook_block_view_MODULE_DELTA_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_view_MODULE_DELTA_alter" value="/**&#10; * Implements hook_block_view_MODULE_DELTA_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_view_MODULE_DELTA_alter(&amp;$data, $block) {&#10;  // This code will only run for a specific block. For example, if MODULE_DELTA&#10;  // in the function definition above is set to &quot;mymodule_somedelta&quot;, the code&#10;  // will only run on the &quot;somedelta&quot; block provided by the &quot;mymodule&quot; module.&#10;&#10;  // Change the title of the &quot;somedelta&quot; block provided by the &quot;mymodule&quot;&#10;  // module.&#10;  $data['subject'] = t('New title of the block');&#10;  $END$&#10;}" description="hook_block_view_MODULE_DELTA_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_block_list_alter" value="/**&#10; * Implements hook_block_list_alter().&#10; *&#10; * Act on blocks prior to rendering.&#10; *&#10; * This hook allows you to add, remove or modify blocks in the block list. The&#10; * block list contains the block definitions, not the rendered blocks. The&#10; * blocks are rendered after the modules have had a chance to manipulate the&#10; * block list.&#10; *&#10; * You can also set $block-&gt;content here, which will override the content of the&#10; * block and prevent hook_block_view() from running.&#10; *&#10; * @param $blocks&#10; *   An array of $blocks, keyed by the block ID.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_list_alter(&amp;$blocks) {&#10;  global $language, $theme_key;&#10;&#10;  // This example shows how to achieve language specific visibility setting for&#10;  // blocks.&#10;&#10;  $result = db_query('SELECT module, delta, language FROM {my_table}');&#10;  $block_languages = array();&#10;  foreach ($result as $record) {&#10;    $block_languages[$record-&gt;module][$record-&gt;delta][$record-&gt;language] = TRUE;&#10;  }&#10;&#10;  foreach ($blocks as $key =&gt; $block) {&#10;    // Any module using this alter should inspect the data before changing it,&#10;    // to ensure it is what they expect.&#10;    if (!isset($block-&gt;theme) || !isset($block-&gt;status) || $block-&gt;theme != $theme_key || $block-&gt;status != 1) {&#10;      // This block was added by a contrib module, leave it in the list.&#10;      continue;&#10;    }&#10;&#10;    if (!isset($block_languages[$block-&gt;module][$block-&gt;delta])) {&#10;      // No language setting for this block, leave it in the list.&#10;      continue;&#10;    }&#10;&#10;    if (!isset($block_languages[$block-&gt;module][$block-&gt;delta][$language-&gt;language])) {&#10;      // This block should not be displayed with the active language, remove&#10;      // from the list.&#10;      unset($blocks[$key]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_block_list_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_block_list_alter" value="/**&#10; * Implements hook_block_list_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_block_list_alter(&amp;$blocks) {&#10;  global $language, $theme_key;&#10;&#10;  // This example shows how to achieve language specific visibility setting for&#10;  // blocks.&#10;&#10;  $result = db_query('SELECT module, delta, language FROM {my_table}');&#10;  $block_languages = array();&#10;  foreach ($result as $record) {&#10;    $block_languages[$record-&gt;module][$record-&gt;delta][$record-&gt;language] = TRUE;&#10;  }&#10;&#10;  foreach ($blocks as $key =&gt; $block) {&#10;    // Any module using this alter should inspect the data before changing it,&#10;    // to ensure it is what they expect.&#10;    if (!isset($block-&gt;theme) || !isset($block-&gt;status) || $block-&gt;theme != $theme_key || $block-&gt;status != 1) {&#10;      // This block was added by a contrib module, leave it in the list.&#10;      continue;&#10;    }&#10;&#10;    if (!isset($block_languages[$block-&gt;module][$block-&gt;delta])) {&#10;      // No language setting for this block, leave it in the list.&#10;      continue;&#10;    }&#10;&#10;    if (!isset($block_languages[$block-&gt;module][$block-&gt;delta][$language-&gt;language])) {&#10;      // This block should not be displayed with the active language, remove&#10;      // from the list.&#10;      unset($blocks[$key]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_block_list_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_dashboard_regions" value="/**&#10; * Implements hook_dashboard_regions().&#10; *&#10; * Adds regions to the dashboard.&#10; *&#10; * @return&#10; *   An array whose keys are the names of the dashboard regions and whose&#10; *   values are the titles that will be displayed in the blocks administration&#10; *   interface. The keys are also used as theme wrapper functions.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_dashboard_regions() {&#10;  // Define a new dashboard region. Your module can also then define&#10;  // theme_mymodule_dashboard_region() as a theme wrapper function to control&#10;  // the region's appearance.&#10;  return array('mymodule_dashboard_region' =&gt; &quot;My module's dashboard region&quot;);&#10;  $END$&#10;}" description="hook_dashboard_regions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_dashboard_regions" value="/**&#10; * Implements hook_dashboard_regions().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_dashboard_regions() {&#10;  // Define a new dashboard region. Your module can also then define&#10;  // theme_mymodule_dashboard_region() as a theme wrapper function to control&#10;  // the region's appearance.&#10;  return array('mymodule_dashboard_region' =&gt; &quot;My module's dashboard region&quot;);&#10;  $END$&#10;}" description="hook_dashboard_regions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_dashboard_regions_alter" value="/**&#10; * Implements hook_dashboard_regions_alter().&#10; *&#10; * Alter dashboard regions provided by modules.&#10; *&#10; * @param $regions&#10; *   An array containing all dashboard regions, in the format provided by&#10; *   hook_dashboard_regions().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_dashboard_regions_alter($regions) {&#10;  // Remove the sidebar region defined by the core dashboard module.&#10;  unset($regions['dashboard_sidebar']);&#10;  $END$&#10;}" description="hook_dashboard_regions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_dashboard_regions_alter" value="/**&#10; * Implements hook_dashboard_regions_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_dashboard_regions_alter($regions) {&#10;  // Remove the sidebar region defined by the core dashboard module.&#10;  unset($regions['dashboard_sidebar']);&#10;  $END$&#10;}" description="hook_dashboard_regions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_download_access" value="/**&#10; * Implements hook_file_download_access().&#10; *&#10; * Control download access to files.&#10; *&#10; * The hook is typically implemented to limit access based on the entity the&#10; * file is referenced, e.g., only users with access to a node should be allowed&#10; * to download files attached to that node.&#10; *&#10; * @param $field&#10; *   The field to which the file belongs.&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The $entity to which $file is referenced.&#10; *&#10; * @return&#10; *   TRUE is access should be allowed by this entity or FALSE if denied. Note&#10; *   that denial may be overridden by another entity controller, making this&#10; *   grant permissive rather than restrictive.&#10; *&#10; * @see hook_field_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download_access($field, $entity_type, $entity) {&#10;  if ($entity_type == 'node') {&#10;    return node_access('view', $entity);&#10;  }&#10;  $END$&#10;}" description="hook_file_download_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_download_access" value="/**&#10; * Implements hook_file_download_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download_access($field, $entity_type, $entity) {&#10;  if ($entity_type == 'node') {&#10;    return node_access('view', $entity);&#10;  }&#10;  $END$&#10;}" description="hook_file_download_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_file_download_access_alter" value="/**&#10; * Implements hook_file_download_access_alter().&#10; *&#10; * Alter the access rules applied to a file download.&#10; *&#10; * Entities that implement file management set the access rules for their&#10; * individual files. Module may use this hook to create custom access rules&#10; * for file downloads.&#10; *&#10; * @see hook_file_download_access().&#10; *&#10; * @param $grants&#10; *   An array of grants gathered by hook_file_download_access(). The array is&#10; *   keyed by the module that defines the entity type's access control; the&#10; *   values are Boolean grant responses for each module.&#10; * @param $field&#10; *   The field to which the file belongs.&#10; * @param $entity_type&#10; *   The type of $entity; for example, 'node' or 'user'.&#10; * @param $entity&#10; *   The $entity to which $file is referenced.&#10; *&#10; * @return&#10; *   An array of grants, keyed by module name, each with a Boolean grant value.&#10; *   Return an empty array to assert FALSE. You may choose to return your own&#10; *   module's value in addition to other grants or to overwrite the values set by&#10; *   other modules.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download_access_alter(&amp;$grants, $field, $entity_type, $entity) {&#10;  // For our example module, we always enforce the rules set by node module.&#10;  if (isset($grants['node'])) {&#10;    $grants = array('node' =&gt; $grants['node']);&#10;  }&#10;  $END$&#10;}" description="hook_file_download_access_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_file_download_access_alter" value="/**&#10; * Implements hook_file_download_access_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_file_download_access_alter(&amp;$grants, $field, $entity_type, $entity) {&#10;  // For our example module, we always enforce the rules set by node module.&#10;  if (isset($grants['node'])) {&#10;    $grants = array('node' =&gt; $grants['node']);&#10;  }&#10;  $END$&#10;}" description="hook_file_download_access_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_property_info" value="/**&#10; * Implements hook_entity_property_info().&#10; *&#10; * Allow modules to define metadata about entity properties.&#10; *&#10; * Modules providing properties for any entities defined in hook_entity_info()&#10; * can implement this hook to provide metadata about this properties.&#10; * For making use of the metadata have a look at the provided wrappers returned&#10; * by entity_metadata_wrapper().&#10; * For providing property information for fields see entity_field_info().&#10; *&#10; * @return&#10; *   An array whose keys are entity type names and whose values are arrays&#10; *   containing the keys:&#10; *   - properties: The array describing all properties for this entity. Entries&#10; *     are keyed by the property name and contain an array of metadata for each&#10; *     property. The name may only contain alphanumeric lowercase characters&#10; *     and underscores. Known keys are:&#10; *     - label: A human readable, translated label for the property.&#10; *     - description: (optional) A human readable, translated description for&#10; *       the property.&#10; *     - type: The data type of the property. To make the property actually&#10; *       useful it is important to map your properties to one of the known data&#10; *       types, which currently are:&#10; *        - text: Any text.&#10; *        - token: A string containing only lowercase letters, numbers, and&#10; *          underscores starting with a letter; e.g. this type is useful for&#10; *          machine readable names.&#10; *        - integer: A usual PHP integer value.&#10; *        - decimal: A PHP float or integer.&#10; *        - date: A full date and time, as timestamp.&#10; *        - duration: A duration as number of seconds.&#10; *        - boolean: A usual PHP boolean value.&#10; *        - uri: An absolute URI or URL.&#10; *        - entities - You may use the type of each entity known by&#10; *          hook_entity_info(), e.g. 'node' or 'user'. Internally entities are&#10; *          represented by their identifieres. In case of single-valued&#10; *          properties getter callbacks may return full entity objects as well,&#10; *          while a value of FALSE is interpreted like a NULL value as &quot;property&#10; *          is not set&quot;.&#10; *        - entity: A special type to be used generically for entities where the&#10; *          entity type is not known beforehand. The entity has to be&#10; *          represented using an EntityMetadataWrapper.&#10; *        - struct: This as well as any else not known type may be used for&#10; *          supporting arbitrary data structures. For that additional metadata&#10; *          has to be specified with the 'property info' key. New type names&#10; *          have to be properly prefixed with the module name.&#10; *        - list: A list of values, represented as numerically indexed array.&#10; *          The list&lt;TYPE&gt; notation may be used to specify the type of the&#10; *          contained items, where TYPE may be any valid type expression.&#10; *     - bundle: (optional) If the property is an entity, you may specify the&#10; *       bundle of the referenced entity.&#10; *     - options list: (optional) A callback that returns a list of possible&#10; *       values for the property. The callback has to return an array as&#10; *       used by hook_options_list().&#10; *       Note that it is possible to return a different set of options depending&#10; *       whether they are used in read or in write context. See&#10; *       EntityMetadataWrapper::optionsList() for more details on that.&#10; *     - getter callback: (optional) A callback used to retrieve the value of&#10; *       the property. Defaults to entity_property_verbatim_get().&#10; *       It is important that your data is represented, as documented for your&#10; *       data type, e.g. a date has to be a timestamp. Thus if necessary, the&#10; *       getter callback has to do the necessary conversion. In case of an empty&#10; *       or not set value, the callback has to return NULL.&#10; *     - setter callback: (optional) A callback used to set the value of the&#10; *       property. In many cases entity_property_verbatim_set() can be used.&#10; *     - validation callback: (optional) A callback that returns whether the&#10; *       passed data value is valid for the property. May be used to implement&#10; *       additional validation checks, such as to ensure the value is a valid&#10; *       mail address.&#10; *     - access callback: (optional) An access callback to allow for checking&#10; *       'view' and 'edit' access for the described property. If no callback&#10; *       is specified, a 'setter permission' may be specified instead.&#10; *     - setter permission: (optional) A permission that describes whether&#10; *       a user has permission to set ('edit') this property. This permission&#10; *       is only be taken into account, if no 'access callback' is given.&#10; *     - schema field: (optional) In case the property is directly based upon&#10; *       a field specified in the entity's hook_schema(), the name of the field.&#10; *     - query callback: (optional) A callback for querying for entities having&#10; *       the given property value. See entity_property_query().&#10; *       In case a 'schema field' has been specified, it is not necessary to&#10; *       specify a callback as it will default to 'entity_metadata_table_query'.&#10; *     - required: (optional) Whether this property is required for the creation&#10; *       of a new instance of its entity. See&#10; *       entity_property_values_create_entity().&#10; *     - field: (optional) A boolean indicating whether a property is stemming&#10; *       from a field.&#10; *     - sanitized: (optional) For textual properties only, whether the text is&#10; *       already sanitized. In this case you might want to also specify a raw&#10; *       getter callback. Defaults to FALSE.&#10; *     - sanitize: (optional) For textual properties, that are not sanitized&#10; *       yet, specify a function for sanitizing the value. Defaults to&#10; *       check_plain().&#10; *     - raw getter callback: (optional) For sanitized textual properties, a&#10; *       separate callback which can be used to retrieve the raw, unprocessed&#10; *       value.&#10; *     - clear: (optional) An array of property names, of which the cache should&#10; *       be cleared too once this property is updated. As a rule of thumb any&#10; *       duplicated properties should be avoided though.&#10; *     - property info: (optional) An array of info for an arbitrary data&#10; *       structure together with any else not defined type, see data type&#10; *       'struct'. Specify metadata in the same way as defined for this hook.&#10; *     - property info alter: (optional) A callback for altering the property&#10; *       info before it is used by the metadata wrappers.&#10; *     - property defaults: (optional) An array of property info defaults for&#10; *       each property derived of the wrapped data item (e.g. an entity).&#10; *       Applied by the metadata wrappers.&#10; *     - auto creation: (optional) Properties of type 'struct' may specify&#10; *       this callback which is used to automatically create the data structure&#10; *       (e.g. an array) if necessary. This is necessary in order to support&#10; *       setting a property of a not yet initialized data structure.&#10; *       See entity_metadata_field_file_callback() for an example.&#10; *     - translatable: (optional) Whether the property is translatable, defaults&#10; *       to FALSE.&#10; *     - entity token: (optional) If Entity tokens module is enabled, the&#10; *       module provides a token for the property if one does not exist yet.&#10; *       Specify FALSE to disable this functionality for the property.&#10; *   - bundles: An array keyed by bundle name containing further metadata&#10; *     related to the bundles only. This array may contain the key 'properties'&#10; *     with an array of info about the bundle specific properties, structured in&#10; *     the same way as the entity properties array.&#10; *&#10; *  @see hook_entity_property_info_alter()&#10; *  @see entity_metadata_get_info()&#10; *  @see entity_metadata_wrapper()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_property_info() {&#10;  $info = array();&#10;  $properties = &amp;$info['node']['properties'];&#10;&#10;  $properties['nid'] = array(&#10;    'label' =&gt; t(&quot;Content ID&quot;),&#10;    'type' =&gt; 'integer',&#10;    'description' =&gt; t(&quot;The unique content ID.&quot;),&#10;  );&#10;  return $info;&#10;  $END$&#10;}" description="hook_entity_property_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_property_info" value="/**&#10; * Implements hook_entity_property_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_property_info() {&#10;  $info = array();&#10;  $properties = &amp;$info['node']['properties'];&#10;&#10;  $properties['nid'] = array(&#10;    'label' =&gt; t(&quot;Content ID&quot;),&#10;    'type' =&gt; 'integer',&#10;    'description' =&gt; t(&quot;The unique content ID.&quot;),&#10;  );&#10;  return $info;&#10;  $END$&#10;}" description="hook_entity_property_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_entity_property_info_alter" value="/**&#10; * Implements hook_entity_property_info_alter().&#10; *&#10; * Allow modules to alter metadata about entity properties.&#10; *&#10; * @see hook_entity_property_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_property_info_alter(&amp;$info) {&#10;  $properties = &amp;$info['node']['bundles']['poll']['properties'];&#10;&#10;  $properties['poll-votes'] = array(&#10;    'label' =&gt; t(&quot;Poll votes&quot;),&#10;    'description' =&gt; t(&quot;The number of votes that have been cast on a poll node.&quot;),&#10;    'type' =&gt; 'integer',&#10;    'getter callback' =&gt; 'entity_property_poll_node_get_properties',&#10;  );&#10;  $END$&#10;}" description="hook_entity_property_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_entity_property_info_alter" value="/**&#10; * Implements hook_entity_property_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_entity_property_info_alter(&amp;$info) {&#10;  $properties = &amp;$info['node']['bundles']['poll']['properties'];&#10;&#10;  $properties['poll-votes'] = array(&#10;    'label' =&gt; t(&quot;Poll votes&quot;),&#10;    'description' =&gt; t(&quot;The number of votes that have been cast on a poll node.&quot;),&#10;    'type' =&gt; 'integer',&#10;    'getter callback' =&gt; 'entity_property_poll_node_get_properties',&#10;  );&#10;  $END$&#10;}" description="hook_entity_property_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_slideshow_info" value="/**&#10; * Implements hook_views_slideshow_slideshow_info().&#10; *&#10; * Define the type of the slideshow (eg.: cycle, imageflow, ddblock).&#10; *&#10; * @return&#10; *  Associative array of slideshow type and its information.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_slideshow_info() {&#10;  $options = array(&#10;    'views_slideshow_cycle' =&gt; array(&#10;      'name' =&gt; t('Cycle'),&#10;      'accepts' =&gt; array(&#10;        'goToSlide',&#10;        'nextSlide',&#10;        'pause',&#10;        'play',&#10;        'previousSlide',&#10;      ),&#10;      'calls' =&gt; array(&#10;        'transitionBegin',&#10;        'transitionEnd',&#10;        'goToSlide',&#10;        'pause',&#10;        'play',&#10;        'nextSlide',&#10;        'previousSlide',&#10;      ),&#10;    ),&#10;  );&#10;  return $options;&#10;  $END$&#10;}" description="hook_views_slideshow_slideshow_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_slideshow_info" value="/**&#10; * Implements hook_views_slideshow_slideshow_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_slideshow_info() {&#10;  $options = array(&#10;    'views_slideshow_cycle' =&gt; array(&#10;      'name' =&gt; t('Cycle'),&#10;      'accepts' =&gt; array(&#10;        'goToSlide',&#10;        'nextSlide',&#10;        'pause',&#10;        'play',&#10;        'previousSlide',&#10;      ),&#10;      'calls' =&gt; array(&#10;        'transitionBegin',&#10;        'transitionEnd',&#10;        'goToSlide',&#10;        'pause',&#10;        'play',&#10;        'nextSlide',&#10;        'previousSlide',&#10;      ),&#10;    ),&#10;  );&#10;  return $options;&#10;  $END$&#10;}" description="hook_views_slideshow_slideshow_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_slideshow_type_form" value="/**&#10; * Implements hook_views_slideshow_slideshow_type_form().&#10; *&#10; * Define form fields to be displayed in the views settings form.&#10; * These fields would help configure your slideshow type.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_slideshow_type_form(&amp;$form, &amp;$form_state, &amp;$view) {&#10;  $form['views_slideshow_cycle']['effect'] = array(&#10;    '#type' =&gt; 'select',&#10;    '#title' =&gt; t('Effect'),&#10;    '#options' =&gt; $effects,&#10;    '#default_value' =&gt; $view-&gt;options['views_slideshow_cycle']['effect'],&#10;    '#description' =&gt; t('The transition effect that will be used to change between images. Not all options below may be relevant depending on the effect. ' . l('Follow this link to see examples of each effect.', 'http://jquery.malsup.com/cycle/browser.html', array('attributes' =&gt; array('target' =&gt; '_blank')))),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_slideshow_type_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_slideshow_type_form" value="/**&#10; * Implements hook_views_slideshow_slideshow_type_form().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_slideshow_type_form(&amp;$form, &amp;$form_state, &amp;$view) {&#10;  $form['views_slideshow_cycle']['effect'] = array(&#10;    '#type' =&gt; 'select',&#10;    '#title' =&gt; t('Effect'),&#10;    '#options' =&gt; $effects,&#10;    '#default_value' =&gt; $view-&gt;options['views_slideshow_cycle']['effect'],&#10;    '#description' =&gt; t('The transition effect that will be used to change between images. Not all options below may be relevant depending on the effect. ' . l('Follow this link to see examples of each effect.', 'http://jquery.malsup.com/cycle/browser.html', array('attributes' =&gt; array('target' =&gt; '_blank')))),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_slideshow_type_form" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_option_definition" value="/**&#10; * Implements hook_views_slideshow_option_definition().&#10; *&#10; * Set default values for your form fields specified in hook_views_slideshow_type_form&#10; *&#10; * @return&#10; *  Associative array of slideshow type name and options.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_option_definition() {&#10;  $options['views_slideshow_cycle'] = array(&#10;    'contains' =&gt; array(&#10;      // Transition&#10;      'effect' =&gt; array('default' =&gt; 'fade'),&#10;      'transition_advanced' =&gt; array('default' =&gt; 0),&#10;      'timeout' =&gt; array('default' =&gt; 5000),&#10;      'speed' =&gt; array('default' =&gt; 700), //normal&#10;      'delay' =&gt; array('default' =&gt; 0),&#10;      'sync' =&gt; array('default' =&gt; 1),&#10;      'random' =&gt; array('default' =&gt; 0),&#10;    )&#10;  );&#10;  return $options;&#10;  $END$&#10;}" description="hook_views_slideshow_option_definition" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_option_definition" value="/**&#10; * Implements hook_views_slideshow_option_definition().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_option_definition() {&#10;  $options['views_slideshow_cycle'] = array(&#10;    'contains' =&gt; array(&#10;      // Transition&#10;      'effect' =&gt; array('default' =&gt; 'fade'),&#10;      'transition_advanced' =&gt; array('default' =&gt; 0),&#10;      'timeout' =&gt; array('default' =&gt; 5000),&#10;      'speed' =&gt; array('default' =&gt; 700), //normal&#10;      'delay' =&gt; array('default' =&gt; 0),&#10;      'sync' =&gt; array('default' =&gt; 1),&#10;      'random' =&gt; array('default' =&gt; 0),&#10;    )&#10;  );&#10;  return $options;&#10;  $END$&#10;}" description="hook_views_slideshow_option_definition" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_options_form_validate" value="/**&#10; * Implements hook_views_slideshow_options_form_validate().&#10; *&#10; * Form validation callback for the slideshow settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_options_form_validate(&amp;$form, &amp;$form_state, &amp;$view) {&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['speed'])) {&#10;    form_error($form['views_slideshow_cycle']['speed'], t('!setting must be numeric!', array('Speed')));&#10;  }&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['timeout'])) {&#10;    form_error($form['views_slideshow_cycle']['speed'], t('!setting must be numeric!', array('timeout')));&#10;  }&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['remember_slide_days'])) {&#10;    form_error($form['views_slideshow_cycle']['remember_slide_days'], t('!setting must be numeric!', array('Slide days')));&#10;  }&#10;  $END$&#10;}" description="hook_views_slideshow_options_form_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_options_form_validate" value="/**&#10; * Implements hook_views_slideshow_options_form_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_options_form_validate(&amp;$form, &amp;$form_state, &amp;$view) {&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['speed'])) {&#10;    form_error($form['views_slideshow_cycle']['speed'], t('!setting must be numeric!', array('Speed')));&#10;  }&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['timeout'])) {&#10;    form_error($form['views_slideshow_cycle']['speed'], t('!setting must be numeric!', array('timeout')));&#10;  }&#10;  if (!is_numeric($form_state['values']['style_options']['views_slideshow_cycle']['remember_slide_days'])) {&#10;    form_error($form['views_slideshow_cycle']['remember_slide_days'], t('!setting must be numeric!', array('Slide days')));&#10;  }&#10;  $END$&#10;}" description="hook_views_slideshow_options_form_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_options_form_submit" value="/**&#10; * Implements hook_views_slideshow_options_form_submit().&#10; *&#10; * Form submission callback for the slideshow settings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_options_form_submit($form, &amp;$form_state) {&#10;  // Act on option submission.&#10;  $END$&#10;}" description="hook_views_slideshow_options_form_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_options_form_submit" value="/**&#10; * Implements hook_views_slideshow_options_form_submit().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_options_form_submit($form, &amp;$form_state) {&#10;  // Act on option submission.&#10;  $END$&#10;}" description="hook_views_slideshow_options_form_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_skin_info" value="/**&#10; * Implements hook_views_slideshow_skin_info().&#10; *&#10; * Define slideshow skins to be available to the end user.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_skin_info() {&#10;  return array(&#10;    'default' =&gt; array(&#10;      'name' =&gt; t('Default'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_skin_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_skin_info" value="/**&#10; * Implements hook_views_slideshow_skin_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_skin_info() {&#10;  return array(&#10;    'default' =&gt; array(&#10;      'name' =&gt; t('Default'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_skin_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_widget_info" value="/**&#10; * Implements hook_views_slideshow_widget_info().&#10; *&#10; * Define new widgets (pagers, controls, counters).&#10; *&#10; * Available events for accepts and calls&#10; *  - pause&#10; *  - play&#10; *  - nextSlide&#10; *  - previousSlide&#10; *  - goToSlide&#10; *  - transitionBegin&#10; *  - transitionEnd&#10; *&#10; * @return&#10; *  Array keyed by the widget names.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_info() {&#10;  return array(&#10;    'views_slideshow_pager' =&gt; array(&#10;      'name' =&gt; t('Pager'),&#10;      'accepts' =&gt; array(&#10;        'transitionBegin' =&gt; array('required' =&gt; TRUE),&#10;        'goToSlide',&#10;        'previousSlide',&#10;        'nextSlide',&#10;      ),&#10;      'calls' =&gt; array(&#10;        'goToSlide',&#10;        'pause',&#10;        'play',&#10;      ),&#10;    ),&#10;    'views_slideshow_controls' =&gt; array(&#10;      'name' =&gt; t('Controls'),&#10;      'accepts' =&gt; array(&#10;        'pause' =&gt; array('required' =&gt; TRUE),&#10;        'play' =&gt; array('required' =&gt; TRUE),&#10;      ),&#10;      'calls' =&gt; array(&#10;        'nextSlide',&#10;        'pause',&#10;        'play',&#10;        'previousSlide',&#10;      ),&#10;    ),&#10;    'views_slideshow_slide_counter' =&gt; array(&#10;      'name' =&gt; t('Slide Counter'),&#10;      'accepts' =&gt; array(&#10;        'transitionBegin' =&gt; array('required' =&gt; TRUE),&#10;        'goToSlide',&#10;        'previousSlide',&#10;        'nextSlide',&#10;      ),&#10;      'calls' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_widget_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_widget_info" value="/**&#10; * Implements hook_views_slideshow_widget_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_info() {&#10;  return array(&#10;    'views_slideshow_pager' =&gt; array(&#10;      'name' =&gt; t('Pager'),&#10;      'accepts' =&gt; array(&#10;        'transitionBegin' =&gt; array('required' =&gt; TRUE),&#10;        'goToSlide',&#10;        'previousSlide',&#10;        'nextSlide',&#10;      ),&#10;      'calls' =&gt; array(&#10;        'goToSlide',&#10;        'pause',&#10;        'play',&#10;      ),&#10;    ),&#10;    'views_slideshow_controls' =&gt; array(&#10;      'name' =&gt; t('Controls'),&#10;      'accepts' =&gt; array(&#10;        'pause' =&gt; array('required' =&gt; TRUE),&#10;        'play' =&gt; array('required' =&gt; TRUE),&#10;      ),&#10;      'calls' =&gt; array(&#10;        'nextSlide',&#10;        'pause',&#10;        'play',&#10;        'previousSlide',&#10;      ),&#10;    ),&#10;    'views_slideshow_slide_counter' =&gt; array(&#10;      'name' =&gt; t('Slide Counter'),&#10;      'accepts' =&gt; array(&#10;        'transitionBegin' =&gt; array('required' =&gt; TRUE),&#10;        'goToSlide',&#10;        'previousSlide',&#10;        'nextSlide',&#10;      ),&#10;      'calls' =&gt; array(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_views_slideshow_widget_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_widget_pager_info" value="/**&#10; * Implements hook_views_slideshow_widget_pager_info().&#10; *&#10; * Hook called by the pager widget to configure it, the fields that should be shown.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_pager_info($view) {&#10;  $END$&#10;}" description="hook_views_slideshow_widget_pager_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_widget_pager_info" value="/**&#10; * Implements hook_views_slideshow_widget_pager_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_pager_info($view) {&#10;  $END$&#10;}" description="hook_views_slideshow_widget_pager_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_slideshow_widget_controls_info" value="/**&#10; * Implements hook_views_slideshow_widget_controls_info().&#10; *&#10; * Hook called by the controls widget to configure it, the fields that should be shown.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_controls_info($view) {&#10;  $END$&#10;}" description="hook_views_slideshow_widget_controls_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_slideshow_widget_controls_info" value="/**&#10; * Implements hook_views_slideshow_widget_controls_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_slideshow_widget_controls_info($view) {&#10;  $END$&#10;}" description="hook_views_slideshow_widget_controls_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_access_explain" value="/**&#10; * Implements hook_node_access_explain().&#10; *&#10; * Explain your records in the {node_access} table.&#10; *&#10; * In order to help developers and administrators understand the forces&#10; * that control access to any given node, the DNA module provides the&#10; * Devel Node Access block, which lists all the grant records in the&#10; * {node_access} table for that node.&#10; *&#10; * However, every Node Access module is free in how it defines and uses the&#10; * 'realm' and 'gid' fields in its records in the {node_access} table, and&#10; * it's often difficult to interpret them. This hook passes each record&#10; * that DNA wants to display, and the owning module is expected to return&#10; * an explanation of that record.&#10; *&#10; * The explanation should not be localized (not be passed through t()), so&#10; * that administrators seeking help can present English explanations.&#10; *&#10; * @param $row&#10; *   The record from the {node_access} table, as object. The member fields are:&#10; *   nid, gid, realm, grant_view, grant_update, grant_delete.&#10; *&#10; * @return&#10; *   A string with a (short!) explanation of the given {node_access} row,&#10; *   to be displayed in DNA's 'Devel Node Access' block. It will be displayed&#10; *   as HTML; any variable parts must already be sanitized.&#10; *&#10; * @see hook_node_access_records()&#10; * @see devel_node_access_node_access_explain()&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_explain($row) {&#10;  if ($row-&gt;realm == 'mymodule_myrealm') {&#10;    if ($row-&gt;grant_view) {&#10;      $role = user_role_load($row-&gt;gid);&#10;      return 'Role ' . drupal_placeholder($role-&gt;name) . ' may view this node.';&#10;    }&#10;    else {&#10;      return 'No access.';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_access_explain" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_access_explain" value="/**&#10; * Implements hook_node_access_explain().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_explain($row) {&#10;  if ($row-&gt;realm == 'mymodule_myrealm') {&#10;    if ($row-&gt;grant_view) {&#10;      $role = user_role_load($row-&gt;gid);&#10;      return 'Role ' . drupal_placeholder($role-&gt;name) . ' may view this node.';&#10;    }&#10;    else {&#10;      return 'No access.';&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_node_access_explain" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_node_access_acknowledge" value="/**&#10; * Implements hook_node_access_acknowledge().&#10; *&#10; * Acknowledge ownership of 'alien' grant records.&#10; *&#10; * Some node access modules store grant records directly into the {node_access}&#10; * table rather than returning them through hook_node_access_records(). This&#10; * practice is not recommended and DNA will flag all such records as 'alien'.&#10; *&#10; * If this is unavoidable, a module can confess to being the owner of these&#10; * grant records, so that DNA can properly attribute them.&#10; *&#10; * @see hook_node_access_records()&#10; *&#10; * @ingroup node_access&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_acknowledge($grant) {&#10;  if ($grant['realm'] == 'mymodule_all' &amp;&amp; $grant['nid'] == 0) {&#10;    return TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_node_access_acknowledge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_node_access_acknowledge" value="/**&#10; * Implements hook_node_access_acknowledge().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_node_access_acknowledge($grant) {&#10;  if ($grant['realm'] == 'mymodule_all' &amp;&amp; $grant['nid'] == 0) {&#10;    return TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_node_access_acknowledge" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_votingapi_results_alter" value="/**&#10; * Implements hook_votingapi_results_alter().&#10; *&#10; * Adds to or changes the calculated vote results for a piece of content.&#10; *&#10; * VotingAPI calculates a number of common aggregate functions automatically,&#10; * including the average vote and total number of votes cast. Results are grouped&#10; * by 'tag', 'value_type', and then 'function' in the following format:&#10; *&#10; *   $results[$tag][$value_type][$aggregate_function] = $value;&#10; *&#10; * If no custom tag is being used for votes, the catch-all &quot;vote&quot; tag should be&#10; * used. In cases where custom tags are used to vote on different aspects of a&#10; * piece of content, a catch-all &quot;vote&quot; value should still be calculated for use&#10; * on summary screens, etc.&#10; *&#10; * @param $vote_results&#10; *   An alterable array of aggregate vote results.&#10; * @param $content_type&#10; *   A string identifying the type of content being rated. Node, comment,&#10; *   aggregator item, etc.&#10; * @param $content_id&#10; *   The key ID of the content being rated.&#10; *&#10; * @see votingapi_recalculate_results()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_results_alter(&amp;$vote_results, $content_type, $content_id) {&#10;  // We're using a MySQLism (STDDEV isn't ANSI SQL), but it's OK because this is&#10;  // an example. And no one would ever base real code on sample code. Ever. Never.&#10;&#10;  $sql  = &quot;SELECT v.tag, STDDEV(v.value) as standard_deviation &quot;;&#10;  $sql .= &quot;FROM {votingapi_vote} v &quot;;&#10;  $sql .= &quot;WHERE v.content_type = '%s' AND v.content_id = %d AND v.value_type = 'percent' &quot;;&#10;  $sql .= &quot;GROUP BY v.tag&quot;;&#10;&#10;  $aggregates = db_query($sql, $content_type, $content_id);&#10;&#10;  // VotingAPI wants the data in the following format:&#10;  // $vote_results[$tag][$value_type][$aggregate_function] = $value;&#10;&#10;  while ($aggregate = db_fetch_array($aggregates)) {&#10;    $vote_results[$result['tag']]['percent']['standard_deviation'] = $result['standard_deviation'];&#10;  }&#10;  $END$&#10;}" description="hook_votingapi_results_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_votingapi_results_alter" value="/**&#10; * Implements hook_votingapi_results_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_results_alter(&amp;$vote_results, $content_type, $content_id) {&#10;  // We're using a MySQLism (STDDEV isn't ANSI SQL), but it's OK because this is&#10;  // an example. And no one would ever base real code on sample code. Ever. Never.&#10;&#10;  $sql  = &quot;SELECT v.tag, STDDEV(v.value) as standard_deviation &quot;;&#10;  $sql .= &quot;FROM {votingapi_vote} v &quot;;&#10;  $sql .= &quot;WHERE v.content_type = '%s' AND v.content_id = %d AND v.value_type = 'percent' &quot;;&#10;  $sql .= &quot;GROUP BY v.tag&quot;;&#10;&#10;  $aggregates = db_query($sql, $content_type, $content_id);&#10;&#10;  // VotingAPI wants the data in the following format:&#10;  // $vote_results[$tag][$value_type][$aggregate_function] = $value;&#10;&#10;  while ($aggregate = db_fetch_array($aggregates)) {&#10;    $vote_results[$result['tag']]['percent']['standard_deviation'] = $result['standard_deviation'];&#10;  }&#10;  $END$&#10;}" description="hook_votingapi_results_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_votingapi_metadata_alter" value="/**&#10; * Implements hook_votingapi_metadata_alter().&#10; *&#10; * Adds to or alters metadata describing Voting tags, value_types, and functions.&#10; *&#10; * If your module uses custom tags or value_types, or calculates custom aggregate&#10; * functions, please implement this hook so other modules can properly interperet&#10; * and display your data.&#10; *&#10; * Three major bins of data are stored: tags, value_types, and aggregate result&#10; * functions. Each entry in these bins is keyed by the value stored in the actual&#10; * VotingAPI tables, and contains an array with (minimally) 'name' and&#10; * 'description' keys. Modules can add extra keys to their entries if desired.&#10; *&#10; * @param $data&#10; *   An alterable array of aggregate vote results.&#10; *&#10; * @see votingapi_metadata()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_metadata_alter(&amp;$data) {&#10;  // Document several custom tags for rating restaurants and meals.&#10;  $data['tags']['bread'] = array(&#10;    'name' =&gt; t('Bread'),&#10;    'description' =&gt; t('The quality of the food at a restaurant.'),&#10;    'module' =&gt; 'mymodule', // This is optional; we can add it for our own purposes.&#10;  );&#10;  $data['tags']['circuses'] = array(&#10;    'name' =&gt; t('Circuses'),&#10;    'description' =&gt; t('The quality of the presentation and atmosphere at a restaurant.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;&#10;  // Document two custom aggregate function.&#10;  $data['functions']['standard_deviation'] = array(&#10;    'name' =&gt; t('Standard deviation'),&#10;    'description' =&gt; t('The standard deviation of all votes cast on a given piece of content. Use this to find controversial content.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;  $data['functions']['median'] = array(&#10;    'name' =&gt; t('Median vote'),&#10;    'description' =&gt; t('The median vote value cast on a given piece of content. More accurate than a pure average when there are a few outlying votes.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;  $END$&#10;}" description="hook_votingapi_metadata_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_votingapi_metadata_alter" value="/**&#10; * Implements hook_votingapi_metadata_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_metadata_alter(&amp;$data) {&#10;  // Document several custom tags for rating restaurants and meals.&#10;  $data['tags']['bread'] = array(&#10;    'name' =&gt; t('Bread'),&#10;    'description' =&gt; t('The quality of the food at a restaurant.'),&#10;    'module' =&gt; 'mymodule', // This is optional; we can add it for our own purposes.&#10;  );&#10;  $data['tags']['circuses'] = array(&#10;    'name' =&gt; t('Circuses'),&#10;    'description' =&gt; t('The quality of the presentation and atmosphere at a restaurant.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;&#10;  // Document two custom aggregate function.&#10;  $data['functions']['standard_deviation'] = array(&#10;    'name' =&gt; t('Standard deviation'),&#10;    'description' =&gt; t('The standard deviation of all votes cast on a given piece of content. Use this to find controversial content.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;  $data['functions']['median'] = array(&#10;    'name' =&gt; t('Median vote'),&#10;    'description' =&gt; t('The median vote value cast on a given piece of content. More accurate than a pure average when there are a few outlying votes.'),&#10;    'module' =&gt; 'mymodule',&#10;  );&#10;  $END$&#10;}" description="hook_votingapi_metadata_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_votingapi_relationships" value="/**&#10; * Implements hook_votingapi_relationships().&#10; *&#10; * Return metadata used to build Views relationships on voting data.&#10; *&#10; * VotingAPI can store votes on any entity in the Drupal database: its content_type&#10; * and content_id columns can be used to store &quot;node&quot;/1, &quot;comment&quot;/2, and so&#10; * on. This hook is used to tell VotingAPI what Views base table the content_type&#10; * field corresponds to, and what field in that base table contains the value in&#10; * votingapi's content_id table.&#10; *&#10; * @return&#10; *   An array of records containing 'description', 'content_type', 'base_table',&#10; *   and 'content_id_column' entries.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_relationships() {&#10;  $relationships[] = array(&#10;    // 'description' is used to construct the field description in the Views UI.&#10;    'description' =&gt; t('users'),&#10;&#10;    // 'content_type' contain the value that your module stores in the voting&#10;    // api 'content_type' column. 'node', 'comment', etc.&#10;    'content_type' =&gt; 'user',&#10;&#10;    // 'base_table' contain the name of the Views base table that stores the&#10;    // data your votes apply to.&#10;    'base_table' =&gt; 'user',&#10;&#10;    // 'content_id_column' contains the name of the views field that represents&#10;    // your base_table's primary key. This column will be joined against the&#10;    // voting api 'content_id' column.&#10;    'content_id_column' =&gt; 'uid',&#10;&#10;    // VotingAPI constructs pseudo-tables so that multiple relationships can&#10;    // point to the same base table (normal and translation-based votes nodes&#10;    // for example. These two columns allow you to override the names of the&#10;    // pseudo-tables. You probably don't need to change this part unless you're&#10;    // nedjo.&#10;    'pseudo_vote' =&gt; 'votingapi_vote_special',&#10;    'pseudo_cache' =&gt; 'votingapi_cache_special',&#10;  );&#10;  $END$&#10;}" description="hook_votingapi_relationships" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_votingapi_relationships" value="/**&#10; * Implements hook_votingapi_relationships().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_relationships() {&#10;  $relationships[] = array(&#10;    // 'description' is used to construct the field description in the Views UI.&#10;    'description' =&gt; t('users'),&#10;&#10;    // 'content_type' contain the value that your module stores in the voting&#10;    // api 'content_type' column. 'node', 'comment', etc.&#10;    'content_type' =&gt; 'user',&#10;&#10;    // 'base_table' contain the name of the Views base table that stores the&#10;    // data your votes apply to.&#10;    'base_table' =&gt; 'user',&#10;&#10;    // 'content_id_column' contains the name of the views field that represents&#10;    // your base_table's primary key. This column will be joined against the&#10;    // voting api 'content_id' column.&#10;    'content_id_column' =&gt; 'uid',&#10;&#10;    // VotingAPI constructs pseudo-tables so that multiple relationships can&#10;    // point to the same base table (normal and translation-based votes nodes&#10;    // for example. These two columns allow you to override the names of the&#10;    // pseudo-tables. You probably don't need to change this part unless you're&#10;    // nedjo.&#10;    'pseudo_vote' =&gt; 'votingapi_vote_special',&#10;    'pseudo_cache' =&gt; 'votingapi_cache_special',&#10;  );&#10;  $END$&#10;}" description="hook_votingapi_relationships" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_votingapi_views_formatters" value="/**&#10; * Implements hook_votingapi_views_formatters().&#10; *&#10; * Returns callback functions and descriptions to format a VotingAPI Views field.&#10; *&#10; * Loads all votes for a given piece of content, then calculates and caches the&#10; * aggregate vote results. This is only intended for modules that have assumed&#10; * responsibility for the full voting cycle: the votingapi_set_vote() function&#10; * recalculates automatically.&#10; *&#10; * @param $field&#10; *   A Views field object. This can be used to expose formatters only for tags,&#10; *   vote values, aggregate functions, etc.&#10; * @return&#10; *   An array of key-value pairs, in which each key is a callback function and&#10; *   each value is a human-readable description of the formatter.&#10; *&#10; * @see votingapi_set_votes()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_views_formatters($field) {&#10;  if ($field-&gt;field == 'value') {&#10;    return array('mymodule_funky_formatter' =&gt; t('MyModule value formatter'));&#10;  }&#10;  if ($field-&gt;field == 'tag') {&#10;    return array('mymodule_funky_tags' =&gt; t('MyModule tag formatter'));&#10;  }&#10;  $END$&#10;}" description="hook_votingapi_views_formatters" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_votingapi_views_formatters" value="/**&#10; * Implements hook_votingapi_views_formatters().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_votingapi_views_formatters($field) {&#10;  if ($field-&gt;field == 'value') {&#10;    return array('mymodule_funky_formatter' =&gt; t('MyModule value formatter'));&#10;  }&#10;  if ($field-&gt;field == 'tag') {&#10;    return array('mymodule_funky_tags' =&gt; t('MyModule tag formatter'));&#10;  }&#10;  $END$&#10;}" description="hook_votingapi_views_formatters" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_wysiwyg_plugin" value="/**&#10; * Implements hook_wysiwyg_plugin().&#10; *&#10; * Return an array of native editor plugins.&#10; *&#10; * Only to be used for native (internal) editor plugins.&#10; *&#10; * @see hook_wysiwyg_include_directory()&#10; *&#10; * @param $editor&#10; *   The internal name of the currently processed editor.&#10; * @param $version&#10; *   The version of the currently processed editor.&#10; *&#10; * @return&#10; *   An associative array having internal plugin names as keys and an array of&#10; *   plugin meta-information as values.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_plugin($editor, $version) {&#10;  switch ($editor) {&#10;    case 'tinymce':&#10;      if ($version &gt; 3) {&#10;        return array(&#10;          'myplugin' =&gt; array(&#10;            // A URL to the plugin's homepage.&#10;            'url' =&gt; 'http://drupal.org/project/img_assist',&#10;            // The full path to the native editor plugin, no trailing slash.&#10;            // Ignored when 'internal' is set to TRUE below.&#10;            'path' =&gt; drupal_get_path('module', 'img_assist') . '/drupalimage',&#10;            // The name of the plugin's main JavaScript file.&#10;            // Ignored when 'internal' is set to TRUE below.&#10;            // Default value depends on which editor the plugin is for.&#10;            'filename' =&gt; 'editor_plugin.js',&#10;            // A list of buttons provided by this native plugin. The key has to&#10;            // match the corresponding JavaScript implementation. The value is&#10;            // is displayed on the editor configuration form only.&#10;            'buttons' =&gt; array(&#10;              'img_assist' =&gt; t('Image Assist'),&#10;            ),&#10;            // A list of editor extensions provided by this native plugin.&#10;            // Extensions are not displayed as buttons and touch the editor's&#10;            // internals, so you should know what you are doing.&#10;            'extensions' =&gt; array(&#10;              'imce' =&gt; t('IMCE'),&#10;            ),&#10;            // A list of global, native editor configuration settings to&#10;            // override. To be used rarely and only when required.&#10;            'options' =&gt; array(&#10;              'file_browser_callback' =&gt; 'imceImageBrowser',&#10;              'inline_styles' =&gt; TRUE,&#10;            ),&#10;            // Boolean whether the editor needs to load this plugin. When TRUE,&#10;            // the editor will automatically load the plugin based on the 'path'&#10;            // variable provided. If FALSE, the plugin either does not need to&#10;            // be loaded or is already loaded by something else on the page.&#10;            // Most plugins should define TRUE here.&#10;            'load' =&gt; TRUE,&#10;            // Boolean whether this plugin is a native plugin, i.e. shipped with&#10;            // the editor. Definition must be ommitted for plugins provided by&#10;            // other modules. TRUE means 'path' and 'filename' above are ignored&#10;            // and the plugin is instead loaded from the editor's plugin folder.&#10;            'internal' =&gt; TRUE,&#10;            // TinyMCE-specific: Additional HTML elements to allow in the markup.&#10;            'extended_valid_elements' =&gt; array(&#10;              'img[class|src|border=0|alt|title|width|height|align|name|style]',&#10;            ),&#10;          ),&#10;        );&#10;      }&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_plugin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_wysiwyg_plugin" value="/**&#10; * Implements hook_wysiwyg_plugin().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_plugin($editor, $version) {&#10;  switch ($editor) {&#10;    case 'tinymce':&#10;      if ($version &gt; 3) {&#10;        return array(&#10;          'myplugin' =&gt; array(&#10;            // A URL to the plugin's homepage.&#10;            'url' =&gt; 'http://drupal.org/project/img_assist',&#10;            // The full path to the native editor plugin, no trailing slash.&#10;            // Ignored when 'internal' is set to TRUE below.&#10;            'path' =&gt; drupal_get_path('module', 'img_assist') . '/drupalimage',&#10;            // The name of the plugin's main JavaScript file.&#10;            // Ignored when 'internal' is set to TRUE below.&#10;            // Default value depends on which editor the plugin is for.&#10;            'filename' =&gt; 'editor_plugin.js',&#10;            // A list of buttons provided by this native plugin. The key has to&#10;            // match the corresponding JavaScript implementation. The value is&#10;            // is displayed on the editor configuration form only.&#10;            'buttons' =&gt; array(&#10;              'img_assist' =&gt; t('Image Assist'),&#10;            ),&#10;            // A list of editor extensions provided by this native plugin.&#10;            // Extensions are not displayed as buttons and touch the editor's&#10;            // internals, so you should know what you are doing.&#10;            'extensions' =&gt; array(&#10;              'imce' =&gt; t('IMCE'),&#10;            ),&#10;            // A list of global, native editor configuration settings to&#10;            // override. To be used rarely and only when required.&#10;            'options' =&gt; array(&#10;              'file_browser_callback' =&gt; 'imceImageBrowser',&#10;              'inline_styles' =&gt; TRUE,&#10;            ),&#10;            // Boolean whether the editor needs to load this plugin. When TRUE,&#10;            // the editor will automatically load the plugin based on the 'path'&#10;            // variable provided. If FALSE, the plugin either does not need to&#10;            // be loaded or is already loaded by something else on the page.&#10;            // Most plugins should define TRUE here.&#10;            'load' =&gt; TRUE,&#10;            // Boolean whether this plugin is a native plugin, i.e. shipped with&#10;            // the editor. Definition must be ommitted for plugins provided by&#10;            // other modules. TRUE means 'path' and 'filename' above are ignored&#10;            // and the plugin is instead loaded from the editor's plugin folder.&#10;            'internal' =&gt; TRUE,&#10;            // TinyMCE-specific: Additional HTML elements to allow in the markup.&#10;            'extended_valid_elements' =&gt; array(&#10;              'img[class|src|border=0|alt|title|width|height|align|name|style]',&#10;            ),&#10;          ),&#10;        );&#10;      }&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_plugin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_wysiwyg_include_directory" value="/**&#10; * Implements hook_wysiwyg_include_directory().&#10; *&#10; * Register a directory containing Wysiwyg plugins.&#10; *&#10; * @param $type&#10; *   The type of objects being collected: either 'plugins' or 'editors'.&#10; * @return&#10; *   A sub-directory of the implementing module that contains the corresponding&#10; *   plugin files. This directory must only contain integration files for&#10; *   Wysiwyg module.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_include_directory($type) {&#10;  switch ($type) {&#10;    case 'plugins':&#10;      // You can just return $type, if you place your Wysiwyg plugins into a&#10;      // sub-directory named 'plugins'.&#10;      return $type;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_include_directory" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_wysiwyg_include_directory" value="/**&#10; * Implements hook_wysiwyg_include_directory().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_include_directory($type) {&#10;  switch ($type) {&#10;    case 'plugins':&#10;      // You can just return $type, if you place your Wysiwyg plugins into a&#10;      // sub-directory named 'plugins'.&#10;      return $type;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_include_directory" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_INCLUDE_plugin" value="/**&#10; * Implements hook_INCLUDE_plugin().&#10; *&#10; * Define a Wysiwyg plugin.&#10; *&#10; * Supposed to be used for &quot;Drupal plugins&quot; (cross-editor plugins) only.&#10; *&#10; * @see hook_wysiwyg_plugin()&#10; *&#10; * Each plugin file in the specified plugin directory of a module needs to&#10; * define meta information about the particular plugin provided.&#10; * The plugin's hook implementation function name is built out of the following:&#10; * - 'hook': The name of the module providing the plugin.&#10; * - 'INCLUDE': The basename of the file containing the plugin definition.&#10; * - 'plugin': Static.&#10; *&#10; * For example, if your module's name is 'mymodule' and&#10; * mymodule_wysiwyg_include_directory() returned 'plugins' as plugin directory,&#10; * and this directory contains an &quot;awesome&quot; plugin file named 'awesome.inc', i.e.&#10; *   sites/all/modules/mymodule/plugins/awesome.inc&#10; * then the corresponding plugin hook function name is:&#10; *   mymodule_awesome_plugin()&#10; *&#10; * @see hook_wysiwyg_include_directory()&#10; *&#10; * @return&#10; *   Meta information about the buttons provided by this plugin.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_INCLUDE_plugin() {&#10;  $plugins['awesome'] = array(&#10;    // The plugin's title; defaulting to its internal name ('awesome').&#10;    'title' =&gt; t('Awesome plugin'),&#10;    // The (vendor) homepage of this plugin; defaults to ''.&#10;    'vendor url' =&gt; 'http://drupal.org/project/wysiwyg',&#10;    // The path to the button's icon; defaults to&#10;    // '/[path-to-module]/[plugins-directory]/[plugin-name]/images'.&#10;    'icon path' =&gt; 'path to icon',&#10;    // The button image filename; defaults to '[plugin-name].png'.&#10;    'icon file' =&gt; 'name of the icon file with extension',&#10;    // The button title to display on hover.&#10;    'icon title' =&gt; t('Do something'),&#10;    // An alternative path to the integration JavaScript; defaults to&#10;    // '[path-to-module]/[plugins-directory]/[plugin-name]'.&#10;    'js path' =&gt; drupal_get_path('module', 'mymodule') . '/awesomeness',&#10;    // An alternative filename of the integration JavaScript; defaults to&#10;    // '[plugin-name].js'.&#10;    'js file' =&gt; 'awesome.js',&#10;    // An alternative path to the integration stylesheet; defaults to&#10;    // '[path-to-module]/[plugins-directory]/[plugin-name]'.&#10;    'css path' =&gt; drupal_get_path('module', 'mymodule') . '/awesomeness',&#10;    // An alternative filename of the integration stylesheet; defaults to&#10;    // '[plugin-name].css'.&#10;    'css file' =&gt; 'awesome.css',&#10;    // An array of settings for this button. Required, but API is still in flux.&#10;    'settings' =&gt; array(&#10;    ),&#10;    // TinyMCE-specific: Additional HTML elements to allow in the markup.&#10;    'extended_valid_elements' =&gt; array(&#10;      'tag1[attribute1|attribute2]',&#10;      'tag2[attribute3|attribute4]',&#10;    ),&#10;  );&#10;  return $plugins;&#10;  $END$&#10;}" description="hook_INCLUDE_plugin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_INCLUDE_plugin" value="/**&#10; * Implements hook_INCLUDE_plugin().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_INCLUDE_plugin() {&#10;  $plugins['awesome'] = array(&#10;    // The plugin's title; defaulting to its internal name ('awesome').&#10;    'title' =&gt; t('Awesome plugin'),&#10;    // The (vendor) homepage of this plugin; defaults to ''.&#10;    'vendor url' =&gt; 'http://drupal.org/project/wysiwyg',&#10;    // The path to the button's icon; defaults to&#10;    // '/[path-to-module]/[plugins-directory]/[plugin-name]/images'.&#10;    'icon path' =&gt; 'path to icon',&#10;    // The button image filename; defaults to '[plugin-name].png'.&#10;    'icon file' =&gt; 'name of the icon file with extension',&#10;    // The button title to display on hover.&#10;    'icon title' =&gt; t('Do something'),&#10;    // An alternative path to the integration JavaScript; defaults to&#10;    // '[path-to-module]/[plugins-directory]/[plugin-name]'.&#10;    'js path' =&gt; drupal_get_path('module', 'mymodule') . '/awesomeness',&#10;    // An alternative filename of the integration JavaScript; defaults to&#10;    // '[plugin-name].js'.&#10;    'js file' =&gt; 'awesome.js',&#10;    // An alternative path to the integration stylesheet; defaults to&#10;    // '[path-to-module]/[plugins-directory]/[plugin-name]'.&#10;    'css path' =&gt; drupal_get_path('module', 'mymodule') . '/awesomeness',&#10;    // An alternative filename of the integration stylesheet; defaults to&#10;    // '[plugin-name].css'.&#10;    'css file' =&gt; 'awesome.css',&#10;    // An array of settings for this button. Required, but API is still in flux.&#10;    'settings' =&gt; array(&#10;    ),&#10;    // TinyMCE-specific: Additional HTML elements to allow in the markup.&#10;    'extended_valid_elements' =&gt; array(&#10;      'tag1[attribute1|attribute2]',&#10;      'tag2[attribute3|attribute4]',&#10;    ),&#10;  );&#10;  return $plugins;&#10;  $END$&#10;}" description="hook_INCLUDE_plugin" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_wysiwyg_editor_settings_alter" value="/**&#10; * Implements hook_wysiwyg_editor_settings_alter().&#10; *&#10; * Act on editor profile settings.&#10; *&#10; * This hook is invoked from wysiwyg_get_editor_config() after the JavaScript&#10; * settings have been generated for an editor profile and before the settings&#10; * are added to the page. The settings may be customized or enhanced; typically&#10; * with options that cannot be controlled through Wysiwyg module's&#10; * administrative UI currently.&#10; *&#10; * Modules implementing this hook to enforce settings that can also be&#10; * controlled through the UI should also implement&#10; * hook_form_wysiwyg_profile_form_alter() to adjust or at least indicate on the&#10; * editor profile configuration form that certain/affected settings cannot be&#10; * changed.&#10; *&#10; * @param $settings&#10; *   An associative array of JavaScript settings to pass to the editor.&#10; * @param $context&#10; *   An associative array containing additional context information:&#10; *   - editor: The plugin definition array of the editor.&#10; *   - profile: The editor profile object, as loaded from the database.&#10; *   - theme: The name of the editor theme/skin.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_editor_settings_alter(&amp;$settings, $context) {&#10;  // Each editor has its own collection of native settings that may be extended&#10;  // or overridden. Please consult the respective official vendor documentation&#10;  // for details.&#10;  if ($context['profile']-&gt;editor == 'tinymce') {&#10;    // Supported values to JSON data types.&#10;    $settings['cleanup_on_startup'] = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_editor_settings_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_wysiwyg_editor_settings_alter" value="/**&#10; * Implements hook_wysiwyg_editor_settings_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_wysiwyg_editor_settings_alter(&amp;$settings, $context) {&#10;  // Each editor has its own collection of native settings that may be extended&#10;  // or overridden. Please consult the respective official vendor documentation&#10;  // for details.&#10;  if ($context['profile']-&gt;editor == 'tinymce') {&#10;    // Supported values to JSON data types.&#10;    $settings['cleanup_on_startup'] = TRUE;&#10;  }&#10;  $END$&#10;}" description="hook_wysiwyg_editor_settings_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ctools_plugin_directory" value="/**&#10; * Implements hook_ctools_plugin_directory().&#10; *&#10; * This hook is used to inform the CTools plugin system about the location of a&#10; * directory that should be searched for files containing plugins of a&#10; * particular type. CTools invokes this same hook for all plugins, using the&#10; * two passed parameters to indicate the specific type of plugin for which it&#10; * is searching.&#10; *&#10; * The $plugin_type parameter is self-explanatory - it is the string name of the&#10; * plugin type (e.g., Panels' 'layouts' or 'styles'). The $owner parameter is&#10; * necessary because CTools internally namespaces plugins by the module that&#10; * owns them. This is an extension of Drupal best practices on avoiding global&#10; * namespace pollution by prepending your module name to all its functions.&#10; * Consequently, it is possible for two different modules to create a plugin&#10; * type with exactly the same name and have them operate in harmony. In fact,&#10; * this system renders it impossible for modules to encroach on other modules'&#10; * plugin namespaces.&#10; *&#10; * Given this namespacing, it is important that implementations of this hook&#10; * check BOTH the $owner and $plugin_type parameters before returning a path.&#10; * If your module does not implement plugins for the requested module/plugin&#10; * combination, it is safe to return nothing at all (or NULL). As a convenience,&#10; * it is also safe to return a path that does not exist for plugins your module&#10; * does not implement - see form 2 for a use case.&#10; *&#10; * Note that modules implementing a plugin also must implement this hook to&#10; * instruct CTools as to the location of the plugins. See form 3 for a use case.&#10; *&#10; * The conventional structure to return is &quot;plugins/$plugin_type&quot; - that is, a&#10; * 'plugins' subdirectory in your main module directory, with individual&#10; * directories contained therein named for the plugin type they contain.&#10; *&#10; * @param string $owner&#10; *   The system name of the module owning the plugin type for which a base&#10; *   directory location is being requested.&#10; * @param string $plugin_type&#10; *   The name of the plugin type for which a base directory is being requested.&#10; * @return string&#10; *   The path where CTools' plugin system should search for plugin files,&#10; *   relative to your module's root. Omit leading and trailing slashes.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_directory($owner, $plugin_type) {&#10;  // Form 1 - for a module implementing only the 'content_types' plugin owned&#10;  // by CTools, this would cause the plugin system to search the&#10;  // &lt;moduleroot&gt;/plugins/content_types directory for .inc plugin files.&#10;  if ($owner == 'ctools' &amp;&amp; $plugin_type == 'content_types') {&#10;    return 'plugins/content_types';&#10;  }&#10;&#10;  // Form 2 - if your module implements only Panels plugins, and has 'layouts'&#10;  // and 'styles' plugins but no 'cache' or 'display_renderers', it is OK to be&#10;  // lazy and return a directory for a plugin you don't actually implement (so&#10;  // long as that directory doesn't exist). This lets you avoid ugly in_array()&#10;  // logic in your conditional, and also makes it easy to add plugins of those&#10;  // types later without having to change this hook implementation.&#10;  if ($owner == 'panels') {&#10;    return &quot;plugins/$plugin_type&quot;;&#10;  }&#10;&#10;  // Form 3 - CTools makes no assumptions about where your plugins are located,&#10;  // so you still have to implement this hook even for plugins created by your&#10;  // own module.&#10;  if ($owner == 'mymodule') {&#10;    // Yes, this is exactly like Form 2 - just a different reasoning for it.&#10;    return &quot;plugins/$plugin_type&quot;;&#10;  }&#10;  // Finally, if nothing matches, it's safe to return nothing at all (or NULL).&#10;  $END$&#10;}" description="hook_ctools_plugin_directory" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ctools_plugin_directory" value="/**&#10; * Implements hook_ctools_plugin_directory().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_directory($owner, $plugin_type) {&#10;  // Form 1 - for a module implementing only the 'content_types' plugin owned&#10;  // by CTools, this would cause the plugin system to search the&#10;  // &lt;moduleroot&gt;/plugins/content_types directory for .inc plugin files.&#10;  if ($owner == 'ctools' &amp;&amp; $plugin_type == 'content_types') {&#10;    return 'plugins/content_types';&#10;  }&#10;&#10;  // Form 2 - if your module implements only Panels plugins, and has 'layouts'&#10;  // and 'styles' plugins but no 'cache' or 'display_renderers', it is OK to be&#10;  // lazy and return a directory for a plugin you don't actually implement (so&#10;  // long as that directory doesn't exist). This lets you avoid ugly in_array()&#10;  // logic in your conditional, and also makes it easy to add plugins of those&#10;  // types later without having to change this hook implementation.&#10;  if ($owner == 'panels') {&#10;    return &quot;plugins/$plugin_type&quot;;&#10;  }&#10;&#10;  // Form 3 - CTools makes no assumptions about where your plugins are located,&#10;  // so you still have to implement this hook even for plugins created by your&#10;  // own module.&#10;  if ($owner == 'mymodule') {&#10;    // Yes, this is exactly like Form 2 - just a different reasoning for it.&#10;    return &quot;plugins/$plugin_type&quot;;&#10;  }&#10;  // Finally, if nothing matches, it's safe to return nothing at all (or NULL).&#10;  $END$&#10;}" description="hook_ctools_plugin_directory" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ctools_plugin_pre_alter" value="/**&#10; * Implements hook_ctools_plugin_pre_alter().&#10; *&#10; * Alter a plugin before it has been processed.&#10; *&#10; * This hook is useful for altering flags or other information that will be&#10; * used or possibly overriden by the process hook if defined.&#10; *&#10; * @param $plugin&#10; *   An associative array defining a plugin.&#10; * @param $info&#10; *   An associative array of plugin type info.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_pre_alter(&amp;$plugin, &amp;$info) {&#10;  // Override a function defined by the plugin.&#10;  if ($info['type'] == 'my_type') {&#10;    $plugin['my_flag'] = 'new_value';&#10;  }&#10;  $END$&#10;}" description="hook_ctools_plugin_pre_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ctools_plugin_pre_alter" value="/**&#10; * Implements hook_ctools_plugin_pre_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_pre_alter(&amp;$plugin, &amp;$info) {&#10;  // Override a function defined by the plugin.&#10;  if ($info['type'] == 'my_type') {&#10;    $plugin['my_flag'] = 'new_value';&#10;  }&#10;  $END$&#10;}" description="hook_ctools_plugin_pre_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ctools_plugin_post_alter" value="/**&#10; * Implements hook_ctools_plugin_post_alter().&#10; *&#10; * Alter a plugin after it has been processed.&#10; *&#10; * This hook is useful for overriding the final values for a plugin after it&#10; * has been processed.&#10; *&#10; * @param $plugin&#10; *   An associative array defining a plugin.&#10; * @param $info&#10; *   An associative array of plugin type info.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_post_alter(&amp;$plugin, &amp;$info) {&#10;  // Override a function defined by the plugin.&#10;  if ($info['type'] == 'my_type') {&#10;    $plugin['my_function'] = 'new_function';&#10;  }&#10;  $END$&#10;}" description="hook_ctools_plugin_post_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ctools_plugin_post_alter" value="/**&#10; * Implements hook_ctools_plugin_post_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_plugin_post_alter(&amp;$plugin, &amp;$info) {&#10;  // Override a function defined by the plugin.&#10;  if ($info['type'] == 'my_type') {&#10;    $plugin['my_function'] = 'new_function';&#10;  }&#10;  $END$&#10;}" description="hook_ctools_plugin_post_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_ctools_math_expression_functions_alter" value="/**&#10; * Implements hook_ctools_math_expression_functions_alter().&#10; *&#10; * Alter the available functions to be used in ctools math expression api.&#10; *&#10; * One usecase would be to create your own function in your module and &#10; * allow to use it in the math expression api.&#10; *&#10; * @param $functions&#10; *    An array which has the functions as value.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_math_expression_functions_alter(&amp;$functions) {&#10;  // Allow to convert from degrees to radiant.&#10;  $functions[] = 'deg2rad';&#10;  $END$&#10;}" description="hook_ctools_math_expression_functions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_ctools_math_expression_functions_alter" value="/**&#10; * Implements hook_ctools_math_expression_functions_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_ctools_math_expression_functions_alter(&amp;$functions) {&#10;  // Allow to convert from degrees to radiant.&#10;  $functions[] = 'deg2rad';&#10;  $END$&#10;}" description="hook_ctools_math_expression_functions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationship_blocks_get_uid" value="/**&#10; * Implements hook_user_relationship_blocks_get_uid().&#10; *&#10; * Return the user that is currently displayed.&#10; *&#10; * @param $delta&#10; *   The delta of the currently viewed block.&#10; *&#10; * @return&#10; *   The uid of the user currently displayed on this page, if any.&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationship_blocks_get_uid($delta) {&#10;  if (arg(0) == 'mypath') {&#10;    return arg(1);&#10;  }&#10;  $END$&#10;}" description="hook_user_relationship_blocks_get_uid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationship_blocks_get_uid" value="/**&#10; * Implements hook_user_relationship_blocks_get_uid().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationship_blocks_get_uid($delta) {&#10;  if (arg(0) == 'mypath') {&#10;    return arg(1);&#10;  }&#10;  $END$&#10;}" description="hook_user_relationship_blocks_get_uid" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_ui_table_header_alter" value="/**&#10; * Implements hook_user_relationships_ui_table_header_alter().&#10; *&#10; * Alter the table header definition of relationship listings.&#10; *&#10; * @param $header&#10; *   Array with the table header definition.&#10; * @param $edit_access&#10; *   TRUE if the current user has edit access.&#10; *&#10; * @see user_relationships_ui_get_table_header()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_ui_table_header_alter(&amp;$header, $edit_access) {&#10;  $insert_index = array_search(t('Relationship'), $header) + 1;&#10;  $header = array_merge(array_slice($header, 0, $insert_index), array(t('Comments')), array_slice($header, $insert_index));&#10;  $END$&#10;}" description="hook_user_relationships_ui_table_header_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_ui_table_header_alter" value="/**&#10; * Implements hook_user_relationships_ui_table_header_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_ui_table_header_alter(&amp;$header, $edit_access) {&#10;  $insert_index = array_search(t('Relationship'), $header) + 1;&#10;  $header = array_merge(array_slice($header, 0, $insert_index), array(t('Comments')), array_slice($header, $insert_index));&#10;  $END$&#10;}" description="hook_user_relationships_ui_table_header_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_type_load" value="/**&#10; * Implements hook_user_relationships_type_load().&#10; *&#10; * Act when relationship types are loaded.&#10; *&#10; * @param $relationship_types_list&#10; *   A list of relationship types, keyed by rtid.&#10; *&#10; * @see user_relationships_type_load_multiple()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_load($relationship_types_list) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_type_load" value="/**&#10; * Implements hook_user_relationships_type_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_load($relationship_types_list) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_type_presave" value="/**&#10; * Implements hook_user_relationships_type_presave().&#10; *&#10; * This hook is executed before an existing or new relationship type is saved.&#10; *&#10; * @param $relationship_type&#10; *   Relationship type object.&#10; *&#10; * @see user_relationships_type_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_presave($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_type_presave" value="/**&#10; * Implements hook_user_relationships_type_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_presave($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_type_update" value="/**&#10; * Implements hook_user_relationships_type_update().&#10; *&#10; * This hook is executed after an relationship type has been updated.&#10; *&#10; * @param $relationship_type&#10; *   Relationship type object.&#10; *&#10; * @see user_relationships_type_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_update($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_type_update" value="/**&#10; * Implements hook_user_relationships_type_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_update($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_type_insert" value="/**&#10; * Implements hook_user_relationships_type_insert().&#10; *&#10; * This hook is executed after a new relationship type has been inserted.&#10; *&#10; * @param $relationship_type&#10; *   Relationship type object.&#10; *&#10; * @see user_relationships_type_save()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_insert($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_type_insert" value="/**&#10; * Implements hook_user_relationships_type_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_insert($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_type_delete" value="/**&#10; * Implements hook_user_relationships_type_delete().&#10; *&#10; * This hook is executed after a relationship type has been deleted.&#10; *&#10; * @param $relationship_type&#10; *   Relationship type object.&#10; *&#10; * @see user_relationships_type_delete()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_delete($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_type_delete" value="/**&#10; * Implements hook_user_relationships_type_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_type_delete($relationship_type) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_type_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_load" value="/**&#10; * Implements hook_user_relationships_load().&#10; *&#10; * Act when relationships are loaded.&#10; *&#10; * @param $relationship_list&#10; *   Array of relations, keyed by rid.&#10; *&#10; * @see user_relationships_load()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_load($relationship_list) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_load" value="/**&#10; * Implements hook_user_relationships_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_load($relationship_list) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_presave" value="/**&#10; * Implements hook_user_relationships_presave().&#10; *&#10; * This hook is executed before a relationship will be saved.&#10; *&#10; * @param $relationship&#10; *   Relationship object.&#10; *&#10; * @see user_relationships_save_relationship()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_presave($relationship) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_presave" value="/**&#10; * Implements hook_user_relationships_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_presave($relationship) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_save" value="/**&#10; * Implements hook_user_relationships_save().&#10; *&#10; * This hook is executed after a relationship has been updated.&#10; *&#10; * @param $relationship&#10; *   Relationship object.&#10; * @param $action&#10; *   The reason for the update (request, approve, update).&#10; *&#10; * @see user_relationships_save_relationship()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_save($relationship, $action) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_save" value="/**&#10; * Implements hook_user_relationships_save().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_save($relationship, $action) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_save" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_insert" value="/**&#10; * Implements hook_user_relationships_insert().&#10; *&#10; * This hook is executed after a new relationship has been saved.&#10; *&#10; * @param $relationship&#10; *   Relationship object.&#10; *&#10; * @see user_relationships_save_relationship()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_insert($relationship) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_insert" value="/**&#10; * Implements hook_user_relationships_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_insert($relationship) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_delete" value="/**&#10; * Implements hook_user_relationships_delete().&#10; *&#10; * This hook is executed before a relationship will be saved.&#10; *&#10; * @param $relationship&#10; *   Relationship object.&#10; * @param $action&#10; *   String reason for removal ('cancel','disapprove','remove').&#10; *&#10; * @see user_relationships_delete_relationship()&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_delete($relationship, $action) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_delete" value="/**&#10; * Implements hook_user_relationships_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_delete($relationship, $action) {&#10;&#10;  $END$&#10;}" description="hook_user_relationships_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_relationships_types_list_alter" value="/**&#10; * Implements hook_user_relationships_types_list_alter().&#10; *&#10; * Alter the relationship types listing page.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_types_list_alter(&amp;$page) {&#10;  $defaults = user_relationship_defaults_load();&#10;&#10;  $default_rows = array();&#10;  foreach ($defaults as $default) {&#10;    $default_rows[] = array(&#10;      theme('username', array('account' =&gt; $default-&gt;user)),&#10;      $default-&gt;relationship_type-&gt;name,&#10;      l(t('delete'), &quot;admin/config/people/relationships/defaults/{$default-&gt;rdid}/delete&quot;),&#10;    );&#10;  }&#10;&#10;  $page['defaults'] = array(&#10;    '#type'   =&gt; 'fieldset',&#10;    '#title'  =&gt; t('Default Relationships'),&#10;    '#weight' =&gt; 2,&#10;  );&#10;  $page['defaults']['list'] = array(&#10;    '#theme' =&gt; 'table',&#10;    '#header' =&gt; array(t('User'), t('Relationship'), t('Operations')),&#10;    '#rows' =&gt; $default_rows,&#10;    '#empty' =&gt; t('No default relationships available.'),&#10;  );&#10;  $END$&#10;}" description="hook_user_relationships_types_list_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_relationships_types_list_alter" value="/**&#10; * Implements hook_user_relationships_types_list_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_relationships_types_list_alter(&amp;$page) {&#10;  $defaults = user_relationship_defaults_load();&#10;&#10;  $default_rows = array();&#10;  foreach ($defaults as $default) {&#10;    $default_rows[] = array(&#10;      theme('username', array('account' =&gt; $default-&gt;user)),&#10;      $default-&gt;relationship_type-&gt;name,&#10;      l(t('delete'), &quot;admin/config/people/relationships/defaults/{$default-&gt;rdid}/delete&quot;),&#10;    );&#10;  }&#10;&#10;  $page['defaults'] = array(&#10;    '#type'   =&gt; 'fieldset',&#10;    '#title'  =&gt; t('Default Relationships'),&#10;    '#weight' =&gt; 2,&#10;  );&#10;  $page['defaults']['list'] = array(&#10;    '#theme' =&gt; 'table',&#10;    '#header' =&gt; array(t('User'), t('Relationship'), t('Operations')),&#10;    '#rows' =&gt; $default_rows,&#10;    '#empty' =&gt; t('No default relationships available.'),&#10;  );&#10;  $END$&#10;}" description="hook_user_relationships_types_list_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_path_alias_types" value="/**&#10; * Implements hook_path_alias_types().&#10; *&#10; * @file&#10; * Documentation for pathauto API.&#10; *&#10; * @see hook_token_info&#10; * @see hook_tokens&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_alias_types() {&#10;  $END$&#10;}" description="hook_path_alias_types" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_path_alias_types" value="/**&#10; * Implements hook_path_alias_types().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_path_alias_types() {&#10;  $END$&#10;}" description="hook_path_alias_types" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_pathauto" value="/**&#10; * Implements hook_pathauto().&#10; *&#10; * Documentation for pathauto API.&#10; *&#10; * @see hook_token_info&#10; * @see hook_tokens&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto($op) {&#10;  $END$&#10;}" description="hook_pathauto" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_pathauto" value="/**&#10; * Implements hook_pathauto().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto($op) {&#10;  $END$&#10;}" description="hook_pathauto" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_pathauto_alias_alter" value="/**&#10; * Implements hook_pathauto_alias_alter().&#10; *&#10; *&#10; * @see hook_token_info&#10; * @see hook_tokens&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto_alias_alter(&amp;$alias, array $context) {&#10;  $END$&#10;}" description="hook_pathauto_alias_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_pathauto_alias_alter" value="/**&#10; * Implements hook_pathauto_alias_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto_alias_alter(&amp;$alias, array $context) {&#10;  $END$&#10;}" description="hook_pathauto_alias_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_pathauto_punctuation_chars_alter" value="/**&#10; * Implements hook_pathauto_punctuation_chars_alter().&#10; *&#10; * Alter the list of punctuation characters for Pathauto control.&#10; *&#10; * @param $punctuation&#10; *   An array of punctuation to be controlled by Pathauto during replacement&#10; *   keyed by punctuation name. Each punctuation record should be an array&#10; *   with the following key/value pairs:&#10; *   - value: The raw value of the punctuation mark.&#10; *   - name: The human-readable name of the punctuation mark. This must be&#10; *     translated using t() already.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto_punctuation_chars_alter(array &amp;$punctuation) {&#10;  // Add the trademark symbol.&#10;  $punctuation['trademark'] = array('value' =&gt; '™', 'name' =&gt; t('Trademark symbol'));&#10;&#10;  // Remove the dollar sign.&#10;  unset($punctuation['dollar']);&#10;  $END$&#10;}" description="hook_pathauto_punctuation_chars_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_pathauto_punctuation_chars_alter" value="/**&#10; * Implements hook_pathauto_punctuation_chars_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_pathauto_punctuation_chars_alter(array &amp;$punctuation) {&#10;  // Add the trademark symbol.&#10;  $punctuation['trademark'] = array('value' =&gt; '™', 'name' =&gt; t('Trademark symbol'));&#10;&#10;  // Remove the dollar sign.&#10;  unset($punctuation['dollar']);&#10;  $END$&#10;}" description="hook_pathauto_punctuation_chars_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_admin_menu_map" value="/**&#10; * Implements hook_admin_menu_map().&#10; *&#10; * Provide expansion arguments for dynamic menu items.&#10; *&#10; * The map items must be keyed by the dynamic path to expand, i.e. a menu path&#10; * containing one or more '%' placeholders. Each map item may have the following&#10; * properties:&#10; * - parent: The parent menu path to link the expanded items to.&#10; * - arguments: An array of argument sets that will be used in the expansion.&#10; *   Each set consists of an array of one or more placeholders, which again is&#10; *   an array of possible expansion values. Upon expansion, each argument is&#10; *   combined with every other argument from the set (technically, the cartesian&#10; *   product of all arguments). The expansion values may be empty; that is, you&#10; *   do not need to insert logic to skip map items for which no values exist,&#10; *   since Administration menu will take care of that.&#10; * - hide: (optional) Used to hide another menu path, usually a superfluous&#10; *   &quot;List&quot; item.&#10; *&#10; * @see admin_menu.map.inc&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_menu_map() {&#10;  // Expand content types below Structure &gt; Content types.&#10;  // The key denotes the dynamic path to expand to multiple menu items.&#10;  $map['admin/structure/types/manage/%node_type'] = array(&#10;    // Link generated items directly to the &quot;Content types&quot; item.&#10;    'parent' =&gt; 'admin/structure/types',&#10;    // Hide the &quot;List&quot; item, as this expansion will expose all available&#10;    // options.&#10;    'hide' =&gt; 'admin/structure/types/list',&#10;    // Create expansion arguments for the '%node_type' placeholder.&#10;    'arguments' =&gt; array(&#10;      array(&#10;        '%node_type' =&gt; array_keys(node_type_get_types()),&#10;      ),&#10;    ),&#10;  );&#10;  return $map;&#10;  $END$&#10;}" description="hook_admin_menu_map" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_admin_menu_map" value="/**&#10; * Implements hook_admin_menu_map().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_menu_map() {&#10;  // Expand content types below Structure &gt; Content types.&#10;  // The key denotes the dynamic path to expand to multiple menu items.&#10;  $map['admin/structure/types/manage/%node_type'] = array(&#10;    // Link generated items directly to the &quot;Content types&quot; item.&#10;    'parent' =&gt; 'admin/structure/types',&#10;    // Hide the &quot;List&quot; item, as this expansion will expose all available&#10;    // options.&#10;    'hide' =&gt; 'admin/structure/types/list',&#10;    // Create expansion arguments for the '%node_type' placeholder.&#10;    'arguments' =&gt; array(&#10;      array(&#10;        '%node_type' =&gt; array_keys(node_type_get_types()),&#10;      ),&#10;    ),&#10;  );&#10;  return $map;&#10;  $END$&#10;}" description="hook_admin_menu_map" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_admin_menu_output_alter" value="/**&#10; * Implements hook_admin_menu_output_alter().&#10; *&#10; * Alter content in Administration menu bar before it is rendered.&#10; *&#10; * @param $content&#10; *   A structured array suitable for drupal_render(), at the very least&#10; *   containing the keys 'menu' and 'links'.  Most implementations likely want&#10; *   to alter or add to 'links'.&#10; *&#10; * $content['menu'] contains the HTML representation of the 'admin_menu' menu&#10; * tree.&#10; * @see admin_menu_menu_alter()&#10; *&#10; * $content['links'] contains additional top-level links in the Administration&#10; * menu, such as the icon menu or the logout link. You can add more items here&#10; * or play with the #weight attribute to customize them.&#10; * @see theme_admin_menu_links()&#10; * @see admin_menu_links_icon()&#10; * @see admin_menu_links_user()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_menu_output_alter(&amp;$content) {&#10;  // Add new top-level item.&#10;  $content['menu']['myitem'] = array(&#10;    '#title' =&gt; t('My item'),&#10;    // #attributes are used for list items (LI).&#10;    '#attributes' =&gt; array('class' =&gt; array('mymodule-myitem')),&#10;    '#href' =&gt; 'mymodule/path',&#10;    // #options are passed to l(). Note that you can apply 'attributes' for&#10;    // links (A) here.&#10;    '#options' =&gt; array(&#10;      'query' =&gt; drupal_get_destination(),&#10;    ),&#10;    // #weight controls the order of links in the resulting item list.&#10;    '#weight' =&gt; 50,&#10;  );&#10;  // Add link to manually run cron.&#10;  $content['menu']['myitem']['cron'] = array(&#10;    '#title' =&gt; t('Run cron'),&#10;    '#access' =&gt; user_access('administer site configuration'),&#10;    '#href' =&gt; 'admin/reports/status/run-cron',&#10;  );&#10;  $END$&#10;}" description="hook_admin_menu_output_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_admin_menu_output_alter" value="/**&#10; * Implements hook_admin_menu_output_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_admin_menu_output_alter(&amp;$content) {&#10;  // Add new top-level item.&#10;  $content['menu']['myitem'] = array(&#10;    '#title' =&gt; t('My item'),&#10;    // #attributes are used for list items (LI).&#10;    '#attributes' =&gt; array('class' =&gt; array('mymodule-myitem')),&#10;    '#href' =&gt; 'mymodule/path',&#10;    // #options are passed to l(). Note that you can apply 'attributes' for&#10;    // links (A) here.&#10;    '#options' =&gt; array(&#10;      'query' =&gt; drupal_get_destination(),&#10;    ),&#10;    // #weight controls the order of links in the resulting item list.&#10;    '#weight' =&gt; 50,&#10;  );&#10;  // Add link to manually run cron.&#10;  $content['menu']['myitem']['cron'] = array(&#10;    '#title' =&gt; t('Run cron'),&#10;    '#access' =&gt; user_access('administer site configuration'),&#10;    '#href' =&gt; 'admin/reports/status/run-cron',&#10;  );&#10;  $END$&#10;}" description="hook_admin_menu_output_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_api" value="/**&#10; * Implements hook_features_api().&#10; *&#10; * Main info hook that features uses to determine what components are provided&#10; * by the implementing module.&#10; *&#10; * @return array&#10; *   An array of components, keyed by the component name. Each component can&#10; *   define several keys:&#10; *&#10; *   'file': Optional path to a file to include which contains the rest&#10; *   of the features API hooks for this module.&#10; *&#10; *   'default_hook': The defaults hook for your component that is called&#10; *   when the cache of default components is generated. Examples include&#10; *   hook_views_default_views() or hook_context_default_contexts().&#10; *&#10; *   'default_file': The file-writing behavior to use when exporting this&#10; *   component. May be one of 3 constant values:&#10; *&#10; *   FEATURES_DEFAULTS_INCLUDED_COMMON: write hooks/components to&#10; *   `.features.inc` with other components. This is the default behavior&#10; *   if this key is not defined.&#10; *&#10; *   FEATURES_DEFAULTS_INCLUDED: write hooks/components to a component-&#10; *   specific include named automatically by features.&#10; *&#10; *   FEATURES_DEFAULTS_CUSTOM: write hooks/components to a component-&#10; *   specific include with a custom name provided. If your module provides&#10; *   large amounts of code that should not be parsed often (only on specific&#10; *   cache clears/rebuilds, for example) you should use the 2nd or 3rd&#10; *   options to split your component into its own include.&#10; *&#10; *   'default_filename': The filename to use when 'default_file' is set to&#10; *   FEATURES_DEFAULTS_CUSTOM.&#10; *&#10; *   'features_source': Boolean value for whether this component should be&#10; *   offered as an option on the initial feature creation form.&#10; *&#10; *   'base': Optional. An alternative base key to use when calling features&#10; *   hooks for this component. Can be used for features component types that&#10; *   are declared &quot;dynamically&quot; or are part of a family of components.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_api() {&#10;  return array(&#10;    'mycomponent' =&gt; array(&#10;      'default_hook' =&gt; 'mycomponent_defaults',&#10;      'default_file' =&gt; FEATURES_DEFAULTS_INCLUDED,&#10;      'features_source' =&gt; TRUE,&#10;      'file' =&gt; drupal_get_path('module', 'mycomponent') .'/mycomponent.features.inc',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_features_api" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_api" value="/**&#10; * Implements hook_features_api().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_api() {&#10;  return array(&#10;    'mycomponent' =&gt; array(&#10;      'default_hook' =&gt; 'mycomponent_defaults',&#10;      'default_file' =&gt; FEATURES_DEFAULTS_INCLUDED,&#10;      'features_source' =&gt; TRUE,&#10;      'file' =&gt; drupal_get_path('module', 'mycomponent') .'/mycomponent.features.inc',&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_features_api" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export" value="/**&#10; * Implements hook_features_export().&#10; *&#10; * Component hook. The hook should be implemented using the name ot the&#10; * component, not the module, eg. [component]_features_export() rather than&#10; * [module]_features_export().&#10; *&#10; * Process the export array for a given component. Implementations of this hook&#10; * have three key tasks:&#10; *&#10; * 1. Determine module dependencies for any of the components passed to it&#10; *   e.g. the views implementation iterates over each views' handlers and&#10; *   plugins to determine which modules need to be added as dependencies.&#10; *&#10; * 2. Correctly add components to the export array. In general this is usually&#10; *   adding all of the items in $data to $export['features']['my_key'], but&#10; *   can become more complicated if components are shared between features&#10; *   or modules.&#10; *&#10; * 3. Delegating further detection and export tasks to related or derivative&#10; *   components.&#10; *&#10; * Each export processor can kickoff further export processors by returning a&#10; * keyed array (aka the &quot;pipe&quot;) where the key is the next export processor hook&#10; * to call and the value is an array to be passed to that processor's $data&#10; * argument. This allows an export process to start simply at a few objects:&#10; *&#10; * [context]&#10; *&#10; * And then branch out, delegating each component to its appropriate hook:&#10; *&#10; * [context]--------+------------+&#10; *     |            |            |&#10; *   [node]      [block]      [views]&#10; *     |&#10; *   [CCK]&#10; *     |&#10; * [imagecache]&#10; *&#10; * @param array $data&#10; *   An array of machine names for the component in question to be exported.&#10; * @param array &amp;$export&#10; *   By reference. An array of all components to be exported with a given&#10; *   feature. Component objects that should be exported should be added to&#10; *   this array.&#10; * @param string $module_name&#10; *   The name of the feature module to be generated.&#10; * @return array&#10; *   The pipe array of further processors that should be called.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export($data, &amp;$export, $module_name) {&#10;  // The following is the simplest implementation of a straight object export&#10;  // with no further export processors called.&#10;  foreach ($data as $component) {&#10;    $export['mycomponent'][$component] = $component;&#10;  }&#10;  return array();&#10;  $END$&#10;}" description="hook_features_export" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export" value="/**&#10; * Implements hook_features_export().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export($data, &amp;$export, $module_name) {&#10;  // The following is the simplest implementation of a straight object export&#10;  // with no further export processors called.&#10;  foreach ($data as $component) {&#10;    $export['mycomponent'][$component] = $component;&#10;  }&#10;  return array();&#10;  $END$&#10;}" description="hook_features_export" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export_options" value="/**&#10; * Implements hook_features_export_options().&#10; *&#10; * Component hook. The hook should be implemented using the name ot the&#10; * component, not the module, eg. [component]_features_export() rather than&#10; * [module]_features_export().&#10; *&#10; * List all objects for a component that may be exported.&#10; *&#10; * @return array&#10; *   A keyed array of items, suitable for use with a FormAPI select or&#10; *   checkboxes element.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_options() {&#10;  $options = array();&#10;  foreach (mycomponent_load() as $mycomponent) {&#10;    $options[$mycomponent-&gt;name] = $mycomponent-&gt;title;&#10;  }&#10;  return $options;&#10;  $END$&#10;}" description="hook_features_export_options" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export_options" value="/**&#10; * Implements hook_features_export_options().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_options() {&#10;  $options = array();&#10;  foreach (mycomponent_load() as $mycomponent) {&#10;    $options[$mycomponent-&gt;name] = $mycomponent-&gt;title;&#10;  }&#10;  return $options;&#10;  $END$&#10;}" description="hook_features_export_options" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export_render" value="/**&#10; * Implements hook_features_export_render().&#10; *&#10; * Component hook. The hook should be implemented using the name ot the&#10; * component, not the module, eg. [component]_features_export() rather than&#10; * [module]_features_export().&#10; *&#10; * Render one or more component objects to code.&#10; *&#10; * @param string $module_name&#10; *   The name of the feature module to be exported.&#10; * @param array $data&#10; *   An array of machine name identifiers for the objects to be rendered.&#10; * @param array $export&#10; *   The full export array of the current feature being exported. This is only&#10; *   passed when hook_features_export_render() is invoked for an actual feature&#10; *   update or recreate, not during state checks or other operations.&#10; * @return array&#10; *   An associative array of rendered PHP code where the key is the name of the&#10; *   hook that should wrap the PHP code. The hook should not include the name&#10; *   of the module, e.g. the key for `hook_example` should simply be `example`.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_render($module_name, $data, $export = NULL) {&#10;  $code = array();&#10;  $code[] = '$mycomponents = array();';&#10;  foreach ($data as $name) {&#10;    $code[] = &quot;  \$mycomponents['{$name}'] = &quot; . features_var_export(mycomponent_load($name)) .&quot;;&quot;;&#10;  }&#10;  $code[] = &quot;return \$mycomponents;&quot;;&#10;  $code = implode(&quot;\n&quot;, $mycomponents);&#10;  return array('mycomponent_defaults' =&gt; $code);&#10;  $END$&#10;}" description="hook_features_export_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export_render" value="/**&#10; * Implements hook_features_export_render().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_render($module_name, $data, $export = NULL) {&#10;  $code = array();&#10;  $code[] = '$mycomponents = array();';&#10;  foreach ($data as $name) {&#10;    $code[] = &quot;  \$mycomponents['{$name}'] = &quot; . features_var_export(mycomponent_load($name)) .&quot;;&quot;;&#10;  }&#10;  $code[] = &quot;return \$mycomponents;&quot;;&#10;  $code = implode(&quot;\n&quot;, $mycomponents);&#10;  return array('mycomponent_defaults' =&gt; $code);&#10;  $END$&#10;}" description="hook_features_export_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export_revert" value="/**&#10; * Implements hook_features_export_revert().&#10; *&#10; * Component hook. The hook should be implemented using the name ot the&#10; * component, not the module, eg. [component]_features_export() rather than&#10; * [module]_features_export().&#10; *&#10; * Revert all component objects for a given feature module.&#10; *&#10; * @param string $module_name&#10; *   The name of the feature module whose components should be reverted.&#10; * @return boolean&#10; *   TRUE or FALSE for whether the components were successfully reverted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_revert($module_name) {&#10;  $mycomponents = module_invoke_all($module_name, 'mycomponent_defaults');&#10;  if (!empty($$mycomponents)) {&#10;    foreach ($mycomponents as $mycomponent) {&#10;      mycomponent_delete($mycomponent);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_features_export_revert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export_revert" value="/**&#10; * Implements hook_features_export_revert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_revert($module_name) {&#10;  $mycomponents = module_invoke_all($module_name, 'mycomponent_defaults');&#10;  if (!empty($$mycomponents)) {&#10;    foreach ($mycomponents as $mycomponent) {&#10;      mycomponent_delete($mycomponent);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_features_export_revert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export_rebuild" value="/**&#10; * Implements hook_features_export_rebuild().&#10; *&#10; * Component hook. The hook should be implemented using the name ot the&#10; * component, not the module, eg. [component]_features_export() rather than&#10; * [module]_features_export().&#10; *&#10; * Rebuild all component objects for a given feature module. Should only be&#10; * implemented for 'faux-exportable' components.&#10; *&#10; * This hook is called at points where Features determines that it is safe&#10; * (ie. the feature is in state `FEATURES_REBUILDABLE`) for your module to&#10; * replace objects in the database with defaults that you collect from your&#10; * own defaults hook. See API.txt for how Features determines whether a&#10; * rebuild of components is possible.&#10; *&#10; * @param string $module_name&#10; *   The name of the feature module whose components should be rebuilt.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_rebuild($module_name) {&#10;  $mycomponents = module_invoke_all($module_name, 'mycomponent_defaults');&#10;  if (!empty($$mycomponents)) {&#10;    foreach ($mycomponents as $mycomponent) {&#10;      mycomponent_save($mycomponent);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_features_export_rebuild" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export_rebuild" value="/**&#10; * Implements hook_features_export_rebuild().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_rebuild($module_name) {&#10;  $mycomponents = module_invoke_all($module_name, 'mycomponent_defaults');&#10;  if (!empty($$mycomponents)) {&#10;    foreach ($mycomponents as $mycomponent) {&#10;      mycomponent_save($mycomponent);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_features_export_rebuild" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_export_alter" value="/**&#10; * Implements hook_features_export_alter().&#10; *&#10; * Alter the final export array just prior to the rendering of defaults. Allows&#10; * modules a final say in altering what component objects are exported.&#10; *&#10; * @param array &amp;$export&#10; *   By reference. An array of all components to be exported with a given&#10; *   feature.&#10; * @param array $module_name&#10; *   The name of the feature module to be generated.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_alter(&amp;$export, $module_name) {&#10;  // Example: do not allow the page content type to be exported, ever.&#10;  if (!empty($export['features']['node']['page'])) {&#10;    unset($export['features']['node']['page']);&#10;  }&#10;  $END$&#10;}" description="hook_features_export_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_export_alter" value="/**&#10; * Implements hook_features_export_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_export_alter(&amp;$export, $module_name) {&#10;  // Example: do not allow the page content type to be exported, ever.&#10;  if (!empty($export['features']['node']['page'])) {&#10;    unset($export['features']['node']['page']);&#10;  }&#10;  $END$&#10;}" description="hook_features_export_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_features_pipe_component_alter" value="/**&#10; * Implements hook_features_pipe_component_alter().&#10; *&#10; * Alter the pipe array for a given component. This hook should be implemented&#10; * with the name of the component type in place of `component` in the function&#10; * name, e.g. `features_pipe_views_alter()` will alter the pipe for the Views&#10; * component.&#10; *&#10; * @param array &amp;$pipe&#10; *   By reference. The pipe array of further processors that should be called.&#10; * @param array $data&#10; *   An array of machine names for the component in question to be exported.&#10; * @param array &amp;$export&#10; *   By reference. An array of all components to be exported with a given&#10; *   feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_pipe_component_alter(&amp;$pipe, $data, $export) {&#10;  $END$&#10;}" description="hook_features_pipe_component_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_features_pipe_component_alter" value="/**&#10; * Implements hook_features_pipe_component_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_features_pipe_component_alter(&amp;$pipe, $data, $export) {&#10;  $END$&#10;}" description="hook_features_pipe_component_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_content_default_fields_alter" value="/**&#10; * Implements hook_content_default_fields_alter().&#10; *&#10; * Alter the default cck fields right before they are cached into the database.&#10; *&#10; * @param &amp;$fields&#10; *   By reference. The fields that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_content_default_fields_alter(&amp;$fields) {&#10;  $END$&#10;}" description="hook_content_default_fields_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_content_default_fields_alter" value="/**&#10; * Implements hook_content_default_fields_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_content_default_fields_alter(&amp;$fields) {&#10;  $END$&#10;}" description="hook_content_default_fields_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_fieldgroup_default_groups_alter" value="/**&#10; * Implements hook_fieldgroup_default_groups_alter().&#10; *&#10; * Alter the default fieldgroup groups right before they are cached into the &#10; * database.&#10; *&#10; * @param &amp;$groups&#10; *   By reference. The fieldgroup groups that have been declared by another &#10; *   feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fieldgroup_default_groups_alter(&amp;$groups) {&#10;  $END$&#10;}" description="hook_fieldgroup_default_groups_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_fieldgroup_default_groups_alter" value="/**&#10; * Implements hook_fieldgroup_default_groups_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fieldgroup_default_groups_alter(&amp;$groups) {&#10;  $END$&#10;}" description="hook_fieldgroup_default_groups_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_filter_default_formats_alter" value="/**&#10; * Implements hook_filter_default_formats_alter().&#10; *&#10; * Alter the default filter formats right before they are cached into the &#10; * database.&#10; *&#10; * @param &amp;$formats&#10; *   By reference. The formats that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_default_formats_alter(&amp;$formats) {&#10;  $END$&#10;}" description="hook_filter_default_formats_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_filter_default_formats_alter" value="/**&#10; * Implements hook_filter_default_formats_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_filter_default_formats_alter(&amp;$formats) {&#10;  $END$&#10;}" description="hook_filter_default_formats_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_default_menu_custom_alter" value="/**&#10; * Implements hook_menu_default_menu_custom_alter().&#10; *&#10; * Alter the default menus right before they are cached into the database.&#10; *&#10; * @param &amp;$menus&#10; *   By reference. The menus that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_menu_custom_alter(&amp;$menus) {&#10;  $END$&#10;}" description="hook_menu_default_menu_custom_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_default_menu_custom_alter" value="/**&#10; * Implements hook_menu_default_menu_custom_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_menu_custom_alter(&amp;$menus) {&#10;  $END$&#10;}" description="hook_menu_default_menu_custom_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_default_menu_links_alter" value="/**&#10; * Implements hook_menu_default_menu_links_alter().&#10; *&#10; * Alter the default menu links right before they are cached into the database.&#10; *&#10; * @param &amp;$links&#10; *   By reference. The menu links that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_menu_links_alter(&amp;$links) {&#10;  $END$&#10;}" description="hook_menu_default_menu_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_default_menu_links_alter" value="/**&#10; * Implements hook_menu_default_menu_links_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_menu_links_alter(&amp;$links) {&#10;  $END$&#10;}" description="hook_menu_default_menu_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_menu_default_items_alter" value="/**&#10; * Implements hook_menu_default_items_alter().&#10; *&#10; * Alter the default menu items right before they are cached into the database.&#10; *&#10; * @param &amp;$items&#10; *   By reference. The menu items that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_items_alter(&amp;$items) {&#10;  $END$&#10;}" description="hook_menu_default_items_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_menu_default_items_alter" value="/**&#10; * Implements hook_menu_default_items_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_menu_default_items_alter(&amp;$items) {&#10;  $END$&#10;}" description="hook_menu_default_items_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_taxonomy_default_vocabularies_alter" value="/**&#10; * Implements hook_taxonomy_default_vocabularies_alter().&#10; *&#10; * Alter the default vocabularies right before they are cached into the&#10; * database.&#10; *&#10; * @param &amp;$vocabularies&#10; *   By reference. The vocabularies that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_default_vocabularies_alter(&amp;$vocabularies) {&#10;  $END$&#10;}" description="hook_taxonomy_default_vocabularies_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_taxonomy_default_vocabularies_alter" value="/**&#10; * Implements hook_taxonomy_default_vocabularies_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_taxonomy_default_vocabularies_alter(&amp;$vocabularies) {&#10;  $END$&#10;}" description="hook_taxonomy_default_vocabularies_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_default_permissions_alter" value="/**&#10; * Implements hook_user_default_permissions_alter().&#10; *&#10; * Alter the default permissions right before they are cached into the&#10; * database.&#10; *&#10; * @param &amp;$permissions&#10; *   By reference. The permissions that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_default_permissions_alter(&amp;$permissions) {&#10;  $END$&#10;}" description="hook_user_default_permissions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_default_permissions_alter" value="/**&#10; * Implements hook_user_default_permissions_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_default_permissions_alter(&amp;$permissions) {&#10;  $END$&#10;}" description="hook_user_default_permissions_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_user_default_roles_alter" value="/**&#10; * Implements hook_user_default_roles_alter().&#10; *&#10; * Alter the default roles right before they are cached into the database.&#10; *&#10; * @param &amp;$roles&#10; *   By reference. The roles that have been declared by another feature.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_default_roles_alter(&amp;$roles) {&#10;  $END$&#10;}" description="hook_user_default_roles_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_user_default_roles_alter" value="/**&#10; * Implements hook_user_default_roles_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_user_default_roles_alter(&amp;$roles) {&#10;  $END$&#10;}" description="hook_user_default_roles_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_info" value="/**&#10; * Implements hook_upgrade_info().&#10; *&#10; * Declares upgrade sets for an API (or set of APIs).&#10; *&#10; * This hook allows contributed modules to declare upgrade sets for an API&#10; * supplied by their module, another contributed module, or a core module. To be&#10; * able to apply the upgrade routines independently, the upgrade routines should&#10; * be contained in separate files.&#10; *&#10; * For example, if your module is called 'your_module_name' and its upgrade&#10; * routines are in 'your_module_name.upgrade' (the default file name), then&#10; * declare an upgrade set as:&#10; * @code&#10; *   function your_module_name_upgrade_info() {&#10; *     $upgrade = array(&#10; *       'title' =&gt; t('Your module API changes from 6.x to 7.x'),&#10; *       'link' =&gt; 'http://...',&#10; *     );&#10; *     return array('your_module_name' =&gt; $upgrade);&#10; *   }&#10; * @endcode&#10; *&#10; * @return&#10; *   An associative array (keyed on the upgrade name) with each element being an&#10; *   associative array with the following elements:&#10; *   - 'title': A description of the upgrade routines provided by the upgrade set.&#10; *   - 'link': An optional link to an issue describing the upgrade routines.&#10; *   - 'module': The name of the module providing the upgrade routines.&#10; *   - 'files': An optional array of file names containing the upgrade routines.&#10; *     The name includes any relative path inside the module directory. Defaults&#10; *     to 'your_module_name.upgrade'.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_info() {&#10;  $upgrade = array(&#10;    'title' =&gt; t('Your module API changes from 6.x to 7.x'),&#10;    'link' =&gt; 'http://...',&#10;    'module' =&gt; 'your_module_name',&#10;    'files' =&gt; array(&#10;      'upgrades/your_module_name.upgrade',&#10;    ),&#10;  );&#10;  return array('your_upgrade_name' =&gt; $upgrade);&#10;  $END$&#10;}" description="hook_upgrade_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_info" value="/**&#10; * Implements hook_upgrade_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_info() {&#10;  $upgrade = array(&#10;    'title' =&gt; t('Your module API changes from 6.x to 7.x'),&#10;    'link' =&gt; 'http://...',&#10;    'module' =&gt; 'your_module_name',&#10;    'files' =&gt; array(&#10;      'upgrades/your_module_name.upgrade',&#10;    ),&#10;  );&#10;  return array('your_upgrade_name' =&gt; $upgrade);&#10;  $END$&#10;}" description="hook_upgrade_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_call_FUNCTION_NAME_alter" value="/**&#10; * Implements hook_upgrade_call_FUNCTION_NAME_alter().&#10; *&#10; * Alters a function call using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter a function call object using&#10; * the grammar parser. The function call may be a stand-alone statement or part&#10; * of an expression in another statement. For example:&#10; * @code&#10; *   foo($bar); // Stand-alone.&#10; *   if (foo($bar)) { // Embedded.&#10; *     // Do something.&#10; *   }&#10; * @endcode&#10; *&#10; * Coder Upgrade will call this alter hook for each function call in the file&#10; * that was parsed. However, the function name must be a string, not a variable&#10; * expression. To modify the latter, use hook_upgrade_file_alter(). Refer to the&#10; * grammar parser documentation for details of the function call object.&#10; *&#10; * @see hook_upgrade_file_alter()&#10; * @see PGPFunctionCall&#10; *&#10; * @param PGPFunctionCall $node&#10; *   A node object containing a function call object.&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_call_FUNCTION_NAME_alter(&amp;$node, &amp;$reader) {&#10;  // Get the function call object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Change the function name.&#10;  $item-&gt;name['value'] = 'new_name';&#10;&#10;  if ($item-&gt;parameterCount() &gt; 0) {&#10;    // Delete the first parameter.&#10;    $item-&gt;deleteParameter();&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_call_FUNCTION_NAME_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_call_FUNCTION_NAME_alter" value="/**&#10; * Implements hook_upgrade_call_FUNCTION_NAME_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_call_FUNCTION_NAME_alter(&amp;$node, &amp;$reader) {&#10;  // Get the function call object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Change the function name.&#10;  $item-&gt;name['value'] = 'new_name';&#10;&#10;  if ($item-&gt;parameterCount() &gt; 0) {&#10;    // Delete the first parameter.&#10;    $item-&gt;deleteParameter();&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_call_FUNCTION_NAME_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_call_alter" value="/**&#10; * Implements hook_upgrade_call_alter().&#10; *&#10; * Alters function calls using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter any function call object using&#10; * the grammar parser. The function call may be a stand-alone statement or part&#10; * of an expression in another statement. For example:&#10; * @code&#10; *   foo($bar); // Stand-alone.&#10; *   if (foo($bar)) { // Embedded.&#10; *     // Do something.&#10; *   }&#10; * @endcode&#10; *&#10; * Coder Upgrade will call this alter hook for each function call in the file&#10; * that was parsed. However, the function name must be a string, not a variable&#10; * expression. To modify the latter, use hook_upgrade_file_alter(). Refer to the&#10; * grammar parser documentation for details of the function call object.&#10; *&#10; * @see hook_upgrade_file_alter()&#10; * @see PGPFunctionCall&#10; *&#10; * @param PGPFunctionCall $node&#10; *   A node object containing a function call object.&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; * @param $name&#10; *   The name of the function.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_call_alter(&amp;$node, &amp;$reader, $name) {&#10;  // Get the function call object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Modify the function call.&#10;  switch ($name) {&#10;    case 'foo':&#10;      $item-&gt;deleteParameter();&#10;      break;&#10;&#10;    default:&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_call_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_call_alter" value="/**&#10; * Implements hook_upgrade_call_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_call_alter(&amp;$node, &amp;$reader, $name) {&#10;  // Get the function call object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Modify the function call.&#10;  switch ($name) {&#10;    case 'foo':&#10;      $item-&gt;deleteParameter();&#10;      break;&#10;&#10;    default:&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_call_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_hook_HOOK_NAME_alter" value="/**&#10; * Implements hook_upgrade_hook_HOOK_NAME_alter().&#10; *&#10; * Alters a hook function using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter a function object using the&#10; * grammar parser. The function block may be inside an interface or class, or a&#10; * stand-alone statement block. For example:&#10; * @code&#10; *   function foo($bar) { // Stand-alone.&#10; *     if ($bar) {&#10; *       // Do something.&#10; *     }&#10; *   }&#10; *   class example {&#10; *     function foo($bar) { // Embedded.&#10; *       if ($bar) {&#10; *         // Do something.&#10; *       }&#10; *     }&#10; *   }&#10; * @endcode&#10; *&#10; * Coder Upgrade will call this alter hook for each hook function in the file&#10; * that was parsed. However, the function name must follow the naming convention&#10; * for a hook, i.e, your_module_name_hook. If your module declares a hook for&#10; * another module or otherwise digresses from the standard naming convention,&#10; * then use hook_upgrade_file_alter() to alter this function.&#10; *&#10; * Refer to the grammar parser documentation for details of the function object&#10; * (i.e. PGPClass).&#10; *&#10; * @see hook_upgrade_file_alter()&#10; * @see PGPClass&#10; *&#10; * @param PGPNode $node&#10; *   A node object containing a PGPClass (or function) item.&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_hook_HOOK_NAME_alter(&amp;$node, &amp;$reader) {&#10;  global $_coder_upgrade_module_name;&#10;&#10;  // Get the function object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Rename the function.&#10;  $item-&gt;name = $_coder_upgrade_module_name . '_new_hook_name';&#10;  // Update the document comment.&#10;  $item-&gt;comment['value'] = preg_replace('@\* Implement\s+@', &quot;* Implements &quot;, $item-&gt;comment['value']);&#10;&#10;  if ($item-&gt;parameterCount() &gt; 1) {&#10;    // Switch the first two parameters.&#10;    $p0 = $item-&gt;getParameter(0);&#10;    $p1 = $item-&gt;getParameter(1);&#10;    $item-&gt;setParameter(0, $p1);&#10;    $item-&gt;setParameter(1, $p0);&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_hook_HOOK_NAME_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_hook_HOOK_NAME_alter" value="/**&#10; * Implements hook_upgrade_hook_HOOK_NAME_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_hook_HOOK_NAME_alter(&amp;$node, &amp;$reader) {&#10;  global $_coder_upgrade_module_name;&#10;&#10;  // Get the function object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Rename the function.&#10;  $item-&gt;name = $_coder_upgrade_module_name . '_new_hook_name';&#10;  // Update the document comment.&#10;  $item-&gt;comment['value'] = preg_replace('@\* Implement\s+@', &quot;* Implements &quot;, $item-&gt;comment['value']);&#10;&#10;  if ($item-&gt;parameterCount() &gt; 1) {&#10;    // Switch the first two parameters.&#10;    $p0 = $item-&gt;getParameter(0);&#10;    $p1 = $item-&gt;getParameter(1);&#10;    $item-&gt;setParameter(0, $p1);&#10;    $item-&gt;setParameter(1, $p0);&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_hook_HOOK_NAME_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_hook_alter" value="/**&#10; * Implements hook_upgrade_hook_alter().&#10; *&#10; * Alters hook functions using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter any function object using the&#10; * grammar parser. The function block may be inside an interface or class, or a&#10; * stand-alone statement block. For example:&#10; * @code&#10; *   function foo($bar) { // Stand-alone.&#10; *     if ($bar) {&#10; *       // Do something.&#10; *     }&#10; *   }&#10; *   class example {&#10; *     function foo($bar) { // Embedded.&#10; *       if ($bar) {&#10; *         // Do something.&#10; *       }&#10; *     }&#10; *   }&#10; * @endcode&#10; *&#10; * Coder Upgrade will call this alter hook for each hook function in the file&#10; * that was parsed. However, the function name must follow the naming convention&#10; * for a hook, i.e, your_module_name_hook. If your module declares a hook for&#10; * another module or otherwise digresses from the standard naming convention,&#10; * then use hook_upgrade_file_alter() to alter this function.&#10; *&#10; * Refer to the grammar parser documentation for details of the function object&#10; * (i.e. PGPClass).&#10; *&#10; * @see hook_upgrade_file_alter()&#10; * @see PGPClass&#10; *&#10; * @param PGPNode $node&#10; *   A node object containing a PGPClass (or function) item.&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; * @param $hook&#10; *   The name of the function (excluding the module name).&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_hook_alter(&amp;$node, &amp;$reader, &amp;$hook) {&#10;  global $_coder_upgrade_module_name;&#10;&#10;  // Get the function object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Modify hook function.&#10;  switch ($hook) {&#10;    case 'old_hook_name':&#10;      // Rename the function.&#10;      $item-&gt;name = $_coder_upgrade_module_name . '_new_hook_name';&#10;      // Update the document comment.&#10;      $item-&gt;comment['value'] = preg_replace('@\* Implement\s+@', &quot;* Implements &quot;, $item-&gt;comment['value']);&#10;&#10;      if ($item-&gt;parameterCount() &gt; 1) {&#10;        // Switch the first two parameters.&#10;        $p0 = $item-&gt;getParameter(0);&#10;        $p1 = $item-&gt;getParameter(1);&#10;        $item-&gt;setParameter(0, $p1);&#10;        $item-&gt;setParameter(1, $p0);&#10;      }&#10;      break;&#10;&#10;    default:&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_hook_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_hook_alter" value="/**&#10; * Implements hook_upgrade_hook_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_hook_alter(&amp;$node, &amp;$reader, &amp;$hook) {&#10;  global $_coder_upgrade_module_name;&#10;&#10;  // Get the function object.&#10;  $item = &amp;$node-&gt;data;&#10;&#10;  // Modify hook function.&#10;  switch ($hook) {&#10;    case 'old_hook_name':&#10;      // Rename the function.&#10;      $item-&gt;name = $_coder_upgrade_module_name . '_new_hook_name';&#10;      // Update the document comment.&#10;      $item-&gt;comment['value'] = preg_replace('@\* Implement\s+@', &quot;* Implements &quot;, $item-&gt;comment['value']);&#10;&#10;      if ($item-&gt;parameterCount() &gt; 1) {&#10;        // Switch the first two parameters.&#10;        $p0 = $item-&gt;getParameter(0);&#10;        $p1 = $item-&gt;getParameter(1);&#10;        $item-&gt;setParameter(0, $p1);&#10;        $item-&gt;setParameter(1, $p0);&#10;      }&#10;      break;&#10;&#10;    default:&#10;      break;&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_hook_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_file_alter" value="/**&#10; * Implements hook_upgrade_file_alter().&#10; *&#10; * Alters a code file using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter a code file object using the&#10; * grammar parser. If a module defines a class, then the calls to its methods&#10; * are not included in the calls to hook_upgrade_hook_HOOK_NAME_alter or&#10; * hook_upgrade_hook_alter.&#10; *&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_file_alter(&amp;$reader) {&#10;  /*&#10;   * Task: Modify calls to class methods.&#10;   */&#10;&#10;  // Get list of function calls (including the calls to class methods).&#10;  $nodes = &amp;$reader-&gt;getFunctionCalls();&#10;  // Loop on list.&#10;  foreach ($nodes as &amp;$node) {&#10;    // Get the function call object.&#10;    $item = &amp;$node-&gt;data;&#10;    if (!isset($item) || !is_object($item) || !($item instanceof PGPFunctionCall) || $item-&gt;type != T_FUNCTION_CALL) {&#10;      /*&#10;       * These checks are necessary as the reference (i.e. $item) could have&#10;       * been changed in another routine so that it no longer refers to a&#10;       * function call object.&#10;       */&#10;      continue;&#10;    }&#10;&#10;    /*&#10;     * To be a call to a class method, the function name must be an expression&#10;     * like $this-&gt;foo() as opposed to a string or a single variable. This code&#10;     * checks the name is an expression (using is_a($item-&gt;name, 'PGPOperand'))&#10;     * and the value element of the name object is '$this'.&#10;     *&#10;     * Review the grammar structure object using $item-&gt;print_r().&#10;     */&#10;    if ($item-&gt;name instanceof PGPOperand &amp;&amp; $item-&gt;name-&gt;findNode('value') == '$this') {&#10;      // Strip '$this-&gt;' from the name.&#10;      $name = substr($item-&gt;name-&gt;toString(), 7);&#10;      // Modify the function call&#10;      my_module_convert_method($item, $reader, $name);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_file_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_file_alter" value="/**&#10; * Implements hook_upgrade_file_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_file_alter(&amp;$reader) {&#10;  /*&#10;   * Task: Modify calls to class methods.&#10;   */&#10;&#10;  // Get list of function calls (including the calls to class methods).&#10;  $nodes = &amp;$reader-&gt;getFunctionCalls();&#10;  // Loop on list.&#10;  foreach ($nodes as &amp;$node) {&#10;    // Get the function call object.&#10;    $item = &amp;$node-&gt;data;&#10;    if (!isset($item) || !is_object($item) || !($item instanceof PGPFunctionCall) || $item-&gt;type != T_FUNCTION_CALL) {&#10;      /*&#10;       * These checks are necessary as the reference (i.e. $item) could have&#10;       * been changed in another routine so that it no longer refers to a&#10;       * function call object.&#10;       */&#10;      continue;&#10;    }&#10;&#10;    /*&#10;     * To be a call to a class method, the function name must be an expression&#10;     * like $this-&gt;foo() as opposed to a string or a single variable. This code&#10;     * checks the name is an expression (using is_a($item-&gt;name, 'PGPOperand'))&#10;     * and the value element of the name object is '$this'.&#10;     *&#10;     * Review the grammar structure object using $item-&gt;print_r().&#10;     */&#10;    if ($item-&gt;name instanceof PGPOperand &amp;&amp; $item-&gt;name-&gt;findNode('value') == '$this') {&#10;      // Strip '$this-&gt;' from the name.&#10;      $name = substr($item-&gt;name-&gt;toString(), 7);&#10;      // Modify the function call&#10;      my_module_convert_method($item, $reader, $name);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_upgrade_file_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_parser_install_alter" value="/**&#10; * Implements hook_upgrade_parser_install_alter().&#10; *&#10; * Alters an install file using the grammar parser.&#10; *&#10; * This hook allows contributed modules to alter an install file object using&#10; * the grammar parser. This hook allows for segregation of upgrade routines that&#10; * only apply to an install file (e.g. the database schema API).&#10; *&#10; * @see hook_upgrade_file_alter()&#10; * @see hook_upgrade_hook_HOOK_NAME_alter()&#10; * @see hook_upgrade_hook_alter()&#10; *&#10; * @param PGPReader $reader&#10; *   The object containing the grammar statements of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_parser_install_alter(&amp;$reader) {&#10;  // Do something to the file.&#10;  $END$&#10;}" description="hook_upgrade_parser_install_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_parser_install_alter" value="/**&#10; * Implements hook_upgrade_parser_install_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_parser_install_alter(&amp;$reader) {&#10;  // Do something to the file.&#10;  $END$&#10;}" description="hook_upgrade_parser_install_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_begin_alter" value="/**&#10; * Implements hook_upgrade_begin_alter().&#10; *&#10; * Processes the directory before upgrade routines are applied.&#10; *&#10; * This hook can be used to cache information needed by other routines. For&#10; * example, core changes need to know about hook_theme or hook_menu to make&#10; * theme changes and form API changes.&#10; *&#10; * @param array $item&#10; *   Array of a directory containing the files to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_begin_alter($item) {&#10;  // Do something.&#10;  $END$&#10;}" description="hook_upgrade_begin_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_begin_alter" value="/**&#10; * Implements hook_upgrade_begin_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_begin_alter($item) {&#10;  // Do something.&#10;  $END$&#10;}" description="hook_upgrade_begin_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_end_alter" value="/**&#10; * Implements hook_upgrade_end_alter().&#10; *&#10; * Processes the directory after upgrade routines are applied.&#10; *&#10; * This hook can be used to apply finishing touches to the directory of&#10; * converted files. For example, a D7 core change is to add file entries to&#10; * the .info files.&#10; *&#10; * @param string $dirname&#10; *   The name of the directory with the converted files.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_end_alter($dirname) {&#10;  // Do something.&#10;  $END$&#10;}" description="hook_upgrade_end_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_end_alter" value="/**&#10; * Implements hook_upgrade_end_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_end_alter($dirname) {&#10;  // Do something.&#10;  $END$&#10;}" description="hook_upgrade_end_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_regex_alter" value="/**&#10; * Implements hook_upgrade_regex_alter().&#10; *&#10; * Alters the text of a code file using regular expressions.&#10; *&#10; * @param string $file&#10; *   The text of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_alter(&amp;$file) {&#10;  $hook = 'your_changes'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Do something to $file.&#10;  $from[] = '/(your_module_name)/';&#10;  $to[] = &quot;$1&quot;;&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_regex_alter" value="/**&#10; * Implements hook_upgrade_regex_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_alter(&amp;$file) {&#10;  $hook = 'your_changes'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Do something to $file.&#10;  $from[] = '/(your_module_name)/';&#10;  $to[] = &quot;$1&quot;;&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_regex_info_alter" value="/**&#10; * Implements hook_upgrade_regex_info_alter().&#10; *&#10; * Alters the text of an info file using regular expressions.&#10; *&#10; * @param string $file&#10; *   The text of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_info_alter(&amp;$file) {&#10;  $hook = 'info_file'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Info file should specify core = 7.x.&#10;  $from[] = '@^core\s+=\s+.*?$@m';&#10;  $to[] = 'core = 7.x';&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_regex_info_alter" value="/**&#10; * Implements hook_upgrade_regex_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_info_alter(&amp;$file) {&#10;  $hook = 'info_file'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Info file should specify core = 7.x.&#10;  $from[] = '@^core\s+=\s+.*?$@m';&#10;  $to[] = 'core = 7.x';&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_upgrade_regex_install_alter" value="/**&#10; * Implements hook_upgrade_regex_install_alter().&#10; *&#10; * Alters the text of an install file using regular expressions.&#10; *&#10; * @param string $file&#10; *   The text of the file to convert.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_install_alter(&amp;$file) {&#10;  $hook = 'info_file'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Do something to $file.&#10;  $from[] = '/(your_module_name)/';&#10;  $to[] = &quot;$1&quot;;&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_install_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_upgrade_regex_install_alter" value="/**&#10; * Implements hook_upgrade_regex_install_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_upgrade_regex_install_alter(&amp;$file) {&#10;  $hook = 'info_file'; // Used as the label in the log file.&#10;  $cur = $file;&#10;  $new = $cur;&#10;&#10;  $from = array();&#10;  $to = array();&#10;&#10;  // Do something to $file.&#10;  $from[] = '/(your_module_name)/';&#10;  $to[] = &quot;$1&quot;;&#10;&#10;  coder_upgrade_do_conversions($from, $to, $new);&#10;  coder_upgrade_save_changes($cur, $new, $file, $hook);&#10;  $END$&#10;}" description="hook_upgrade_regex_install_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_reviews" value="/**&#10; * Implements hook_reviews().&#10; *&#10; * @file&#10; * Coder hook function api documentation.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_reviews() {&#10;  $END$&#10;}" description="hook_reviews" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_reviews" value="/**&#10; * Implements hook_reviews().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_reviews() {&#10;  $END$&#10;}" description="hook_reviews" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_fivestar_widgets" value="/**&#10; * Implements hook_fivestar_widgets().&#10; *&#10; * Implementation of hook_fivestar_widgets().&#10; *&#10; * This hook allows other modules to create additional custom widgets for&#10; * the fivestar module.&#10; *&#10; * @return array&#10; *   An array of key =&gt; value pairs suitable for inclusion as the #options in a&#10; *   select or radios form element. Each key must be the location of a css&#10; *   file for a fivestar widget. Each value should be the name of the widget.&#10; *&#10; * @see fivestar_fivestar_widgets()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_widgets() {&#10;  // Letting fivestar know about my Cool and Awesome Stars.&#10;  $widgets = array(&#10;    'path/to/my/awesome/fivestar/css.css' =&gt; 'Awesome Stars',&#10;    'path/to/my/cool/fivestar/css.css' =&gt; 'Cool Stars',&#10;  );&#10;&#10;  return $widgets;&#10;  $END$&#10;}" description="hook_fivestar_widgets" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_fivestar_widgets" value="/**&#10; * Implements hook_fivestar_widgets().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_widgets() {&#10;  // Letting fivestar know about my Cool and Awesome Stars.&#10;  $widgets = array(&#10;    'path/to/my/awesome/fivestar/css.css' =&gt; 'Awesome Stars',&#10;    'path/to/my/cool/fivestar/css.css' =&gt; 'Cool Stars',&#10;  );&#10;&#10;  return $widgets;&#10;  $END$&#10;}" description="hook_fivestar_widgets" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_fivestar_access" value="/**&#10; * Implements hook_fivestar_access().&#10; *&#10; * Implementation of hook_fivestar_access().&#10; *&#10; * This hook is called before every vote is cast through Fivestar. It allows&#10; * modules to allow or deny voting on any type of entity, such as nodes, users, or&#10; * comments.&#10; *&#10; * @param $entity_type&#10; *   Type entity.&#10; * @param $id&#10; *   Identifier within the type.&#10; * @param $tag&#10; *   The VotingAPI tag string.&#10; * @param $uid&#10; *   The user ID trying to cast the vote.&#10; *&#10; * @return boolean or NULL&#10; *   Returns TRUE if voting is supported on this object.&#10; *   Returns NULL if voting is not supported on this object by this module.&#10; *   If needing to absolutely deny all voting on this object, regardless&#10; *   of permissions defined in other modules, return FALSE. Note if all&#10; *   modules return NULL, stating no preference, then access will be denied.&#10; *&#10; * @see fivestar_validate_target()&#10; * @see fivestar_fivestar_access()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_access($entity_type, $id, $tag, $uid) {&#10;  if ($uid == 1) {&#10;    // We are never going to allow the admin user case a fivestar vote.&#10;    return FALSE;&#10;  }&#10;  $END$&#10;}" description="hook_fivestar_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_fivestar_access" value="/**&#10; * Implements hook_fivestar_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_access($entity_type, $id, $tag, $uid) {&#10;  if ($uid == 1) {&#10;    // We are never going to allow the admin user case a fivestar vote.&#10;    return FALSE;&#10;  }&#10;  $END$&#10;}" description="hook_fivestar_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_fivestar_target_info" value="/**&#10; * Implements hook_fivestar_target_info().&#10; *&#10; * Implementation of hook_fivestar_access().&#10; *&#10; * @param $field&#10; *   The field structure for the operation.&#10; * @param $instance&#10; *   The instance structures for the $field.&#10; *&#10; * @return array&#10; *   An array of key =&gt; value pairs. Each key must be unique the identifier for this&#10; *   target selection. The Value is an array of key =&gt; value pairs for a title and a&#10; *   callback function. The title value is used for displaying in the #options array&#10; *   of the target selection option. The callback function is used when trying to decided&#10; *   which target the current vote should be cast against.&#10; *&#10; * @see fivestar_get_targets()&#10; * @see fivestar_fivestar_target_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_target_info($field, $instance) {&#10;  $entity_type = $instance['entity_type'];&#10;  $bundle = $instance['bundle'];&#10;&#10;  $options = array(&#10;    // Declase a new Target Type.&#10;    // This will allow users to vote on a Node and have the vote cast against the&#10;    // node's author instead of the actual node.&#10;    'example_node_author' =&gt; array(&#10;      'title' =&gt; t('Node Author'),&#10;      'callback' =&gt; '_example_target_node_author'&#10;    ),&#10;  );&#10;&#10;  return $options;&#10;  $END$&#10;}" description="hook_fivestar_target_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_fivestar_target_info" value="/**&#10; * Implements hook_fivestar_target_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_fivestar_target_info($field, $instance) {&#10;  $entity_type = $instance['entity_type'];&#10;  $bundle = $instance['bundle'];&#10;&#10;  $options = array(&#10;    // Declase a new Target Type.&#10;    // This will allow users to vote on a Node and have the vote cast against the&#10;    // node's author instead of the actual node.&#10;    'example_node_author' =&gt; array(&#10;      'title' =&gt; t('Node Author'),&#10;      'callback' =&gt; '_example_target_node_author'&#10;    ),&#10;  );&#10;&#10;  return $options;&#10;  $END$&#10;}" description="hook_fivestar_target_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_data" value="/**&#10; * Implements hook_views_data().&#10; *&#10; * Describe table structure to Views.&#10; *&#10; * This hook should be placed in MODULENAME.views.inc and it will be auto-loaded.&#10; * MODULENAME.views.inc must be in the directory specified by the 'path' key&#10; * returned by MODULENAME_views_api(), or the same directory as the .module&#10; * file, if 'path' is unspecified.&#10; *&#10; * The full documentation for this hook is in the advanced help.&#10; * @link http://views-help.doc.logrus.com/help/views/api-tables @endlink&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_data() {&#10;  // This example describes how to write hook_views_data() for the following&#10;  // table:&#10;  //&#10;  // CREATE TABLE example_table (&#10;  //   nid INT(11) NOT NULL         COMMENT 'Primary key; refers to {node}.nid.',&#10;  //   plain_text_field VARCHAR(32) COMMENT 'Just a plain text field.',&#10;  //   numeric_field INT(11)        COMMENT 'Just a numeric field.',&#10;  //   boolean_field INT(1)         COMMENT 'Just an on/off field.',&#10;  //   timestamp_field INT(8)       COMMENT 'Just a timestamp field.',&#10;  //   PRIMARY KEY(nid)&#10;  // );&#10;&#10;  // The 'group' index will be used as a prefix in the UI for any of this&#10;  // table's fields, sort criteria, etc. so it's easy to tell where they came&#10;  // from.&#10;  $data['example_table']['table']['group'] = t('Example table');&#10;&#10;  // Define this as a base table. In reality this is not very useful for&#10;  // this table, as it isn't really a distinct object of its own, but&#10;  // it makes a good example.&#10;  $data['example_table']['table']['base'] = array(&#10;    'field' =&gt; 'nid',&#10;    'title' =&gt; t('Example table'),&#10;    'help' =&gt; t(&quot;Example table contains example content and can be related to nodes.&quot;),&#10;    'weight' =&gt; -10,&#10;  );&#10;&#10;  // This table references the {node} table.&#10;  // This creates an 'implicit' relationship to the node table, so that when 'Node'&#10;  // is the base table, the fields are automatically available.&#10;  $data['example_table']['table']['join'] = array(&#10;    // Index this array by the table name to which this table refers.&#10;    // 'left_field' is the primary key in the referenced table.&#10;    // 'field' is the foreign key in this table.&#10;    'node' =&gt; array(&#10;      'left_field' =&gt; 'nid',&#10;      'field' =&gt; 'nid',&#10;    ),&#10;  );&#10;&#10;  // Next, describe each of the individual fields in this table to Views. For&#10;  // each field, you may define what field, sort, argument, and/or filter&#10;  // handlers it supports. This will determine where in the Views interface you&#10;  // may use the field.&#10;&#10;  // Node ID field.&#10;  $data['example_table']['nid'] = array(&#10;    'title' =&gt; t('Example content'),&#10;    'help' =&gt; t('Some example content that references a node.'),&#10;    // Because this is a foreign key to the {node} table. This allows us to&#10;    // have, when the view is configured with this relationship, all the fields&#10;    // for the related node available.&#10;    'relationship' =&gt; array(&#10;      'base' =&gt; 'node',&#10;      'field' =&gt; 'nid',&#10;      'handler' =&gt; 'views_handler_relationship',&#10;      'label' =&gt; t('Example node'),&#10;    ),&#10;  );&#10;&#10;  // Example plain text field.&#10;  $data['example_table']['plain_text_field'] = array(&#10;    'title' =&gt; t('Plain text field'),&#10;    'help' =&gt; t('Just a plain text field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_string',&#10;    ),&#10;    'argument' =&gt; array(&#10;      'handler' =&gt; 'views_handler_argument_string',&#10;    ),&#10;  );&#10;&#10;  // Example numeric text field.&#10;  $data['example_table']['numeric_field'] = array(&#10;    'title' =&gt; t('Numeric field'),&#10;    'help' =&gt; t('Just a numeric field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_numeric',&#10;      'click sortable' =&gt; TRUE,&#10;     ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_numeric',&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;  );&#10;&#10;  // Example boolean field.&#10;  $data['example_table']['boolean_field'] = array(&#10;    'title' =&gt; t('Boolean field'),&#10;    'help' =&gt; t('Just an on/off field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_boolean',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_boolean_operator',&#10;      'label' =&gt; t('Published'),&#10;      'type' =&gt; 'yes-no',&#10;      // use boolean_field = 1 instead of boolean_field &lt;&gt; 0 in WHERE statment&#10;      'use equal' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;  );&#10;&#10;  // Example timestamp field.&#10;  $data['example_table']['timestamp_field'] = array(&#10;    'title' =&gt; t('Timestamp field'),&#10;    'help' =&gt; t('Just a timestamp field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_date',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort_date',&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_date',&#10;    ),&#10;  );&#10;&#10;  return $data;&#10;  $END$&#10;}" description="hook_views_data" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_data" value="/**&#10; * Implements hook_views_data().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_data() {&#10;  // This example describes how to write hook_views_data() for the following&#10;  // table:&#10;  //&#10;  // CREATE TABLE example_table (&#10;  //   nid INT(11) NOT NULL         COMMENT 'Primary key; refers to {node}.nid.',&#10;  //   plain_text_field VARCHAR(32) COMMENT 'Just a plain text field.',&#10;  //   numeric_field INT(11)        COMMENT 'Just a numeric field.',&#10;  //   boolean_field INT(1)         COMMENT 'Just an on/off field.',&#10;  //   timestamp_field INT(8)       COMMENT 'Just a timestamp field.',&#10;  //   PRIMARY KEY(nid)&#10;  // );&#10;&#10;  // The 'group' index will be used as a prefix in the UI for any of this&#10;  // table's fields, sort criteria, etc. so it's easy to tell where they came&#10;  // from.&#10;  $data['example_table']['table']['group'] = t('Example table');&#10;&#10;  // Define this as a base table. In reality this is not very useful for&#10;  // this table, as it isn't really a distinct object of its own, but&#10;  // it makes a good example.&#10;  $data['example_table']['table']['base'] = array(&#10;    'field' =&gt; 'nid',&#10;    'title' =&gt; t('Example table'),&#10;    'help' =&gt; t(&quot;Example table contains example content and can be related to nodes.&quot;),&#10;    'weight' =&gt; -10,&#10;  );&#10;&#10;  // This table references the {node} table.&#10;  // This creates an 'implicit' relationship to the node table, so that when 'Node'&#10;  // is the base table, the fields are automatically available.&#10;  $data['example_table']['table']['join'] = array(&#10;    // Index this array by the table name to which this table refers.&#10;    // 'left_field' is the primary key in the referenced table.&#10;    // 'field' is the foreign key in this table.&#10;    'node' =&gt; array(&#10;      'left_field' =&gt; 'nid',&#10;      'field' =&gt; 'nid',&#10;    ),&#10;  );&#10;&#10;  // Next, describe each of the individual fields in this table to Views. For&#10;  // each field, you may define what field, sort, argument, and/or filter&#10;  // handlers it supports. This will determine where in the Views interface you&#10;  // may use the field.&#10;&#10;  // Node ID field.&#10;  $data['example_table']['nid'] = array(&#10;    'title' =&gt; t('Example content'),&#10;    'help' =&gt; t('Some example content that references a node.'),&#10;    // Because this is a foreign key to the {node} table. This allows us to&#10;    // have, when the view is configured with this relationship, all the fields&#10;    // for the related node available.&#10;    'relationship' =&gt; array(&#10;      'base' =&gt; 'node',&#10;      'field' =&gt; 'nid',&#10;      'handler' =&gt; 'views_handler_relationship',&#10;      'label' =&gt; t('Example node'),&#10;    ),&#10;  );&#10;&#10;  // Example plain text field.&#10;  $data['example_table']['plain_text_field'] = array(&#10;    'title' =&gt; t('Plain text field'),&#10;    'help' =&gt; t('Just a plain text field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_string',&#10;    ),&#10;    'argument' =&gt; array(&#10;      'handler' =&gt; 'views_handler_argument_string',&#10;    ),&#10;  );&#10;&#10;  // Example numeric text field.&#10;  $data['example_table']['numeric_field'] = array(&#10;    'title' =&gt; t('Numeric field'),&#10;    'help' =&gt; t('Just a numeric field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_numeric',&#10;      'click sortable' =&gt; TRUE,&#10;     ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_numeric',&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;  );&#10;&#10;  // Example boolean field.&#10;  $data['example_table']['boolean_field'] = array(&#10;    'title' =&gt; t('Boolean field'),&#10;    'help' =&gt; t('Just an on/off field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_boolean',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_boolean_operator',&#10;      'label' =&gt; t('Published'),&#10;      'type' =&gt; 'yes-no',&#10;      // use boolean_field = 1 instead of boolean_field &lt;&gt; 0 in WHERE statment&#10;      'use equal' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort',&#10;    ),&#10;  );&#10;&#10;  // Example timestamp field.&#10;  $data['example_table']['timestamp_field'] = array(&#10;    'title' =&gt; t('Timestamp field'),&#10;    'help' =&gt; t('Just a timestamp field.'),&#10;    'field' =&gt; array(&#10;      'handler' =&gt; 'views_handler_field_date',&#10;      'click sortable' =&gt; TRUE,&#10;    ),&#10;    'sort' =&gt; array(&#10;      'handler' =&gt; 'views_handler_sort_date',&#10;    ),&#10;    'filter' =&gt; array(&#10;      'handler' =&gt; 'views_handler_filter_date',&#10;    ),&#10;  );&#10;&#10;  return $data;&#10;  $END$&#10;}" description="hook_views_data" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_data_alter" value="/**&#10; * Implements hook_views_data_alter().&#10; *&#10; * Alter table structure.&#10; *&#10; * You can add/edit/remove to existing tables defined by hook_views_data().&#10; *&#10; * This hook should be placed in MODULENAME.views.inc and it will be auto-loaded.&#10; * MODULENAME.views.inc must be in the directory specified by the 'path' key&#10; * returned by MODULENAME_views_api(), or the same directory as the .module&#10; * file, if 'path' is unspecified.&#10; *&#10; * The full documentation for this hook is in the advanced help.&#10; * @link http://views-help.doc.logrus.com/help/views/api-tables @endlink&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_data_alter(&amp;$data) {&#10;  // This example alters the title of the node: nid field for the admin.&#10;  $data['node']['nid']['title'] = t('Node-Nid');&#10;&#10;  // This example adds a example field to the users table&#10;  $data['users']['example_field'] = array(&#10;    'title' =&gt; t('Example field'),&#10;    'help' =&gt; t('Some examüple content that references a user'),&#10;    'handler' =&gt; 'hook_handlers_field_example_field',&#10;  );&#10;&#10;  // This example changes the handler of the node title field.&#10;  // In this handler you could do stuff, like preview of the node, when clicking the node title.&#10;&#10;  $data['node']['title']['handler'] = 'modulename_handlers_field_node_title';&#10;  $END$&#10;}" description="hook_views_data_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_data_alter" value="/**&#10; * Implements hook_views_data_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_data_alter(&amp;$data) {&#10;  // This example alters the title of the node: nid field for the admin.&#10;  $data['node']['nid']['title'] = t('Node-Nid');&#10;&#10;  // This example adds a example field to the users table&#10;  $data['users']['example_field'] = array(&#10;    'title' =&gt; t('Example field'),&#10;    'help' =&gt; t('Some examüple content that references a user'),&#10;    'handler' =&gt; 'hook_handlers_field_example_field',&#10;  );&#10;&#10;  // This example changes the handler of the node title field.&#10;  // In this handler you could do stuff, like preview of the node, when clicking the node title.&#10;&#10;  $data['node']['title']['handler'] = 'modulename_handlers_field_node_title';&#10;  $END$&#10;}" description="hook_views_data_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_plugins" value="/**&#10; * Implements hook_views_plugins().&#10; *&#10; * The full documentation for this hook is now in the advanced help.&#10; *&#10; * This hook should be placed in MODULENAME.views.inc and it will be auto-loaded.&#10; * MODULENAME.views.inc must be in the directory specified by the 'path' key&#10; * returned by MODULENAME_views_api(), or the same directory as the .module&#10; * file, if 'path' is unspecified.&#10; *&#10; * This is a stub list as a reminder that this needs to be doc'd and is not used&#10; * in views anywhere so might not be remembered when this is formally documented:&#10; * - style: 'even empty'&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_plugins() {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_plugins" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_plugins" value="/**&#10; * Implements hook_views_plugins().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_plugins() {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_plugins" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_plugins_alter" value="/**&#10; * Implements hook_views_plugins_alter().&#10; *&#10; * Alter existing plugins data, defined by modules.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_plugins_alter(&amp;$plugins) {&#10;  // Add apachesolr to the base of the node row plugin.&#10;  $plugins['row']['node']['base'][] = 'apachesolr';&#10;  $END$&#10;}" description="hook_views_plugins_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_plugins_alter" value="/**&#10; * Implements hook_views_plugins_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_plugins_alter(&amp;$plugins) {&#10;  // Add apachesolr to the base of the node row plugin.&#10;  $plugins['row']['node']['base'][] = 'apachesolr';&#10;  $END$&#10;}" description="hook_views_plugins_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_api" value="/**&#10; * Implements hook_views_api().&#10; *&#10; * Register View API information. This is required for your module to have&#10; * its include files loaded; for example, when implementing&#10; * hook_views_default_views().&#10; *&#10; * @return&#10; *   An array with the following possible keys:&#10; *   - api:  (required) The version of the Views API the module implements.&#10; *   - path: (optional) If includes are stored somewhere other than within&#10; *       the root module directory, specify its path here.&#10; *   - template path: (optional) A path where the module has stored it's views template files.&#10; *        When you have specificed this key views automatically uses the template files for the views.&#10; *        You can use the same naming conventions like for normal views template files.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_api() {&#10;  return array(&#10;    'api' =&gt; 2,&#10;    'path' =&gt; drupal_get_path('module', 'example') . '/includes/views',&#10;  );&#10;  $END$&#10;}" description="hook_views_api" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_api" value="/**&#10; * Implements hook_views_api().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_api() {&#10;  return array(&#10;    'api' =&gt; 2,&#10;    'path' =&gt; drupal_get_path('module', 'example') . '/includes/views',&#10;  );&#10;  $END$&#10;}" description="hook_views_api" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_default_views" value="/**&#10; * Implements hook_views_default_views().&#10; *&#10; * This hook allows modules to provide their own views which can either be used&#10; * as-is or as a &quot;starter&quot; for users to build from.&#10; *&#10; * This hook should be placed in MODULENAME.views_default.inc and it will be&#10; * auto-loaded. MODULENAME.views_default.inc must be in the directory specified&#10; * by the 'path' key returned by MODULENAME_views_api(), or the same directory&#10; * as the .module file, if 'path' is unspecified.&#10; *&#10; * The $view-&gt;disabled boolean flag indicates whether the View should be&#10; * enabled or disabled by default.&#10; *&#10; * @return&#10; *   An associative array containing the structures of views, as generated from&#10; *   the Export tab, keyed by the view name. A best practice is to go through&#10; *   and add t() to all title and label strings, with the exception of menu&#10; *   strings.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_default_views() {&#10;  // Begin copy and paste of output from the Export tab of a view.&#10;  $view = new view;&#10;  $view-&gt;name = 'frontpage';&#10;  $view-&gt;description = t('Emulates the default Drupal front page; you may set the default home page path to this view to make it your front page.');&#10;  $view-&gt;tag = t('default');&#10;  $view-&gt;base_table = 'node';&#10;  $view-&gt;api_version = 2;&#10;  $view-&gt;disabled = FALSE; // Edit this to true to make a default view disabled initially&#10;  $view-&gt;display = array();&#10;    $display = new views_display;&#10;    $display-&gt;id = 'default';&#10;    $display-&gt;display_title = t('Master');&#10;    $display-&gt;display_plugin = 'default';&#10;    $display-&gt;position = '1';&#10;    $display-&gt;display_options = array (&#10;    'style_plugin' =&gt; 'default',&#10;    'style_options' =&gt;&#10;    array (&#10;    ),&#10;    'row_plugin' =&gt; 'node',&#10;    'row_options' =&gt;&#10;    array (&#10;      'teaser' =&gt; 1,&#10;      'links' =&gt; 1,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;      'sticky' =&gt;&#10;      array (&#10;        'id' =&gt; 'sticky',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'sticky',&#10;        'order' =&gt; 'ASC',&#10;      ),&#10;      'created' =&gt;&#10;      array (&#10;        'id' =&gt; 'created',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'created',&#10;        'order' =&gt; 'ASC',&#10;        'relationship' =&gt; 'none',&#10;        'granularity' =&gt; 'second',&#10;      ),&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;      'promote' =&gt;&#10;      array (&#10;        'id' =&gt; 'promote',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'promote',&#10;        'operator' =&gt; '=',&#10;        'value' =&gt; '1',&#10;        'group' =&gt; 0,&#10;        'exposed' =&gt; false,&#10;        'expose' =&gt;&#10;        array (&#10;          'operator' =&gt; false,&#10;          'label' =&gt; '',&#10;        ),&#10;      ),&#10;      'status' =&gt;&#10;      array (&#10;        'id' =&gt; 'status',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'status',&#10;        'operator' =&gt; '=',&#10;        'value' =&gt; '1',&#10;        'group' =&gt; 0,&#10;        'exposed' =&gt; false,&#10;        'expose' =&gt;&#10;        array (&#10;          'operator' =&gt; false,&#10;          'label' =&gt; '',&#10;        ),&#10;      ),&#10;    ),&#10;    'items_per_page' =&gt; 10,&#10;    'use_pager' =&gt; '1',&#10;    'pager_element' =&gt; 0,&#10;    'title' =&gt; '',&#10;    'header' =&gt; '',&#10;    'header_format' =&gt; '1',&#10;    'footer' =&gt; '',&#10;    'footer_format' =&gt; '1',&#10;    'empty' =&gt; '',&#10;    'empty_format' =&gt; '1',&#10;  );&#10;  $view-&gt;display['default'] = $display;&#10;    $display = new views_display;&#10;    $display-&gt;id = 'page';&#10;    $display-&gt;display_title = t('Page');&#10;    $display-&gt;display_plugin = 'page';&#10;    $display-&gt;position = '2';&#10;    $display-&gt;display_options = array (&#10;    'defaults' =&gt;&#10;    array (&#10;      'access' =&gt; true,&#10;      'title' =&gt; true,&#10;      'header' =&gt; true,&#10;      'header_format' =&gt; true,&#10;      'header_empty' =&gt; true,&#10;      'footer' =&gt; true,&#10;      'footer_format' =&gt; true,&#10;      'footer_empty' =&gt; true,&#10;      'empty' =&gt; true,&#10;      'empty_format' =&gt; true,&#10;      'items_per_page' =&gt; true,&#10;      'offset' =&gt; true,&#10;      'use_pager' =&gt; true,&#10;      'pager_element' =&gt; true,&#10;      'link_display' =&gt; true,&#10;      'php_arg_code' =&gt; true,&#10;      'exposed_options' =&gt; true,&#10;      'style_plugin' =&gt; true,&#10;      'style_options' =&gt; true,&#10;      'row_plugin' =&gt; true,&#10;      'row_options' =&gt; true,&#10;      'relationships' =&gt; true,&#10;      'fields' =&gt; true,&#10;      'sorts' =&gt; true,&#10;      'arguments' =&gt; true,&#10;      'filters' =&gt; true,&#10;      'use_ajax' =&gt; true,&#10;      'distinct' =&gt; true,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;    ),&#10;    'path' =&gt; 'frontpage',&#10;  );&#10;  $view-&gt;display['page'] = $display;&#10;    $display = new views_display;&#10;    $display-&gt;id = 'feed';&#10;    $display-&gt;display_title = t('Feed');&#10;    $display-&gt;display_plugin = 'feed';&#10;    $display-&gt;position = '3';&#10;    $display-&gt;display_options = array (&#10;    'defaults' =&gt;&#10;    array (&#10;      'access' =&gt; true,&#10;      'title' =&gt; false,&#10;      'header' =&gt; true,&#10;      'header_format' =&gt; true,&#10;      'header_empty' =&gt; true,&#10;      'footer' =&gt; true,&#10;      'footer_format' =&gt; true,&#10;      'footer_empty' =&gt; true,&#10;      'empty' =&gt; true,&#10;      'empty_format' =&gt; true,&#10;      'use_ajax' =&gt; true,&#10;      'items_per_page' =&gt; true,&#10;      'offset' =&gt; true,&#10;      'use_pager' =&gt; true,&#10;      'pager_element' =&gt; true,&#10;      'use_more' =&gt; true,&#10;      'distinct' =&gt; true,&#10;      'link_display' =&gt; true,&#10;      'php_arg_code' =&gt; true,&#10;      'exposed_options' =&gt; true,&#10;      'style_plugin' =&gt; false,&#10;      'style_options' =&gt; false,&#10;      'row_plugin' =&gt; false,&#10;      'row_options' =&gt; false,&#10;      'relationships' =&gt; true,&#10;      'fields' =&gt; true,&#10;      'sorts' =&gt; true,&#10;      'arguments' =&gt; true,&#10;      'filters' =&gt; true,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;    ),&#10;    'displays' =&gt;&#10;    array (&#10;      'default' =&gt; 'default',&#10;      'page' =&gt; 'page',&#10;    ),&#10;    'style_plugin' =&gt; 'rss',&#10;    'style_options' =&gt;&#10;    array (&#10;      'description' =&gt; '',&#10;    ),&#10;    'row_plugin' =&gt; 'node_rss',&#10;    'row_options' =&gt;&#10;    array (&#10;      'item_length' =&gt; 'default',&#10;    ),&#10;    'path' =&gt; 'rss.xml',&#10;    'title' =&gt; t('Front page feed'),&#10;  );&#10;  $view-&gt;display['feed'] = $display;&#10;  // End copy and paste of Export tab output.&#10;&#10;  // Add view to list of views to provide.&#10;  $views[$view-&gt;name] = $view;&#10;&#10;  // ...Repeat all of the above for each view the module should provide.&#10;&#10;  // At the end, return array of default views.&#10;  return $views;&#10;  $END$&#10;}" description="hook_views_default_views" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_default_views" value="/**&#10; * Implements hook_views_default_views().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_default_views() {&#10;  // Begin copy and paste of output from the Export tab of a view.&#10;  $view = new view;&#10;  $view-&gt;name = 'frontpage';&#10;  $view-&gt;description = t('Emulates the default Drupal front page; you may set the default home page path to this view to make it your front page.');&#10;  $view-&gt;tag = t('default');&#10;  $view-&gt;base_table = 'node';&#10;  $view-&gt;api_version = 2;&#10;  $view-&gt;disabled = FALSE; // Edit this to true to make a default view disabled initially&#10;  $view-&gt;display = array();&#10;    $display = new views_display;&#10;    $display-&gt;id = 'default';&#10;    $display-&gt;display_title = t('Master');&#10;    $display-&gt;display_plugin = 'default';&#10;    $display-&gt;position = '1';&#10;    $display-&gt;display_options = array (&#10;    'style_plugin' =&gt; 'default',&#10;    'style_options' =&gt;&#10;    array (&#10;    ),&#10;    'row_plugin' =&gt; 'node',&#10;    'row_options' =&gt;&#10;    array (&#10;      'teaser' =&gt; 1,&#10;      'links' =&gt; 1,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;      'sticky' =&gt;&#10;      array (&#10;        'id' =&gt; 'sticky',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'sticky',&#10;        'order' =&gt; 'ASC',&#10;      ),&#10;      'created' =&gt;&#10;      array (&#10;        'id' =&gt; 'created',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'created',&#10;        'order' =&gt; 'ASC',&#10;        'relationship' =&gt; 'none',&#10;        'granularity' =&gt; 'second',&#10;      ),&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;      'promote' =&gt;&#10;      array (&#10;        'id' =&gt; 'promote',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'promote',&#10;        'operator' =&gt; '=',&#10;        'value' =&gt; '1',&#10;        'group' =&gt; 0,&#10;        'exposed' =&gt; false,&#10;        'expose' =&gt;&#10;        array (&#10;          'operator' =&gt; false,&#10;          'label' =&gt; '',&#10;        ),&#10;      ),&#10;      'status' =&gt;&#10;      array (&#10;        'id' =&gt; 'status',&#10;        'table' =&gt; 'node',&#10;        'field' =&gt; 'status',&#10;        'operator' =&gt; '=',&#10;        'value' =&gt; '1',&#10;        'group' =&gt; 0,&#10;        'exposed' =&gt; false,&#10;        'expose' =&gt;&#10;        array (&#10;          'operator' =&gt; false,&#10;          'label' =&gt; '',&#10;        ),&#10;      ),&#10;    ),&#10;    'items_per_page' =&gt; 10,&#10;    'use_pager' =&gt; '1',&#10;    'pager_element' =&gt; 0,&#10;    'title' =&gt; '',&#10;    'header' =&gt; '',&#10;    'header_format' =&gt; '1',&#10;    'footer' =&gt; '',&#10;    'footer_format' =&gt; '1',&#10;    'empty' =&gt; '',&#10;    'empty_format' =&gt; '1',&#10;  );&#10;  $view-&gt;display['default'] = $display;&#10;    $display = new views_display;&#10;    $display-&gt;id = 'page';&#10;    $display-&gt;display_title = t('Page');&#10;    $display-&gt;display_plugin = 'page';&#10;    $display-&gt;position = '2';&#10;    $display-&gt;display_options = array (&#10;    'defaults' =&gt;&#10;    array (&#10;      'access' =&gt; true,&#10;      'title' =&gt; true,&#10;      'header' =&gt; true,&#10;      'header_format' =&gt; true,&#10;      'header_empty' =&gt; true,&#10;      'footer' =&gt; true,&#10;      'footer_format' =&gt; true,&#10;      'footer_empty' =&gt; true,&#10;      'empty' =&gt; true,&#10;      'empty_format' =&gt; true,&#10;      'items_per_page' =&gt; true,&#10;      'offset' =&gt; true,&#10;      'use_pager' =&gt; true,&#10;      'pager_element' =&gt; true,&#10;      'link_display' =&gt; true,&#10;      'php_arg_code' =&gt; true,&#10;      'exposed_options' =&gt; true,&#10;      'style_plugin' =&gt; true,&#10;      'style_options' =&gt; true,&#10;      'row_plugin' =&gt; true,&#10;      'row_options' =&gt; true,&#10;      'relationships' =&gt; true,&#10;      'fields' =&gt; true,&#10;      'sorts' =&gt; true,&#10;      'arguments' =&gt; true,&#10;      'filters' =&gt; true,&#10;      'use_ajax' =&gt; true,&#10;      'distinct' =&gt; true,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;    ),&#10;    'path' =&gt; 'frontpage',&#10;  );&#10;  $view-&gt;display['page'] = $display;&#10;    $display = new views_display;&#10;    $display-&gt;id = 'feed';&#10;    $display-&gt;display_title = t('Feed');&#10;    $display-&gt;display_plugin = 'feed';&#10;    $display-&gt;position = '3';&#10;    $display-&gt;display_options = array (&#10;    'defaults' =&gt;&#10;    array (&#10;      'access' =&gt; true,&#10;      'title' =&gt; false,&#10;      'header' =&gt; true,&#10;      'header_format' =&gt; true,&#10;      'header_empty' =&gt; true,&#10;      'footer' =&gt; true,&#10;      'footer_format' =&gt; true,&#10;      'footer_empty' =&gt; true,&#10;      'empty' =&gt; true,&#10;      'empty_format' =&gt; true,&#10;      'use_ajax' =&gt; true,&#10;      'items_per_page' =&gt; true,&#10;      'offset' =&gt; true,&#10;      'use_pager' =&gt; true,&#10;      'pager_element' =&gt; true,&#10;      'use_more' =&gt; true,&#10;      'distinct' =&gt; true,&#10;      'link_display' =&gt; true,&#10;      'php_arg_code' =&gt; true,&#10;      'exposed_options' =&gt; true,&#10;      'style_plugin' =&gt; false,&#10;      'style_options' =&gt; false,&#10;      'row_plugin' =&gt; false,&#10;      'row_options' =&gt; false,&#10;      'relationships' =&gt; true,&#10;      'fields' =&gt; true,&#10;      'sorts' =&gt; true,&#10;      'arguments' =&gt; true,&#10;      'filters' =&gt; true,&#10;    ),&#10;    'relationships' =&gt;&#10;    array (&#10;    ),&#10;    'fields' =&gt;&#10;    array (&#10;    ),&#10;    'sorts' =&gt;&#10;    array (&#10;    ),&#10;    'arguments' =&gt;&#10;    array (&#10;    ),&#10;    'filters' =&gt;&#10;    array (&#10;    ),&#10;    'displays' =&gt;&#10;    array (&#10;      'default' =&gt; 'default',&#10;      'page' =&gt; 'page',&#10;    ),&#10;    'style_plugin' =&gt; 'rss',&#10;    'style_options' =&gt;&#10;    array (&#10;      'description' =&gt; '',&#10;    ),&#10;    'row_plugin' =&gt; 'node_rss',&#10;    'row_options' =&gt;&#10;    array (&#10;      'item_length' =&gt; 'default',&#10;    ),&#10;    'path' =&gt; 'rss.xml',&#10;    'title' =&gt; t('Front page feed'),&#10;  );&#10;  $view-&gt;display['feed'] = $display;&#10;  // End copy and paste of Export tab output.&#10;&#10;  // Add view to list of views to provide.&#10;  $views[$view-&gt;name] = $view;&#10;&#10;  // ...Repeat all of the above for each view the module should provide.&#10;&#10;  // At the end, return array of default views.&#10;  return $views;&#10;  $END$&#10;}" description="hook_views_default_views" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_default_views_alter" value="/**&#10; * Implements hook_views_default_views_alter().&#10; *&#10; * This hook is called right before all default views are cached to the&#10; * database. It takes a keyed array of views by reference.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_default_views_alter(&amp;$views) {&#10;  if (isset($views['taxonomy_term'])) {&#10;    $views['taxonomy_term']-&gt;display['default']-&gt;display_options['title'] = 'Categories';&#10;  }&#10;  $END$&#10;}" description="hook_views_default_views_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_default_views_alter" value="/**&#10; * Implements hook_views_default_views_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_default_views_alter(&amp;$views) {&#10;  if (isset($views['taxonomy_term'])) {&#10;    $views['taxonomy_term']-&gt;display['default']-&gt;display_options['title'] = 'Categories';&#10;  }&#10;  $END$&#10;}" description="hook_views_default_views_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_query_substitutions" value="/**&#10; * Implements hook_views_query_substitutions().&#10; *&#10; * Stub hook documentation&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_query_substitutions() {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_query_substitutions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_query_substitutions" value="/**&#10; * Implements hook_views_query_substitutions().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_query_substitutions() {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_query_substitutions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_form_substitutions" value="/**&#10; * Implements hook_views_form_substitutions().&#10; *&#10; * This hook is called to get a list of placeholders and their substitutions,&#10; * used when preprocessing a View with form elements.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_substitutions() {&#10;  return array(&#10;    '&lt;!--views-form-example-substitutions--&gt;' =&gt; 'Example Substitution',&#10;  );&#10;  $END$&#10;}" description="hook_views_form_substitutions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_form_substitutions" value="/**&#10; * Implements hook_views_form_substitutions().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_substitutions() {&#10;  return array(&#10;    '&lt;!--views-form-example-substitutions--&gt;' =&gt; 'Example Substitution',&#10;  );&#10;  $END$&#10;}" description="hook_views_form_substitutions" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_form_validate" value="/**&#10; * Implements hook_views_form_validate().&#10; *&#10; * Views form (View with form elements) validate handler.&#10; * Called for all steps ($form_state['step']) of the multistep form.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_validate($form, &amp;$form_state) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_form_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_form_validate" value="/**&#10; * Implements hook_views_form_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_validate($form, &amp;$form_state) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_form_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_form_submit" value="/**&#10; * Implements hook_views_form_submit().&#10; *&#10; * Views form (View with form elements) submit handler.&#10; * Called for all steps ($form_state['step']) of the multistep form.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_submit($form, &amp;$form_state) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_form_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_form_submit" value="/**&#10; * Implements hook_views_form_submit().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_form_submit($form, &amp;$form_state) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_form_submit" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_pre_view" value="/**&#10; * Implements hook_views_pre_view().&#10; *&#10; * This hook is called at the very beginning of views processing,&#10; * before anything is done.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_view(&amp;$view, &amp;$display_id, &amp;$args) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_pre_view" value="/**&#10; * Implements hook_views_pre_view().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_view(&amp;$view, &amp;$display_id, &amp;$args) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_view" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_pre_build" value="/**&#10; * Implements hook_views_pre_build().&#10; *&#10; * This hook is called right before the build process, but after displays&#10; * are attached and the display performs its pre_execute phase.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_build(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_pre_build" value="/**&#10; * Implements hook_views_pre_build().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_build(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_post_build" value="/**&#10; * Implements hook_views_post_build().&#10; *&#10; * This hook is called right after the build process. The query is&#10; * now fully built, but it has not yet been run through db_rewrite_sql.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_build(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_post_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_post_build" value="/**&#10; * Implements hook_views_post_build().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_build(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_post_build" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_pre_execute" value="/**&#10; * Implements hook_views_pre_execute().&#10; *&#10; * This hook is called right before the execute process. The query is&#10; * now fully built, but it has not yet been run through db_rewrite_sql.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_execute(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_pre_execute" value="/**&#10; * Implements hook_views_pre_execute().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_execute(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_post_execute" value="/**&#10; * Implements hook_views_post_execute().&#10; *&#10; * This hook is called right after the execute process. The query has&#10; * been executed, but the pre_render() phase has not yet happened for&#10; * handlers.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after. Altering the&#10; * content can be achieved by editing the items of $view-&gt;result.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_execute(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_post_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_post_execute" value="/**&#10; * Implements hook_views_post_execute().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_execute(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_post_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_pre_render" value="/**&#10; * Implements hook_views_pre_render().&#10; *&#10; * This hook is called right before the render process. The query has&#10; * been executed, and the pre_render() phase has already happened for&#10; * handlers, so all data should be available.&#10; *&#10; * Adding output to the view can be accomplished by placing text on&#10; * $view-&gt;attachment_before and $view-&gt;attachment_after. Altering the&#10; * content can be achieved by editing the items of $view-&gt;result.&#10; *&#10; * This hook can be utilized by themes.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_render(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_pre_render" value="/**&#10; * Implements hook_views_pre_render().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_pre_render(&amp;$view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_pre_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_post_render" value="/**&#10; * Implements hook_views_post_render().&#10; *&#10; * Post process any rendered data.&#10; *&#10; * This can be valuable to be able to cache a view and still have some level of&#10; * dynamic output. In an ideal world, the actual output will include HTML&#10; * comment based tokens, and then the post process can replace those tokens.&#10; *&#10; * Example usage. If it is known that the view is a node view and that the&#10; * primary field will be a nid, you can do something like this:&#10; *&#10; * &lt;!--post-FIELD-NID--&gt;&#10; *&#10; * And then in the post render, create an array with the text that should&#10; * go there:&#10; *&#10; * strtr($output, array('&lt;!--post-FIELD-1--&gt;', 'output for FIELD of nid 1');&#10; *&#10; * All of the cached result data will be available in $view-&gt;result, as well,&#10; * so all ids used in the query should be discoverable.&#10; *&#10; * This hook can be utilized by themes.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_render(&amp;$view, &amp;$output, &amp;$cache) {&#10;&#10;  $END$&#10;}" description="hook_views_post_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_post_render" value="/**&#10; * Implements hook_views_post_render().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_post_render(&amp;$view, &amp;$output, &amp;$cache) {&#10;&#10;  $END$&#10;}" description="hook_views_post_render" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_query_alter" value="/**&#10; * Implements hook_views_query_alter().&#10; *&#10; * Stub hook documentation&#10; *&#10; * This hook should be placed in MODULENAME.views.inc and it will be auto-loaded.&#10; * MODULENAME.views.inc must be in the directory specified by the 'path' key&#10; * returned by MODULENAME_views_api(), or the same directory as the .module&#10; * file, if 'path' is unspecified.&#10; *&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_query_alter(&amp;$view, &amp;$query) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_query_alter" value="/**&#10; * Implements hook_views_query_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_query_alter(&amp;$view, &amp;$query) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_query_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_preview_info_alter" value="/**&#10; * Implements hook_views_preview_info_alter().&#10; *&#10; * This hook should be placed in MODULENAME.views.inc and it will be auto-loaded.&#10; * MODULENAME.views.inc must be in the directory specified by the 'path' key&#10; * returned by MODULENAME_views_api(), or the same directory as the .module&#10; * file, if 'path' is unspecified.&#10; *&#10; * Alter the rows that appear with a view preview, which include query and&#10; * performance statistics. $rows is an associative array with two keys:&#10; * - query: An array of rows suitable for theme('table'), containing information&#10; *   about the query and the display title and path.&#10; * - statistics: An array of rows suitable for theme('table'), containing&#10; *   performance statistics.&#10; *&#10; * Warning: $view is not a reference in PHP4 and cannot be modified here. But it IS&#10; * a reference in PHP5, and can be modified. Please be careful with it.&#10; *&#10; * @see theme_table&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_preview_info_alter(&amp;$rows, $view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_preview_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_preview_info_alter" value="/**&#10; * Implements hook_views_preview_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_preview_info_alter(&amp;$rows, $view) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_preview_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_views_ui_display_top_links_alter" value="/**&#10; * Implements hook_views_ui_display_top_links_alter().&#10; *&#10; * This hooks allows to alter the links at the top of the view edit form.&#10; * Some modules might want to add links there.&#10; *&#10; * @param $links&#10; *   The links which will be displayed at the top of the view edit form.&#10; * @param view $view&#10; *   The full view object which is currently changed.&#10; * @param $display_id&#10; *   The current display id which is edited. For example that's 'default' or 'page_1'.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_ui_display_top_links_alter(&amp;$links, $view, $display_id) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_ui_display_top_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_views_ui_display_top_links_alter" value="/**&#10; * Implements hook_views_ui_display_top_links_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_views_ui_display_top_links_alter(&amp;$links, $view, $display_id) {&#10;  // example code here&#10;  $END$&#10;}" description="hook_views_ui_display_top_links_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_action_info" value="/**&#10; * Implements hook_rules_action_info().&#10; *&#10; * Define rules compatible actions.&#10; *&#10; * This hook is required in order to add a new rules action. It should be&#10; * placed into the file MODULENAME.rules.inc, which gets automatically included&#10; * when the hook is invoked.&#10; *&#10; * @return&#10; *   An array of information about the module's provided rules actions.&#10; *   The array contains a sub-array for each action, with the action name as&#10; *   the key. Actions names may only contain lowercase alpha-numeric characters&#10; *   and underscores and should be prefixed with the providing module name.&#10; *   Possible attributes for each sub-array are:&#10; *   - label: The label of the action. Start capitalized. Required.&#10; *   - group: A group for this element, used for grouping the actions in the&#10; *     interface. Should start with a capital letter and be translated.&#10; *     Required.&#10; *   - parameter: (optional) An array describing all parameter of the action&#10; *     with the parameter's name as key. Each parameter has to be&#10; *     described by a sub-array with possible attributes as described&#10; *     afterwards, whereas the name of a parameter needs to be a lowercase,&#10; *     valid PHP variable name.&#10; *   - provides: (optional) An array describing the variables the action&#10; *     provides to the evaluation state with the variable name as key. Each&#10; *     variable has to be described by a sub-array with possible attributes as&#10; *     described afterwards, whereas the name of a parameter needs to be a&#10; *     lowercase, valid PHP variable name.&#10; *   - 'named parameter': (optional) If set to TRUE, the arguments will be&#10; *     passed as a single array with the parameter names as keys. This emulates&#10; *     named parameters in PHP and is in particular useful if the number of&#10; *     parameters can vary. Defaults to FALSE.&#10; *   - base: (optional) The base for action implementation callbacks to use&#10; *     instead of the action's name. Defaults to the action name.&#10; *   - callbacks: (optional) An array which allows to set specific function&#10; *     callbacks for the action. The default for each callback is the actions&#10; *     base appended by '_' and the callback name.&#10; *   - 'access callback': (optional) A callback which has to return whether the&#10; *     currently logged in user is allowed to configure this action. See&#10; *     rules_node_integration_access() for an example callback.&#10; *  Each 'parameter' array may contain the following properties:&#10; *   - label: The label of the parameter. Start capitalized. Required.&#10; *   - type: The rules data type of the parameter, which is to be passed to the&#10; *     action. All types declared in hook_rules_data_info() may be specified, as&#10; *     well as an array of possible types. Also lists and lists of a given type&#10; *     can be specified by using the notating list&lt;integer&gt; as introduced by&#10; *     the entity metadata module, see hook_entity_property_info(). The special&#10; *     keyword '*' can be used when all types should be allowed. Required.&#10; *   - bundles: (optional) An array of bundle names. When the specified type is&#10; *     set to a single entity type, this may be used to restrict the allowed&#10; *     bundles.&#10; *   - description: (optional) If necessary, a further description of the&#10; *     parameter.&#10; *   - options list: (optional) A callback that returns an array of possible&#10; *     values for this parameter. The callback has to return an array as used&#10; *     by hook_options_list(). For an example implementation see&#10; *     rules_data_action_type_options().&#10; *   - save: (optional) If this is set to TRUE, the parameter will be saved by&#10; *     rules when the rules evaluation ends. This is only supported for savable&#10; *     data types. If the action returns FALSE, saving is skipped.&#10; *   - optional: (optional) May be set to TRUE, when the parameter isn't&#10; *     required.&#10; *   - 'default value': (optional) The value to pass to the action, in case the&#10; *     parameter is optional and there is no specified value.&#10; *   - 'allow null': (optional) Usually Rules will not pass any NULL values as&#10; *     argument, but abort the evaluation if a NULL value is present. If set to&#10; *     TRUE, Rules will not abort and pass the NULL value through. Defaults to&#10; *     FALSE.&#10; *   - restriction: (optional) Restrict how the argument for this parameter may&#10; *     be provided. Supported values are 'selector' and 'input'.&#10; *   - sanitize: (optional) Allows parameters of type 'text' to demand an&#10; *     already sanitized argument. If enabled, any user specified value won't be&#10; *     sanitized itself, but replacements applied by input evaluators are as&#10; *     well as values retrieved from selected data sources.&#10; *   - wrapped: (optional) Set this to TRUE in case the data should be passed&#10; *     wrapped. This only applies to wrapped data types, e.g. entities.&#10; *  Each 'provides' array may contain the following properties:&#10; *   - label: The label of the variable. Start capitalized. Required.&#10; *   - type: The rules data type of the variable. All types declared in&#10; *     hook_rules_data_info() may be specified. Types may be parametrized e.g.&#10; *     the types node&lt;page&gt; or list&lt;integer&gt; are valid.&#10; *   - save: (optional) If this is set to TRUE, the provided variable is saved&#10; *     by rules when the rules evaluation ends. Only possible for savable data&#10; *     types. Defaults to FALSE.&#10; *&#10; *  The module has to provide an implementation for each action, being a&#10; *  function named as specified in the 'base' key or for the execution callback.&#10; *  All other possible callbacks are optional.&#10; *  Supported action callbacks by rules are defined and documented in the&#10; *  RulesPluginImplInterface. However any module may extend the action plugin&#10; *  based upon a defined interface using hook_rules_plugin_info(). All methods&#10; *  defined in those interfaces can be overridden by the action implementation.&#10; *  The callback implementations for those interfaces may reside in any file&#10; *  specified in hook_rules_file_info().&#10; *&#10; *  @see hook_rules_file_info()&#10; *  @see rules_action_execution_callback()&#10; *  @see hook_rules_plugin_info()&#10; *  @see RulesPluginImplInterface&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_info() {&#10;  return array(&#10;    'mail_user' =&gt; array(&#10;      'label' =&gt; t('Send a mail to a user'),&#10;      'parameter' =&gt; array(&#10;        'user' =&gt; array('type' =&gt; 'user', 'label' =&gt; t('Recipient')),&#10;      ),&#10;      'group' =&gt; t('System'),&#10;      'base' =&gt; 'rules_action_mail_user',&#10;      'callbacks' =&gt; array(&#10;        'validate' =&gt; 'rules_action_custom_validation',&#10;        'help' =&gt; 'rules_mail_help',&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_action_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_action_info" value="/**&#10; * Implements hook_rules_action_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_info() {&#10;  return array(&#10;    'mail_user' =&gt; array(&#10;      'label' =&gt; t('Send a mail to a user'),&#10;      'parameter' =&gt; array(&#10;        'user' =&gt; array('type' =&gt; 'user', 'label' =&gt; t('Recipient')),&#10;      ),&#10;      'group' =&gt; t('System'),&#10;      'base' =&gt; 'rules_action_mail_user',&#10;      'callbacks' =&gt; array(&#10;        'validate' =&gt; 'rules_action_custom_validation',&#10;        'help' =&gt; 'rules_mail_help',&#10;      ),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_action_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_file_info" value="/**&#10; * Implements hook_rules_file_info().&#10; *&#10; * Specify files containing rules integration code.&#10; *&#10; * All files specified in that hook will be included when rules looks for&#10; * existing callbacks for any plugin. Rules remembers which callback is found in&#10; * which file and automatically includes the right file before it is executing&#10; * a plugin method callback. The file yourmodule.rules.inc is added by default&#10; * and need not be specified here.&#10; * This allows you to add new include files only containing functions serving as&#10; * plugin method callbacks in any file without having to care about file&#10; * inclusion.&#10; *&#10; * @return&#10; *   An array of file names without the file ending which defaults to '.inc'.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_file_info() {&#10;  return array('yourmodule.rules-eval');&#10;  $END$&#10;}" description="hook_rules_file_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_file_info" value="/**&#10; * Implements hook_rules_file_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_file_info() {&#10;  return array('yourmodule.rules-eval');&#10;  $END$&#10;}" description="hook_rules_file_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_condition_info" value="/**&#10; * Implements hook_rules_condition_info().&#10; *&#10; * Define rules conditions.&#10; *&#10; * This hook is required in order to add a new rules condition. It should be&#10; * placed into the file MODULENAME.rules.inc, which gets automatically included&#10; * when the hook is invoked.&#10; *&#10; * Adding conditions works exactly the same way as adding actions, with the&#10; * exception that conditions can't provide variables and cannot save parameters.&#10; * Thus the 'provides' attribute is not supported. Furthermore the condition&#10; * implementation callback has to return a boolean value.&#10; *&#10; * @see hook_rules_action_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_condition_info() {&#10;  return array(&#10;    'rules_condition_text_compare' =&gt; array(&#10;      'label' =&gt; t('Textual comparison'),&#10;      'parameter' =&gt; array(&#10;        'text1' =&gt; array('label' =&gt; t('Text 1'), 'type' =&gt; 'text'),&#10;        'text2' =&gt; array('label' =&gt; t('Text 2'), 'type' =&gt; 'text'),&#10;      ),&#10;      'group' =&gt; t('Rules'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_condition_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_condition_info" value="/**&#10; * Implements hook_rules_condition_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_condition_info() {&#10;  return array(&#10;    'rules_condition_text_compare' =&gt; array(&#10;      'label' =&gt; t('Textual comparison'),&#10;      'parameter' =&gt; array(&#10;        'text1' =&gt; array('label' =&gt; t('Text 1'), 'type' =&gt; 'text'),&#10;        'text2' =&gt; array('label' =&gt; t('Text 2'), 'type' =&gt; 'text'),&#10;      ),&#10;      'group' =&gt; t('Rules'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_condition_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_event_info" value="/**&#10; * Implements hook_rules_event_info().&#10; *&#10; * Define rules events.&#10; *&#10; * This hook is required in order to add a new rules event. It should be&#10; * placed into the file MODULENAME.rules.inc, which gets automatically included&#10; * when the hook is invoked.&#10; * The module has to invoke the event when it occurs using rules_invoke_event().&#10; * This function call has to happen outside of MODULENAME.rules.inc,&#10; * usually it's invoked directly from the providing module but wrapped by a&#10; * module_exists('rules') check.&#10; *&#10; * @return&#10; *   An array of information about the module's provided rules events. The array&#10; *   contains a sub-array for each event, with the event name as the key. The&#10; *   name may only contain lower case alpha-numeric characters and underscores&#10; *   and should be prefixed with the providing module name. Possible attributes&#10; *   for each sub-array are:&#10; *   - label: The label of the event. Start capitalized. Required.&#10; *   - group: A group for this element, used for grouping the events in the&#10; *     interface. Should start with a capital letter and be translated.&#10; *     Required.&#10; *   - 'access callback': An callback, which has to return whether the&#10; *     currently logged in user is allowed to configure rules for this event.&#10; *     Access should be only granted, if the user at least may access all the&#10; *     variables provided by the event. Optional.&#10; *   - help: A help text for rules reaction on this event.&#10; *   - variables: An array describing all variables that are available for&#10; *     elements reaction on this event. Optional. Each variable has to be&#10; *     described by a sub-array with the possible attributes:&#10; *     - label: The label of the variable. Start capitalized. Required.&#10; *     - type: The rules data type of the variable. All types declared in&#10; *       hook_rules_data_info() or supported by hook_entity_property_info() may&#10; *       be specified.&#10; *     - bundle: (optional) If the type is an entity type, the bundle of the&#10; *       entity.&#10; *     - description: (optional) A description for the variable.&#10; *     - 'options list': (optional) A callback that returns an array of possible&#10; *       values for this variable as specified for entity properties at&#10; *       hook_entity_property_info().&#10; *     - 'skip save': If the variable is saved after the event has occurred&#10; *       anyway, set this to TRUE. So rules won't save the variable a second&#10; *       time. Optional, defaults to FALSE.&#10; *     - handler: A handler to load the actual variable value. This is useful&#10; *       for lazy loading variables. The handler gets all so far available&#10; *       variables passed in the order as defined. Optional. Also see&#10; *       http://drupal.org/node/884554.&#10; *       Note that for lazy-loading entities just the entity id may be passed&#10; *       as variable value, so a handler is not necessary in that case.&#10; *&#10; *  @see rules_invoke_event()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_info() {&#10;  $items = array(&#10;    'node_insert' =&gt; array(&#10;      'label' =&gt; t('After saving new content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('created content')),&#10;    ),&#10;    'node_update' =&gt; array(&#10;      'label' =&gt; t('After updating existing content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('updated content'), TRUE),&#10;    ),&#10;    'node_presave' =&gt; array(&#10;      'label' =&gt; t('Content is going to be saved'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('saved content'), TRUE),&#10;    ),&#10;    'node_view' =&gt; array(&#10;      'label' =&gt; t('Content is going to be viewed'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('viewed content')) + array(&#10;        'view_mode' =&gt; array('type' =&gt; 'text', 'label' =&gt; t('view mode')),&#10;      ),&#10;    ),&#10;    'node_delete' =&gt; array(&#10;      'label' =&gt; t('After deleting content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('deleted content')),&#10;    ),&#10;  );&#10;  // Specify that on presave the node is saved anyway.&#10;  $items['node_presave']['variables']['node']['skip save'] = TRUE;&#10;  return $items;&#10;  $END$&#10;}" description="hook_rules_event_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_event_info" value="/**&#10; * Implements hook_rules_event_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_info() {&#10;  $items = array(&#10;    'node_insert' =&gt; array(&#10;      'label' =&gt; t('After saving new content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('created content')),&#10;    ),&#10;    'node_update' =&gt; array(&#10;      'label' =&gt; t('After updating existing content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('updated content'), TRUE),&#10;    ),&#10;    'node_presave' =&gt; array(&#10;      'label' =&gt; t('Content is going to be saved'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('saved content'), TRUE),&#10;    ),&#10;    'node_view' =&gt; array(&#10;      'label' =&gt; t('Content is going to be viewed'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('viewed content')) + array(&#10;        'view_mode' =&gt; array('type' =&gt; 'text', 'label' =&gt; t('view mode')),&#10;      ),&#10;    ),&#10;    'node_delete' =&gt; array(&#10;      'label' =&gt; t('After deleting content'),&#10;      'group' =&gt; t('Node'),&#10;      'variables' =&gt; rules_events_node_variables(t('deleted content')),&#10;    ),&#10;  );&#10;  // Specify that on presave the node is saved anyway.&#10;  $items['node_presave']['variables']['node']['skip save'] = TRUE;&#10;  return $items;&#10;  $END$&#10;}" description="hook_rules_event_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_data_info" value="/**&#10; * Implements hook_rules_data_info().&#10; *&#10; * Define rules data types.&#10; *&#10; * This hook is required in order to add a new rules data type. It should be&#10; * placed into the file MODULENAME.rules.inc, which gets automatically included&#10; * when the hook is invoked.&#10; * Rules builds upon the entity metadata module, thus to improve the support of&#10; * your data in rules, make it an entity if possible and provide metadata about&#10; * its properties and CRUD functions by integrating with the entity metadata&#10; * module.&#10; * For a list of data types defined by rules see rules_rules_core_data_info().&#10; *&#10; *&#10; * @return&#10; *   An array of information about the module's provided data types. The array&#10; *   contains a sub-array for each data type, with the data type name as the&#10; *   key. The name may only contain lower case alpha-numeric characters and&#10; *   underscores and should be prefixed with the providing module name. Possible&#10; *   attributes for each sub-array are:&#10; *   - label: The label of the data type. Start uncapitalized. Required.&#10; *   - parent: (optional) A parent type may be set to specify a sub-type&#10; *     relationship, which will be only used for checking compatible types. E.g.&#10; *     the 'entity' data type is parent of the 'node' data type, thus a node may&#10; *     be also used for any action needing an 'entity' parameter. Can be set to&#10; *     any known rules data type.&#10; *   - ui class: (optional) Specify a class that is used to generate the&#10; *     configuration UI to configure parameters of this type. The given class&#10; *     must extend RulesDataUI and may implement the&#10; *     RulesDataDirectInputFormInterface in order to allow the direct data input&#10; *     configuration mode. Defaults to RulesDataUI.&#10; *   - wrap: (optional) If set to TRUE, the data is wrapped internally using&#10; *     wrappers provided by the entity API module. This is required for entities&#10; *     and data structures to support selecting a property via the data selector&#10; *     and for intelligent saving.&#10; *   - is wrapped: (optional) In case the data wrapper is already wrapped when&#10; *     passed to Rules and Rules should not unwrap it when passing the data as&#10; *     argument, e.g. to an action, set this to TRUE. The default FALSE is fine&#10; *     in most cases.&#10; *   - wrapper class: (optional) Allows the specification of a custom wrapper&#10; *     class, which has to inherit from 'EntityMetadataWrapper'. If given Rules&#10; *     makes use of the class for wrapping the data of the given type. However&#10; *     note that if data is already wrapped when it is passed to Rules, the&#10; *     existing wrappers will be kept.&#10; *     For modules implementing identifiable data types being non-entites the&#10; *     class RulesIdentifiableDataWrapper is provided, which can be used as base&#10; *     for a custom wrapper class. See RulesIdentifiableDataWrapper for details.&#10; *   - property info: (optional) May be used for non-entity data structures to&#10; *     provide info about the data properties, such that data selectors via an&#10; *     entity metadata wrapper are supported. Specify an array as expected by&#10; *     the $info parameter of entity_metadata_wrapper().&#10; *   - creation callback: (optional) If 'property info' is given, an optional&#10; *     callback that makes use of the property info to create a new instance of&#10; *     this data type. Entities should use hook_entity_info() to specify the&#10; *     'creation callback' instead, as utilized by the entity API module. See&#10; *     rules_action_data_create_array() for an example callback.&#10; *   - property defaults: (optional) May be used for non-entity data structures&#10; *     to to provide property info defaults for the data properties. Specify an&#10; *     array as expected by entity_metadata_wrapper().&#10; *   - group: (optional) A group for this element, used for grouping the data&#10; *     types in the interface. Should start with a capital letter and be&#10; *     translated.&#10; *   - token type: (optional) The type name as used by the token module.&#10; *     Defaults to the type name as used by rules. Use FALSE to let token ignore&#10; *     this type.&#10; *   - cleaning callback: (optional) A callback that input evaluators may use&#10; *     to clean inserted replacements; e.g. this is used by the token evaluator.&#10; *&#10; *  @see entity_metadata_wrapper()&#10; *  @see hook_rules_data_info_alter()&#10; *  @see rules_rules_core_data_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_info() {&#10;  return array(&#10;    'node' =&gt; array(&#10;      'label' =&gt; t('content'),&#10;      'parent' =&gt; 'entity',&#10;      'group' =&gt; t('Node'),&#10;    ),&#10;    // Formatted text as used by in hook_entity_property_info() for text fields.&#10;    'text_formatted' =&gt; array(&#10;      'label' =&gt; t('formatted text'),&#10;      'ui class' =&gt; 'RulesDataUITextFormatted',&#10;      'wrap' =&gt; TRUE,&#10;      'property info' =&gt; entity_property_text_formatted_info(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_data_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_data_info" value="/**&#10; * Implements hook_rules_data_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_info() {&#10;  return array(&#10;    'node' =&gt; array(&#10;      'label' =&gt; t('content'),&#10;      'parent' =&gt; 'entity',&#10;      'group' =&gt; t('Node'),&#10;    ),&#10;    // Formatted text as used by in hook_entity_property_info() for text fields.&#10;    'text_formatted' =&gt; array(&#10;      'label' =&gt; t('formatted text'),&#10;      'ui class' =&gt; 'RulesDataUITextFormatted',&#10;      'wrap' =&gt; TRUE,&#10;      'property info' =&gt; entity_property_text_formatted_info(),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_data_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_plugin_info" value="/**&#10; * Implements hook_rules_plugin_info().&#10; *&#10; * Defines rules plugins.&#10; *&#10; * A rules configuration may consist of elements being instances of any rules&#10; * plugin. This hook can be used to define new or to extend rules plugins.&#10; *&#10; * @return&#10; *   An array of information about the module's provided rules plugins. The&#10; *   array contains a sub-array for each plugin, with the plugin name as the&#10; *   key. The name may only contain lower case alpha-numeric characters,&#10; *   underscores and spaces and should be prefixed with the providing module&#10; *   name. Possible attributes for&#10; *   each sub-array are:&#10; *   - label: A label for the plugin. Start capitalized. Required only for&#10; *     components (see below).&#10; *   - class: The implementation class. Has to extend the RulesPlugin class.&#10; *   - embeddable: A container class in which elements of those plugin may be&#10; *     embedded or FALSE to disallow embedding. Common classes that are used&#10; *     here are RulesConditionContainer and RulesActionContainer.&#10; *   - component: If set to TRUE, the rules admin UI will list elements of those&#10; *     plugin in the components UI and allows the creation of new components&#10; *     based upon this plugin. Optional.&#10; *   - extenders: This allows one to specify faces extenders, which may be used&#10; *     to dynamically implement interfaces. Optional. All extenders specified&#10; *     here are setup automatically by rules once the object is created. To&#10; *     specify set this to an array, where the keys are the implemented&#10; *     interfaces pointing to another array with the keys:&#10; *     - class: The class of the extender, implementing the FacesExtender&#10; *       and the specified interface. Either 'class' or 'methods' has to exist.&#10; *     - methods: An array of callbacks that implement the methods of the&#10; *       interface where the method names are the keys and the callback names&#10; *       the values. There has to be a callback for each defined method.&#10; *     - file: An optional array describing the file to include when a method&#10; *       of the interface is invoked. The array entries known are 'type',&#10; *       'module', and 'name' matching the parameters of module_load_include().&#10; *       Only 'module' is required as 'type' defaults to 'inc' and 'name' to&#10; *       NULL.&#10; *   - overrides: An optional array, which may be used to specify callbacks to&#10; *     override specific methods. For that the following keys are supported:&#10; *     - methods: As in the extenders array, but you may specify as many methods&#10; *       here as you like.&#10; *     - file: Optionally an array specifying a file to include for a method.&#10; *       For each method appearing in methods a file may be specified by using&#10; *       the method name as key and another array as value, which describes the&#10; *       file to include - looking like the file array supported by 'extenders'.&#10; *   - import keys: (optional) Embeddable plugins may specify an array of import&#10; *     keys, which the plugin make use for exporting. Defaults to the upper&#10; *     case plugin name, thus the key 'OR' in an export triggers the creation&#10; *     of the 'or' plugin. Note that only uppercase values are allowed, as&#10; *     lower case values are treated as action or condition exports.&#10; *&#10; *  @see class RulesPlugin&#10; *  @see hook_rules_plugin_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_plugin_info() {&#10;  return array(&#10;    'or' =&gt; array(&#10;      'label' =&gt; t('Condition set (OR)'),&#10;      'class' =&gt; 'RulesOr',&#10;      'embeddable' =&gt; 'RulesConditionContainer',&#10;      'component' =&gt; TRUE,&#10;      'extenders' =&gt; array(&#10;        'RulesPluginUIInterface' =&gt; array(&#10;          'class' =&gt; 'RulesConditionContainerUI',&#10;        ),&#10;      ),&#10;    ),&#10;    'rule' =&gt; array(&#10;      'class' =&gt; 'Rule',&#10;      'embeddable' =&gt; 'RulesRuleSet',&#10;      'extenders' =&gt; array(&#10;        'RulesPluginUIInterface' =&gt; array(&#10;          'class' =&gt; 'RulesRuleUI',&#10;        ),&#10;      ),&#10;      'import keys' =&gt; array('DO', 'IF'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_plugin_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_plugin_info" value="/**&#10; * Implements hook_rules_plugin_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_plugin_info() {&#10;  return array(&#10;    'or' =&gt; array(&#10;      'label' =&gt; t('Condition set (OR)'),&#10;      'class' =&gt; 'RulesOr',&#10;      'embeddable' =&gt; 'RulesConditionContainer',&#10;      'component' =&gt; TRUE,&#10;      'extenders' =&gt; array(&#10;        'RulesPluginUIInterface' =&gt; array(&#10;          'class' =&gt; 'RulesConditionContainerUI',&#10;        ),&#10;      ),&#10;    ),&#10;    'rule' =&gt; array(&#10;      'class' =&gt; 'Rule',&#10;      'embeddable' =&gt; 'RulesRuleSet',&#10;      'extenders' =&gt; array(&#10;        'RulesPluginUIInterface' =&gt; array(&#10;          'class' =&gt; 'RulesRuleUI',&#10;        ),&#10;      ),&#10;      'import keys' =&gt; array('DO', 'IF'),&#10;    ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_plugin_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_evaluator_info" value="/**&#10; * Implements hook_rules_evaluator_info().&#10; *&#10; * Declare provided rules input evaluators.&#10; *&#10; * The hook implementation should be placed into the file MODULENAME.rules.inc,&#10; * which gets automatically included when the hook is invoked.&#10; * For implementing an input evaluator a class has to be provided which&#10; * extends the abstract RulesDataInputEvaluator class. Therefore the abstract&#10; * methods prepare() and evaluate() have to be implemented, as well as access()&#10; * and help() could be overridden in order to control access permissions or to&#10; * provide some usage help.&#10; *&#10; * @return&#10; *   An array of information about the module's provided input evaluators. The&#10; *   array contains a sub-array for each evaluator, with the evaluator name as&#10; *   the key. The name may only contain lower case alpha-numeric characters and&#10; *   underscores and should be prefixed with the providing module name. Possible&#10; *   attributes for each sub-array are:&#10; *   - class: The implementation class, which has to extend the&#10; *     RulesDataInputEvaluator class. Required.&#10; *   - weight: A weight for controlling the evaluation order of multiple&#10; *     evaluators. Required.&#10; *   - type: Optionally, the data types for which the input evaluator should be&#10; *     used. Defaults to 'text'. Multiple data types may be specified using an&#10; *     array.&#10; *&#10; *  @see class RulesDataInputEvaluator&#10; *  @see hook_rules_evaluator_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_evaluator_info() {&#10;  return array(&#10;    'token' =&gt; array(&#10;      'class' =&gt; 'RulesTokenEvaluator',&#10;      'type' =&gt; array('text', 'uri'),&#10;      'weight' =&gt; 0,&#10;     ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_evaluator_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_evaluator_info" value="/**&#10; * Implements hook_rules_evaluator_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_evaluator_info() {&#10;  return array(&#10;    'token' =&gt; array(&#10;      'class' =&gt; 'RulesTokenEvaluator',&#10;      'type' =&gt; array('text', 'uri'),&#10;      'weight' =&gt; 0,&#10;     ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_evaluator_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_data_processor_info" value="/**&#10; * Implements hook_rules_data_processor_info().&#10; *&#10; * Declare provided rules data processors.&#10; *&#10; * The hook implementation should be placed into the file MODULENAME.rules.inc,&#10; * which gets automatically included when the hook is invoked.&#10; * For implementing a data processors a class has to be provided which&#10; * extends the abstract RulesDataProcessor class. Therefore the abstract&#10; * method process() has to be implemented, but also the methods form() and&#10; * access() could be overridden in order to provide a configuration form or&#10; * to control access permissions.&#10; *&#10; * @return&#10; *   An array of information about the module's provided data processors. The&#10; *   array contains a sub-array for each processor, with the processor name as&#10; *   the key. The name may only contain lower case alpha-numeric characters and&#10; *   underscores and should be prefixed with the providing module name, whereas&#10; *   'select' is reserved as well.&#10; *   Possible attributes for each sub-array are:&#10; *   - class: The implementation class, which has to extend the&#10; *     RulesDataProcessor class. Required.&#10; *   - weight: A weight for controlling the processing order of multiple data&#10; *     processors. Required.&#10; *   - type: Optionally, the data types for which the data processor should be&#10; *     used. Defaults to 'text'. Multiple data types may be specified using an&#10; *     array.&#10; *&#10; *  @see class RulesDataProcessor&#10; *  @see hook_rules_data_processor_info_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_processor_info() {&#10;  return array(&#10;    'date_offset' =&gt; array(&#10;      'class' =&gt; 'RulesDateOffsetProcessor',&#10;      'type' =&gt; 'date',&#10;      'weight' =&gt; -2,&#10;     ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_data_processor_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_data_processor_info" value="/**&#10; * Implements hook_rules_data_processor_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_processor_info() {&#10;  return array(&#10;    'date_offset' =&gt; array(&#10;      'class' =&gt; 'RulesDateOffsetProcessor',&#10;      'type' =&gt; 'date',&#10;      'weight' =&gt; -2,&#10;     ),&#10;  );&#10;  $END$&#10;}" description="hook_rules_data_processor_info" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_action_info_alter" value="/**&#10; * Implements hook_rules_action_info_alter().&#10; *&#10; * Alter rules compatible actions.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $actions&#10; *   The items of all modules as returned from hook_rules_action_info().&#10; *&#10; * @see hook_rules_action_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_info_alter(&amp;$actions) {&#10;  // The rules action is more powerful, so hide the core action&#10;  unset($actions['rules_core_node_assign_owner_action']);&#10;  // We prefer handling saving by rules - not by the user.&#10;  unset($actions['rules_core_node_save_action']);&#10;  $END$&#10;}" description="hook_rules_action_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_action_info_alter" value="/**&#10; * Implements hook_rules_action_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_info_alter(&amp;$actions) {&#10;  // The rules action is more powerful, so hide the core action&#10;  unset($actions['rules_core_node_assign_owner_action']);&#10;  // We prefer handling saving by rules - not by the user.&#10;  unset($actions['rules_core_node_save_action']);&#10;  $END$&#10;}" description="hook_rules_action_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_condition_info_alter" value="/**&#10; * Implements hook_rules_condition_info_alter().&#10; *&#10; * Alter rules conditions.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $conditions&#10; *   The items of all modules as returned from hook_rules_condition_info().&#10; *&#10; * @see hook_rules_condition_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_condition_info_alter(&amp;$conditions) {&#10;  // Change conditions.&#10;  $END$&#10;}" description="hook_rules_condition_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_condition_info_alter" value="/**&#10; * Implements hook_rules_condition_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_condition_info_alter(&amp;$conditions) {&#10;  // Change conditions.&#10;  $END$&#10;}" description="hook_rules_condition_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_event_info_alter" value="/**&#10; * Implements hook_rules_event_info_alter().&#10; *&#10; * Alter rules events.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $events&#10; *   The items of all modules as returned from hook_rules_event_info().&#10; *&#10; * @see hook_rules_event_info().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_info_alter(&amp;$events) {&#10;  // Change events.&#10;  $END$&#10;}" description="hook_rules_event_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_event_info_alter" value="/**&#10; * Implements hook_rules_event_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_info_alter(&amp;$events) {&#10;  // Change events.&#10;  $END$&#10;}" description="hook_rules_event_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_data_info_alter" value="/**&#10; * Implements hook_rules_data_info_alter().&#10; *&#10; * Alter rules data types.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $data_info&#10; *   The items of all modules as returned from hook_rules_data_info().&#10; *&#10; * @see hook_rules_data_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_info_alter(&amp;$data_info) {&#10;  // Change data types.&#10;  $END$&#10;}" description="hook_rules_data_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_data_info_alter" value="/**&#10; * Implements hook_rules_data_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_info_alter(&amp;$data_info) {&#10;  // Change data types.&#10;  $END$&#10;}" description="hook_rules_data_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_plugin_info_alter" value="/**&#10; * Implements hook_rules_plugin_info_alter().&#10; *&#10; * Alter rules plugin info.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $plugin_info&#10; *   The items of all modules as returned from hook_rules_plugin_info().&#10; *&#10; * @see hook_rules_plugin_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_plugin_info_alter(&amp;$plugin_info) {&#10;  // Change plugin info.&#10;  $END$&#10;}" description="hook_rules_plugin_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_plugin_info_alter" value="/**&#10; * Implements hook_rules_plugin_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_plugin_info_alter(&amp;$plugin_info) {&#10;  // Change plugin info.&#10;  $END$&#10;}" description="hook_rules_plugin_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_evaluator_info_alter" value="/**&#10; * Implements hook_rules_evaluator_info_alter().&#10; *&#10; * Alter rules input evaluator info.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $evaluator_info&#10; *   The items of all modules as returned from hook_rules_evaluator_info().&#10; *&#10; * @see hook_rules_evaluator_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_evaluator_info_alter(&amp;$evaluator_info) {&#10;  // Change evaluator info.&#10;  $END$&#10;}" description="hook_rules_evaluator_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_evaluator_info_alter" value="/**&#10; * Implements hook_rules_evaluator_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_evaluator_info_alter(&amp;$evaluator_info) {&#10;  // Change evaluator info.&#10;  $END$&#10;}" description="hook_rules_evaluator_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_data_processor_info_alter" value="/**&#10; * Implements hook_rules_data_processor_info_alter().&#10; *&#10; * Alter rules data_processor info.&#10; *&#10; * The implementation should be placed into the file MODULENAME.rules.inc, which&#10; * gets automatically included when the hook is invoked.&#10; *&#10; * @param $processor_info&#10; *   The items of all modules as returned from hook_rules_data_processor_info().&#10; *&#10; * @see hook_rules_data_processor_info()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_processor_info_alter(&amp;$processor_info) {&#10;  // Change processor info.&#10;  $END$&#10;}" description="hook_rules_data_processor_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_data_processor_info_alter" value="/**&#10; * Implements hook_rules_data_processor_info_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_data_processor_info_alter(&amp;$processor_info) {&#10;  // Change processor info.&#10;  $END$&#10;}" description="hook_rules_data_processor_info_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_load" value="/**&#10; * Implements hook_rules_config_load().&#10; *&#10; * Act on rules configuration being loaded from the database.&#10; *&#10; * This hook is invoked during rules configuration loading, which is handled&#10; * by entity_load(), via classes RulesEntityController and EntityCRUDController.&#10; *&#10; * @param $configs&#10; *   An array of rules configurations being loaded, keyed by id.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_load($configs) {&#10;  $result = db_query('SELECT id, foo FROM {mytable} WHERE id IN(:ids)', array(':ids' =&gt; array_keys($configs)));&#10;  foreach ($result as $record) {&#10;    $configs[$record-&gt;id]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_rules_config_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_load" value="/**&#10; * Implements hook_rules_config_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_load($configs) {&#10;  $result = db_query('SELECT id, foo FROM {mytable} WHERE id IN(:ids)', array(':ids' =&gt; array_keys($configs)));&#10;  foreach ($result as $record) {&#10;    $configs[$record-&gt;id]-&gt;foo = $record-&gt;foo;&#10;  }&#10;  $END$&#10;}" description="hook_rules_config_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_insert" value="/**&#10; * Implements hook_rules_config_insert().&#10; *&#10; * Respond to creation of a new rules configuration.&#10; *&#10; * This hook is invoked after the rules configuration is inserted into the&#10; * the database.&#10; *&#10; * @param RulesPlugin $config&#10; *   The rules configuration that is being created.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_insert($config) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $config-&gt;id,&#10;      'plugin' =&gt; $config-&gt;plugin,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_insert" value="/**&#10; * Implements hook_rules_config_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_insert($config) {&#10;  db_insert('mytable')&#10;    -&gt;fields(array(&#10;      'nid' =&gt; $config-&gt;id,&#10;      'plugin' =&gt; $config-&gt;plugin,&#10;    ))&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_presave" value="/**&#10; * Implements hook_rules_config_presave().&#10; *&#10; * Act on a rules configuration being inserted or updated.&#10; *&#10; * This hook is invoked before the rules configuration is saved to the&#10; * database.&#10; *&#10; * @param RulesPlugin $config&#10; *   The rules configuration that is being inserted or updated.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_presave($config) {&#10;  if ($config-&gt;id &amp;&amp; $config-&gt;module == 'yours') {&#10;    // Add custom condition.&#10;    $config-&gt;conditon(/* Your condition */);&#10;  }&#10;  $END$&#10;}" description="hook_rules_config_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_presave" value="/**&#10; * Implements hook_rules_config_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_presave($config) {&#10;  if ($config-&gt;id &amp;&amp; $config-&gt;module == 'yours') {&#10;    // Add custom condition.&#10;    $config-&gt;conditon(/* Your condition */);&#10;  }&#10;  $END$&#10;}" description="hook_rules_config_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_update" value="/**&#10; * Implements hook_rules_config_update().&#10; *&#10; * Respond to updates to a rules configuration.&#10; *&#10; * This hook is invoked after the configuration has been updated in the&#10; * database.&#10; *&#10; * @param RulesPlugin $config&#10; *   The rules configuration that is being updated.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_update($config) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('plugin' =&gt; $config-&gt;plugin))&#10;    -&gt;condition('id', $config-&gt;id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_update" value="/**&#10; * Implements hook_rules_config_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_update($config) {&#10;  db_update('mytable')&#10;    -&gt;fields(array('plugin' =&gt; $config-&gt;plugin))&#10;    -&gt;condition('id', $config-&gt;id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_delete" value="/**&#10; * Implements hook_rules_config_delete().&#10; *&#10; * Respond to rules configuration deletion.&#10; *&#10; * This hook is invoked after the configuration has been removed from the&#10; * database.&#10; *&#10; * @param RulesPlugin $config&#10; *   The rules configuration that is being deleted.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_delete($config) {&#10;  db_delete('mytable')&#10;    -&gt;condition('id', $config-&gt;id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_delete" value="/**&#10; * Implements hook_rules_config_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_delete($config) {&#10;  db_delete('mytable')&#10;    -&gt;condition('id', $config-&gt;id)&#10;    -&gt;execute();&#10;  $END$&#10;}" description="hook_rules_config_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_config_execute" value="/**&#10; * Implements hook_rules_config_execute().&#10; *&#10; * Respond to rules configuration execution.&#10; *&#10; * This hook is invoked right before the rules configuration is executed.&#10; *&#10; * @param RulesPlugin $config&#10; *   The rules configuration that is being executed.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_execute($config) {&#10;&#10;  $END$&#10;}" description="hook_rules_config_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_config_execute" value="/**&#10; * Implements hook_rules_config_execute().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_config_execute($config) {&#10;&#10;  $END$&#10;}" description="hook_rules_config_execute" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_default_rules_configuration" value="/**&#10; * Implements hook_default_rules_configuration().&#10; *&#10; * Define default rules configurations.&#10; *&#10; * This hook is invoked when rules configurations are loaded. The implementation&#10; * should be placed into the file MODULENAME.rules_defaults.inc, which gets&#10; * automatically included when the hook is invoked.&#10; *&#10; * @return&#10; *   An array of rules configurations with the configuration names as keys.&#10; *&#10; * @see hook_default_rules_configuration_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_default_rules_configuration() {&#10;  $rule = rules_reaction_rule();&#10;  $rule-&gt;label = 'example default rule';&#10;  $rule-&gt;active = FALSE;&#10;  $rule-&gt;event('node_update')&#10;       -&gt;condition(rules_condition('data_is', array('data:select' =&gt; 'node:status', 'value' =&gt; TRUE))-&gt;negate())&#10;       -&gt;condition('data_is', array('data:select' =&gt; 'node:type', 'value' =&gt; 'page'))&#10;       -&gt;action('drupal_message', array('message' =&gt; 'A node has been updated.'));&#10;&#10;  $configs['rules_test_default_1'] = $rule;&#10;  return $config;&#10;  $END$&#10;}" description="hook_default_rules_configuration" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_default_rules_configuration" value="/**&#10; * Implements hook_default_rules_configuration().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_default_rules_configuration() {&#10;  $rule = rules_reaction_rule();&#10;  $rule-&gt;label = 'example default rule';&#10;  $rule-&gt;active = FALSE;&#10;  $rule-&gt;event('node_update')&#10;       -&gt;condition(rules_condition('data_is', array('data:select' =&gt; 'node:status', 'value' =&gt; TRUE))-&gt;negate())&#10;       -&gt;condition('data_is', array('data:select' =&gt; 'node:type', 'value' =&gt; 'page'))&#10;       -&gt;action('drupal_message', array('message' =&gt; 'A node has been updated.'));&#10;&#10;  $configs['rules_test_default_1'] = $rule;&#10;  return $config;&#10;  $END$&#10;}" description="hook_default_rules_configuration" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_default_rules_configuration_alter" value="/**&#10; * Implements hook_default_rules_configuration_alter().&#10; *&#10; * Alter default rules configurations.&#10; *&#10; * The implementation should be placed into the file&#10; * MODULENAME.rules_defaults.inc, which gets automatically included when the&#10; * hook is invoked.&#10; *&#10; * @param $configs&#10; *   The default configurations of all modules as returned from&#10; *   hook_default_rules_configuration().&#10; *&#10; * @see hook_default_rules_configuration()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_default_rules_configuration_alter(&amp;$configs) {&#10;  // Add custom condition.&#10;  $configs['foo']-&gt;condition('bar');&#10;  $END$&#10;}" description="hook_default_rules_configuration_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_default_rules_configuration_alter" value="/**&#10; * Implements hook_default_rules_configuration_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_default_rules_configuration_alter(&amp;$configs) {&#10;  // Add custom condition.&#10;  $configs['foo']-&gt;condition('bar');&#10;  $END$&#10;}" description="hook_default_rules_configuration_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_component_alter" value="/**&#10; * Implements hook_rules_component_alter().&#10; *&#10; * Alter rules components before execution.&#10; *&#10; * This hooks allows altering rules components before they are cached for later&#10; * re-use. Use this hook only for altering the component in order to prepare&#10; * re-use through rules_invoke_component() or the provided condition/action.&#10; * Note that this hook is only invoked for any components cached for execution,&#10; * but not for components that are programmatically created and executed on the&#10; * fly (without saving them).&#10; *&#10; * @param $plugin&#10; *   The name of the component plugin.&#10; * @param $component&#10; *   The component that is to be cached.&#10; *&#10; * @see rules_invoke_component()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_component_alter($plugin, RulesPlugin $component) {&#10;&#10;  $END$&#10;}" description="hook_rules_component_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_component_alter" value="/**&#10; * Implements hook_rules_component_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_component_alter($plugin, RulesPlugin $component) {&#10;&#10;  $END$&#10;}" description="hook_rules_component_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_event_set_alter" value="/**&#10; * Implements hook_rules_event_set_alter().&#10; *&#10; * Alters event sets.&#10; *&#10; * This hooks allows altering rules event sets, which contain all rules that are&#10; * triggered upon a specific event. Rules internally caches all rules associated&#10; * to an event in an event set, which is cached for fast evaluation. This hook&#10; * is invoked just before any event set is cached, thus it allows altering of&#10; * the to be executed rules without the changes to appear in the UI, e.g. to add&#10; * a further condition to some rules.&#10; *&#10; * @param $event_name&#10; *   The name of the event.&#10; * @param $event_set&#10; *   The event set that is to be cached.&#10; *&#10; * @see rules_invoke_event()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_set_alter($event_name, RulesEventSet $event_set) {&#10;&#10;  $END$&#10;}" description="hook_rules_event_set_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_event_set_alter" value="/**&#10; * Implements hook_rules_event_set_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_event_set_alter($event_name, RulesEventSet $event_set) {&#10;&#10;  $END$&#10;}" description="hook_rules_event_set_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_action_base_upgrade_map_name" value="/**&#10; * Implements hook_rules_action_base_upgrade_map_name().&#10; *&#10; * D6 to D7 upgrade procedure hook for mapping action or condition names.&#10; *&#10; * If for a module the action or condition name changed since Drupal 6, this&#10; * &quot;hook&quot; can be implemented in order to map to the new name of the action or&#10; * condition.&#10; *&#10; * This is no real hook, but a callback that is invoked for each Drupal 6&#10; * action or condition that is to be upgraded to Drupal 7. E.g. the function&#10; * name called for the action &quot;rules_action_set_node_title&quot; would be&#10; * &quot;rules_action_set_node_title_upgrade_map_name&quot;.&#10; *&#10; * @param $element&#10; *   The element array of a configured condition or action which is to be&#10; *   upgraded.&#10; * @return&#10; *   The name of the action or condition which should be used.&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_base_upgrade_map_name($element) {&#10;  return 'data_set';&#10;  $END$&#10;}" description="hook_rules_action_base_upgrade_map_name" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_action_base_upgrade_map_name" value="/**&#10; * Implements hook_rules_action_base_upgrade_map_name().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_base_upgrade_map_name($element) {&#10;  return 'data_set';&#10;  $END$&#10;}" description="hook_rules_action_base_upgrade_map_name" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_action_base_upgrade" value="/**&#10; * Implements hook_rules_action_base_upgrade().&#10; *&#10; * D6 to D7 upgrade procedure hook for mapping action or condition configuration.&#10; *&#10; * During upgrading Drupal 6 rule configurations to Drupal 7 Rules is taking&#10; * care of upgrading the configuration of all known parameters, which only works&#10; * if the parameter name has not changed.&#10; * If something changed, this callback can be used to properly apply the&#10; * configruation of the Drupal 6 action ($element) to the Drupal 7 version&#10; * ($target).&#10; *&#10; * This is no real hook, but a callback that is invoked for each Drupal 6&#10; * action or condition that is to be upgraded to Drupal 7. E.g. the function&#10; * name called for the action &quot;rules_action_set_node_title&quot; would be&#10; * &quot;rules_action_set_node_title_upgrade&quot;.&#10; *&#10; * @param $element&#10; *   The element array of a configured condition or action which is to be&#10; *   upgraded.&#10; * @param $target&#10; *   The Drupal 7 version of the configured element.&#10; *&#10; * @see hook_rules_element_upgrade_alter()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_base_upgrade($element, RulesPlugin $target) {&#10;  $target-&gt;settings['data:select'] = $element['#settings']['#argument map']['node'] . ':title';&#10;  $target-&gt;settings['value'] = $element['#settings']['title'];&#10;  $END$&#10;}" description="hook_rules_action_base_upgrade" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_action_base_upgrade" value="/**&#10; * Implements hook_rules_action_base_upgrade().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_action_base_upgrade($element, RulesPlugin $target) {&#10;  $target-&gt;settings['data:select'] = $element['#settings']['#argument map']['node'] . ':title';&#10;  $target-&gt;settings['value'] = $element['#settings']['title'];&#10;  $END$&#10;}" description="hook_rules_action_base_upgrade" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_rules_element_upgrade_alter" value="/**&#10; * Implements hook_rules_element_upgrade_alter().&#10; *&#10; * D6 to D7 upgrade procedure hook for mapping action or condition configuration.&#10; *&#10; * A alter hook that is called after the action/condition specific callback for&#10; * each element of a configuration that is upgraded.&#10; *&#10; * @param $element&#10; *   The element array of a configured condition or action which is to be&#10; *   upgraded.&#10; * @param $target&#10; *   The Drupal 7 version of the configured element.&#10; *&#10; * @see hook_rules_action_base_upgrade()&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_element_upgrade_alter($element, $target) {&#10;&#10;  $END$&#10;}" description="hook_rules_element_upgrade_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_rules_element_upgrade_alter" value="/**&#10; * Implements hook_rules_element_upgrade_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_rules_element_upgrade_alter($element, $target) {&#10;&#10;  $END$&#10;}" description="hook_rules_element_upgrade_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_load" value="/**&#10; * Implements hook_redirect_load().&#10; *&#10; * Act on redirects being loaded from the database.&#10; *&#10; * This hook is invoked during redirect loading, which is handled by&#10; * entity_load(), via classes RedirectController and&#10; * DrupalDefaultEntityController. After the redirect information is read from&#10; * the database or the entity cache, hook_entity_load() is invoked on all&#10; * implementing modules, and then hook_redirect_load() is invoked on all&#10; * implementing modules.&#10; *&#10; * This hook should only be used to add information that is not in the redirect&#10; * table, not to replace information that is in that table (which could&#10; * interfere with the entity cache). For performance reasons, information for&#10; * all available redirects should be loaded in a single query where possible.&#10; *&#10; * The $types parameter allows for your module to have an early return (for&#10; * efficiency) if your module only supports certain redirect types.&#10; *&#10; * @param $redirects&#10; *   An array of the redirects being loaded, keyed by rid.&#10; * @param $types&#10; *   An array containing the types of the redirects.&#10; *&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_load(array &amp;$redirects, $types) {&#10;&#10;  $END$&#10;}" description="hook_redirect_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_load" value="/**&#10; * Implements hook_redirect_load().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_load(array &amp;$redirects, $types) {&#10;&#10;  $END$&#10;}" description="hook_redirect_load" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_load_by_source_alter" value="/**&#10; * Implements hook_redirect_load_by_source_alter().&#10; *&#10; * Alter the list of redirects matching a certain source.&#10; *&#10; * @param $redirects&#10; *   An array of redirect objects.&#10; * @param $source&#10; *   The source request path.&#10; * @param $context&#10; *   An array with the following key/value pairs:&#10; *   - language: The language code of the source request.&#10; *   - query: An array of the source request query string.&#10; *&#10; * @see redirect_load_by_source()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_load_by_source_alter(array &amp;$redirects, $source, array $context) {&#10;  foreach ($redirects as $rid =&gt; $redirect) {&#10;    if ($redirect-&gt;source !== $source) {&#10;      // If the redirects to do not exactly match $source (e.g. case&#10;      // insensitive matches), then remove them from the results.&#10;      unset($redirects[$rid]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_redirect_load_by_source_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_load_by_source_alter" value="/**&#10; * Implements hook_redirect_load_by_source_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_load_by_source_alter(array &amp;$redirects, $source, array $context) {&#10;  foreach ($redirects as $rid =&gt; $redirect) {&#10;    if ($redirect-&gt;source !== $source) {&#10;      // If the redirects to do not exactly match $source (e.g. case&#10;      // insensitive matches), then remove them from the results.&#10;      unset($redirects[$rid]);&#10;    }&#10;  }&#10;  $END$&#10;}" description="hook_redirect_load_by_source_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_access" value="/**&#10; * Implements hook_redirect_access().&#10; *&#10; * Control access to a redirect.&#10; *&#10; * Modules may implement this hook if they want to have a say in whether or not&#10; * a given user has access to perform a given operation on a redirect.&#10; *&#10; * The administrative account (user ID #1) always passes any access check,&#10; * so this hook is not called in that case. Users with the &quot;administer redirects&quot;&#10; * permission may always update and delete redirects through the administrative&#10; * interface.&#10; *&#10; * Note that not all modules will want to influence access on all&#10; * redirect types. If your module does not want to actively grant or&#10; * block access, return REDIRECT_ACCESS_IGNORE or simply return nothing.&#10; * Blindly returning FALSE will break other redirect access modules.&#10; *&#10; * @param $redirect&#10; *   The redirect object on which the operation is to be performed, or, if it&#10; *   does not yet exist, the type of redirect to be created.&#10; * @param $op&#10; *   The operation to be performed. Possible values:&#10; *   - &quot;create&quot;&#10; *   - &quot;delete&quot;&#10; *   - &quot;update&quot;&#10; * @param $account&#10; *   A user object representing the user for whom the operation is to be&#10; *   performed.&#10; *&#10; * @return&#10; *   REDIRECT_ACCESS_ALLOW if the operation is to be allowed;&#10; *   REDIRECT_ACCESS_DENY if the operation is to be denied;&#10; *   REDIRECT_ACCESSS_IGNORE to not affect this operation at all.&#10; *&#10; * @see redirect_access()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_access($op, $redirect, $account) {&#10;  $type = is_string($redirect) ? $redirect : $redirect-&gt;type;&#10;&#10;  if (in_array($type, array('normal', 'special'))) {&#10;    if ($op == 'create' &amp;&amp; user_access('create ' . $type . ' redirects', $account)) {&#10;      return REDIRECT_ACCESS_ALLOW;&#10;    }&#10;&#10;    if ($op == 'update') {&#10;      if (user_access('edit any ' . $type . ' content', $account) || (user_access('edit own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $redirect-&gt;uid))) {&#10;        return REDIRECT_ACCESS_ALLOW;&#10;      }&#10;    }&#10;&#10;    if ($op == 'delete') {&#10;      if (user_access('delete any ' . $type . ' content', $account) || (user_access('delete own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $redirect-&gt;uid))) {&#10;        return REDIRECT_ACCESS_ALLOW;&#10;      }&#10;    }&#10;  }&#10;&#10;  // Returning nothing from this function would have the same effect.&#10;  return REDIRECT_ACCESS_IGNORE;&#10;  $END$&#10;}" description="hook_redirect_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_access" value="/**&#10; * Implements hook_redirect_access().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_access($op, $redirect, $account) {&#10;  $type = is_string($redirect) ? $redirect : $redirect-&gt;type;&#10;&#10;  if (in_array($type, array('normal', 'special'))) {&#10;    if ($op == 'create' &amp;&amp; user_access('create ' . $type . ' redirects', $account)) {&#10;      return REDIRECT_ACCESS_ALLOW;&#10;    }&#10;&#10;    if ($op == 'update') {&#10;      if (user_access('edit any ' . $type . ' content', $account) || (user_access('edit own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $redirect-&gt;uid))) {&#10;        return REDIRECT_ACCESS_ALLOW;&#10;      }&#10;    }&#10;&#10;    if ($op == 'delete') {&#10;      if (user_access('delete any ' . $type . ' content', $account) || (user_access('delete own ' . $type . ' content', $account) &amp;&amp; ($account-&gt;uid == $redirect-&gt;uid))) {&#10;        return REDIRECT_ACCESS_ALLOW;&#10;      }&#10;    }&#10;  }&#10;&#10;  // Returning nothing from this function would have the same effect.&#10;  return REDIRECT_ACCESS_IGNORE;&#10;  $END$&#10;}" description="hook_redirect_access" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_prepare" value="/**&#10; * Implements hook_redirect_prepare().&#10; *&#10; * Act on a redirect object about to be shown on the add/edit form.&#10; *&#10; * This hook is invoked from redirect_object_prepare().&#10; *&#10; * @param $redirect&#10; *   The redirect that is about to be shown on the add/edit form.&#10; *&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_prepare($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_prepare" value="/**&#10; * Implements hook_redirect_prepare().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_prepare($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_prepare" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_validate" value="/**&#10; * Implements hook_redirect_validate().&#10; *&#10; * Perform redirect validation before a redirect is created or updated.&#10; *&#10; * This hook is invoked from redirect_validate(), after a user has has finished&#10; * editing the redirect and is submitting it. It is invoked at the end of all&#10; * the standard validation steps.&#10; *&#10; * To indicate a validation error, use form_set_error().&#10; *&#10; * Note: Changes made to the $redirect object within your hook implementation&#10; * will have no effect. The preferred method to change a redirect's content is&#10; * to use hook_redirect_presave() instead. If it is really necessary to change&#10; * the redirect at the validate stage, you can use form_set_value().&#10; *&#10; * @param $redirect&#10; *   The redirect being validated.&#10; * @param $form&#10; *   The form being used to edit the redirect.&#10; * @param $form_state&#10; *   The form state array.&#10; *&#10; * @see redirect_validate()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_validate($redirect, $form, $form_state) {&#10;&#10;  $END$&#10;}" description="hook_redirect_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_validate" value="/**&#10; * Implements hook_redirect_validate().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_validate($redirect, $form, $form_state) {&#10;&#10;  $END$&#10;}" description="hook_redirect_validate" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_presave" value="/**&#10; * Implements hook_redirect_presave().&#10; *&#10; * Act on a redirect being inserted or updated.&#10; *&#10; * This hook is invoked from redirect_save() before the redirect is saved to&#10; * the database.&#10; *&#10; * @param $redirect&#10; *   The redirect that is being inserted or updated.&#10; *&#10; * @see redirect_save()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_presave($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_presave" value="/**&#10; * Implements hook_redirect_presave().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_presave($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_presave" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_insert" value="/**&#10; * Implements hook_redirect_insert().&#10; *&#10; * Respond to creation of a new redirect.&#10; *&#10; * This hook is invoked from redirect_save() after the redirect is inserted&#10; * into the redirect table in the database.&#10; *&#10; * @param $redirect&#10; *   The redirect that is being created.&#10; *&#10; * @see redirect_save()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_insert($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_insert" value="/**&#10; * Implements hook_redirect_insert().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_insert($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_insert" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_update" value="/**&#10; * Implements hook_redirect_update().&#10; *&#10; * Respond to updates to a redirect.&#10; *&#10; * This hook is invoked from redirect_save() after the redirect is updated in&#10; * the redirect table in the database.&#10; *&#10; * @param $redirect&#10; *   The redirect that is being updated.&#10; *&#10; * @see redirect_save()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_update($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_update" value="/**&#10; * Implements hook_redirect_update().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_update($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_update" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_delete" value="/**&#10; * Implements hook_redirect_delete().&#10; *&#10; * Respond to redirect deletion.&#10; *&#10; * This hook is invoked from redirect_delete_multiple() after the redirect has&#10; * been removed from the redirect table in the database.&#10; *&#10; * @param $redirect&#10; *   The redirect that is being deleted.&#10; *&#10; * @see redirect_delete_multiple()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_delete($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_delete" value="/**&#10; * Implements hook_redirect_delete().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_delete($redirect) {&#10;&#10;  $END$&#10;}" description="hook_redirect_delete" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="hook_redirect_alter" value="/**&#10; * Implements hook_redirect_alter().&#10; *&#10; * Act on a redirect being redirected.&#10; *&#10; * This hook is invoked from redirect_redirect() before the redirect callback&#10; * is invoked.&#10; *&#10; * @param $redirect&#10; *   The redirect that is being used for the redirect.&#10; *&#10; * @see redirect_redirect()&#10; * @see drupal_page_is_cacheable()&#10; * @ingroup redirect_api_hooks&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_alter($redirect) {&#10;  $END$&#10;}" description="hook_redirect_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
  <template name="h_redirect_alter" value="/**&#10; * Implements hook_redirect_alter().&#10; *&#10; * $COMMENT$&#10; */&#10;function $MODULE_NAME$_redirect_alter($redirect) {&#10;  $END$&#10;}" description="hook_redirect_alter" toReformat="false" toShortenFQNames="true">
    <variable name="COMMENT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="MODULE_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="HTML_TEXT" value="false" />
      <option name="HTML" value="false" />
      <option name="XSL_TEXT" value="false" />
      <option name="XML" value="false" />
      <option name="CSS" value="false" />
      <option name="JAVA_SCRIPT" value="false" />
      <option name="JSP" value="false" />
      <option name="SQL" value="false" />
      <option name="PHP" value="true" />
      <option name="OTHER" value="false" />
    </context>
  </template>
</templateSet>

